{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo • All posts by \"java学习路线\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/10/12/%E7%BC%96%E7%A8%8B/%E5%B0%9A%E7%A1%85%E8%B0%B7Git/",
            "url": "http://example.com/2023/10/12/%E7%BC%96%E7%A8%8B/%E5%B0%9A%E7%A1%85%E8%B0%B7Git/",
            "title": "尚硅谷Git",
            "date_published": "2023-10-12T10:49:32.912Z",
            "content_html": "<h1 id=\"git使用\"><a class=\"markdownIt-Anchor\" href=\"#git使用\">#</a> Git 使用</h1>\n<p><code>C:\\\\Users\\\\86136\\\\git.config</code>  是 Git 的配置文件。</p>\n<p>按住 ctrl 键，滑动鼠标中键可以放大和缩小字体大小。</p>\n<p>使用 init 命令创建库成功后，会在该文件夹下创建一个.git 文件夹，默认是隐藏的，可以通过显示隐藏项目进行查看。</p>\n<p>红色代表该文件只存在于工作区，绿色代表文件已经上传到暂存区。</p>\n<p>只有将暂存区的文件提交到本地库，才会形成本地的历史记录。</p>\n<p>git 是以行的作为维护的，所以在原来的行上修改，会先删除改行，然后重新写入修改后的行。</p>\n<p>在.git 文件夹下的 refs 的 heads 目录的 main 文件可以查看当前版本号。</p>\n<p><strong>合并分支时，两个分支在同一个文件的同一个位置上有两套完全不同的修改，Git 无法替我们决定使用哪一个，必须人为决定新代码内容。</strong></p>\n<p><strong>首先使用 vim 命令对内容进行合并，然后将文件提交到暂存区，最后执行提交 (注意此时使用 git commit 命令时不能带文件名)。此时修改的只是当前分支，合并进来的分支的文件不会被修改。</strong></p>\n<p>各个分支其实都是指向具体版本的指针，当前所在的分支其实是由 HEAD 指针决定的，所以创建分支的本质就是多创建一个指针。</p>\n<p>clone 操作会进行如下操作：1、拉取代码。2、初始化本地仓库。3、创建别名。</p>\n<p>fork 别人代码后进行修改完成后，可以通过点击 pull request 想对方发送请求。对方可以在 pull request 查看，如果可以的话点击 Merge pull request 进行合并。</p>\n<h1 id=\"git常用命令\"><a class=\"markdownIt-Anchor\" href=\"#git常用命令\">#</a> Git 常用命令</h1>\n<table>\n<thead>\n<tr>\n<th>命令名称</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git config --global <a class=\"link\"   href=\"http://user.name\" >user.name <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a> 用户名</td>\n<td>设置用户签名</td>\n</tr>\n<tr>\n<td>git config --global user.email 邮箱</td>\n<td>设置用户邮箱</td>\n</tr>\n<tr>\n<td>git init</td>\n<td>初始化本地库</td>\n</tr>\n<tr>\n<td>git status</td>\n<td>查看本地库状态</td>\n</tr>\n<tr>\n<td>git add 文件名</td>\n<td>添加到暂存区</td>\n</tr>\n<tr>\n<td>git commit -m “日志信息” 文件名</td>\n<td>提交到本地库</td>\n</tr>\n<tr>\n<td>git reflog</td>\n<td>查看历史记录</td>\n</tr>\n<tr>\n<td>git reset --hard 版本号</td>\n<td>版本穿梭，版本号为 reflog 命令的七位随机码</td>\n</tr>\n<tr>\n<td>git add 文件名</td>\n<td>将文件加入到暂存区</td>\n</tr>\n<tr>\n<td>git rm --cached 文件名</td>\n<td>删除暂存区中的文件</td>\n</tr>\n<tr>\n<td>git commit -m “日志信息” 文件名</td>\n<td>将暂存区的文件提交到本地库中</td>\n</tr>\n<tr>\n<td>git reflog</td>\n<td>查看版本信息</td>\n</tr>\n<tr>\n<td>git log</td>\n<td>查看详细版本信息</td>\n</tr>\n<tr>\n<td>git branch 分支名</td>\n<td>创建分支</td>\n</tr>\n<tr>\n<td>git branch -v</td>\n<td>查看分支</td>\n</tr>\n<tr>\n<td>git checkout ‘分支名’</td>\n<td>切换分支</td>\n</tr>\n<tr>\n<td>git merge 分支名</td>\n<td>把指定的分组合并到当前分支上</td>\n</tr>\n<tr>\n<td>git remote -v</td>\n<td>查看当前所有远程地址别名</td>\n</tr>\n<tr>\n<td>git remote add 别名 远程地址</td>\n<td>起别名</td>\n</tr>\n<tr>\n<td>git push 别名 分支</td>\n<td>推送本地分支上的内容到远程仓库</td>\n</tr>\n<tr>\n<td>git clone 远程地址</td>\n<td>将远程仓库的内容克隆到本地</td>\n</tr>\n<tr>\n<td>git pull 远程库地址别名 远程分支名</td>\n<td>将远程仓库对应分支最新内容拉下来后与当前本地分支直接合并</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"linux常用命令\"><a class=\"markdownIt-Anchor\" href=\"#linux常用命令\">#</a> Linux 常用命令</h1>\n<table>\n<thead>\n<tr>\n<th>命令名称</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ll</td>\n<td>显示当前目录下的文档详细信息，加上 - a 可以查看隐藏信息</td>\n</tr>\n<tr>\n<td>ls</td>\n<td>当前目录的文档名</td>\n</tr>\n<tr>\n<td>yy</td>\n<td>复制当前行，需要退出编辑状态</td>\n</tr>\n<tr>\n<td>p</td>\n<td>粘贴当前行，需要退出编辑状态</td>\n</tr>\n<tr>\n<td>i 或 insert</td>\n<td>进入编辑状态</td>\n</tr>\n<tr>\n<td>:wq!</td>\n<td>退出编辑状态</td>\n</tr>\n<tr>\n<td>cat 文件名</td>\n<td>查看对应文件</td>\n</tr>\n<tr>\n<td>clear</td>\n<td>清除当前界面的命令行</td>\n</tr>\n</tbody>\n</table>\n<p>使用 vim 命令创建新文件时，需要按 i 键或 insert 键进入编辑状态。退出编辑状态则是按 esc 键，然后输入 <code>:wq!</code>  回车退出。</p>\n<h1 id=\"git集成idea\"><a class=\"markdownIt-Anchor\" href=\"#git集成idea\">#</a> Git 集成 IDEA</h1>\n<p>创建忽略规则文件 <code>xxx.ignore</code> ，来屏蔽不需要的文件，因为这些文件与项目的实际功能无关，不参与服务器部署运行，把它们忽略掉能够屏蔽 IDE 工具之间的差异。配置文件后在.gitconfig 文件中设置引用该文件。</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//git.ignore文件配置，写上需要忽略的文件后缀</span><br><span class=\"line\"># Compiled class file</span><br><span class=\"line\">*.class</span><br><span class=\"line\"></span><br><span class=\"line\"># Log file</span><br><span class=\"line\">*.log</span><br><span class=\"line\"></span><br><span class=\"line\"># BlueJ files</span><br><span class=\"line\">*.ctxt</span><br><span class=\"line\"></span><br><span class=\"line\"># Mobile Tools for Java (J2ME)</span><br><span class=\"line\">.mtj.tmp/# Package Files #</span><br><span class=\"line\">*.jar</span><br><span class=\"line\">*.war</span><br><span class=\"line\">*.nar</span><br><span class=\"line\">*.ear</span><br><span class=\"line\">*.zip</span><br><span class=\"line\">*.tar.gz</span><br><span class=\"line\">*.rar</span><br><span class=\"line\"></span><br><span class=\"line\">hs_err_pid*</span><br><span class=\"line\"></span><br><span class=\"line\">.classpath</span><br><span class=\"line\">.project</span><br><span class=\"line\">.settings</span><br><span class=\"line\">target</span><br><span class=\"line\">.idea</span><br><span class=\"line\">*.iml</span><br><span class=\"line\">//.gitconfig文件</span><br><span class=\"line\">[core]</span><br><span class=\"line\">  excludesfile = git.ignore文件所在路径，记得将反斜线(/)改为斜线(\\)</span><br></pre></td></tr></table></figure></div>\n<p>idea 则是在设置的 Version Control 下的 Git，并设置路径为 Git 安装目录的 C:\\Program Files\\Git\\bin\\git.exe。</p>\n<p>设置完成后还需要完成初始化，在 VCS (Version Control Setting) 下选择 import into Version Control 下的 Create Git Repository 才算真正完成初始化，此时 Git 接管了该项目。</p>\n<p>蓝色的代表之前已经被追踪过，可以不用 add，直接 commit 到本地库。</p>\n<p>如果想要将本地代码库推送到远程库，一定要保证本地库的版本要比远程库的版本高。因此一共成熟的程序员在动手改本地代码之前，一定会先检查远程库和本地库代码的区别。</p>\n",
            "tags": [
                "java学习路线",
                "计算机基础"
            ]
        },
        {
            "id": "http://example.com/2023/10/12/java/Linux-%E9%9F%A9%E9%A1%BA%E5%B9%B3/Linux-%E9%9F%A9%E9%A1%BA%E5%B9%B3/",
            "url": "http://example.com/2023/10/12/java/Linux-%E9%9F%A9%E9%A1%BA%E5%B9%B3/Linux-%E9%9F%A9%E9%A1%BA%E5%B9%B3/",
            "title": "Linux-韩顺平",
            "date_published": "2023-10-12T10:49:32.902Z",
            "content_html": "<h1 id=\"基础篇\"><a class=\"markdownIt-Anchor\" href=\"#基础篇\">#</a> 基础篇</h1>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"F:%5Cblog%5Cmyblog%5Csource%5C_posts%5Cjava%5CLinux-%E9%9F%A9%E9%A1%BA%E5%B9%B3%5C186662223856814ec6f2295c8a23c346.png\"\n                      alt=\"截图\"\n                ></p>\n<p>Linux 分区一般分为：boot 分区、交换分区和根分区。</p>\n<p>虚拟系统安装好后，它的本质就是文件。</p>\n<p>虚拟机克隆：如果你已经安装了一台 liux 操作系统，你还想再更多的，使用虚拟机克隆即可。方式 1，直接拷贝一份安装好的虚拟机文件。然后在 VM 上点击打开对应的 vmx 文件即可。方式 2，使用 vmware 的克隆操作，右键点击管理，后选择克隆即可。注意，克隆时，需要先关闭 linux 系统。</p>\n<p>虚拟机快照：如果你在使用虚拟机系统的时候，你想回到原先的某个状态，也就是说你担心可能有些误操作造成系统异常，需要回到原先某个正常运行的状态，vmware 也提供了这样的功能，就叫快照管理。</p>\n<p>vmtools 安装后可以让我们在 Windows 下更好的管理 VM 虚拟机，可以设置 Windows 和 centos 的共享文件夹。在设置中开启共享文件夹后，可以在主文件夹 -&gt; 其他位置 -&gt;mnt-&gt;hgfs 下找到该文件夹。</p>\n<p>Windows 和 centos 就可以共享文件了，但是在实际开发中，文件的上传下载是需要使用远程方式完成的。</p>\n<p>使用 tab 键可以实现自动补全。</p>\n<p><strong>在 Linux 世界里，一切皆文件。</strong></p>\n<p>三种网络连接模式：桥接模式：虚拟系统可以和外部系统通讯，但是容易导致 IP 冲突。NAT 模式：网络地址转换模式，虚拟系统可以和外部系统通讯，不造成 IP 冲突。主机模式：独立的系统，不与外部系统通讯。</p>\n<p>使用 ifconfig 查看虚拟机的 inet 地址，然后使用 xshell 进行远程连接。</p>\n<h2 id=\"目录结构\"><a class=\"markdownIt-Anchor\" href=\"#目录结构\">#</a> 目录结构</h2>\n<ol>\n<li>/bin (usr/bin、/usr/local/bin) 是 Binary 的缩写，这个目录存放着最经常使用的命令。</li>\n<li>/sbin (/usr/sbin/usr/local/sbin) s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。</li>\n<li>/home 存放普通用户的主目录，在 Linux 中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名。</li>\n<li>/root 该目录为系统管理员，也称作超级权限者的用户主目录。</li>\n<li>/Iib 系统开机所需要最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所 有的应用程序都需要用到这些共享库。</li>\n<li>/lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li>\n<li>/etc 所有的系统管理所需要的配置文件和子目录，比如安装 mysq 数据库 my.conf</li>\n<li>/usr 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与 windows 下的 program files 目录。</li>\n<li>/boot 存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>\n<li>/poc 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。不能轻易修改，否则会导致系统崩溃。</li>\n<li>/srv service 缩写，该目录存放一些服务启动之后需要提取的数据。</li>\n<li>/sys 这是 Iinux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs。</li>\n<li>/tmp 这个目录是用来存放一些临时文件的。</li>\n<li>/dev 类似于 windows 的设备管理器，把所有的硬件用文件的形式存储。</li>\n<li>/media linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下。</li>\n<li>/mnt 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在 /mnt/ 上，然后进入该目录就可以查看里的内容了。例如 d:/myshare。</li>\n<li>/opt 这是给主机额外安装软件所存放的目录。如安装 ORACLE 数据库就可放到该目录下。默认为空。</li>\n<li>/usr/Iocal 这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。</li>\n<li>/var 这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。</li>\n<li>/selinux [security-enhanced linux] SELinux 是一种安全子系统，它能控制程序只能访问特定文件，有三种工作模式，可以自行设置。</li>\n</ol>\n<h1 id=\"linux实操篇\"><a class=\"markdownIt-Anchor\" href=\"#linux实操篇\">#</a> Linux 实操篇</h1>\n<h2 id=\"vi和vim\"><a class=\"markdownIt-Anchor\" href=\"#vi和vim\">#</a> vi 和 vim</h2>\n<h3 id=\"vi和vim的三种模式\"><a class=\"markdownIt-Anchor\" href=\"#vi和vim的三种模式\">#</a> vi 和 vim 的三种模式</h3>\n<ol>\n<li>正常模式：以 vim 打开一个档案就直接进入一般模式（这是默认的，模式）。在这个模式中，你可以使用方向按键来移动光标，使用删除字符或删除整行来处理档案内容，也可以使用复制、粘贴来处理文件数据。</li>\n<li>编辑模式：按下 i、I、o、O、a、A、r、R 等任何一个字母之后才会进入编辑模式，一般是按 i。</li>\n<li>命令行模式：输入 esc 后再输入：。在该模式下，可以提供相关指令完成读取、存盘、替换、离开 vim、显示行号等动作。</li>\n</ol>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"F:%5Cblog%5Cmyblog%5Csource%5C_posts%5Cjava%5CLinux-%E9%9F%A9%E9%A1%BA%E5%B9%B3%5C209330823b8a08dcde2343614bf23ba0.png\"\n                      alt=\"无标题-2023-02-20-1711.png\"\n                ></p>\n<h3 id=\"快捷键使用\"><a class=\"markdownIt-Anchor\" href=\"#快捷键使用\">#</a> 快捷键使用</h3>\n<ol>\n<li>拷贝当前行 yy, 拷贝当前行向下的 5 行 5yy, 并粘贴（输入 P)。 注意不要使用小键盘的数字，否则会进入编辑模式。</li>\n<li>删除当前行 dd, 删除当前行向下的 5 行 5dd。</li>\n<li>在文件中查找某个单词 [命令行下输入 / 关键字，回车查找，输入 n 就是查找下一个]</li>\n<li>设置文件的行号，取消文件的行号。[命令行下:set nu 和:set nonu) 。</li>\n<li>编辑 /etc/profile 文件，在一般模式下使用快捷键到该文档的最末行 [G] 和最首行 [gg]。注意是区分大小写的。</li>\n<li>在一个文件中输入 &quot;hello”, 然后又撤销这个动作 u。</li>\n<li>编辑 /etc/profile 文件，在一般模式下，并将光标移动到，输入 20，再输入 20 行 shift+g。</li>\n</ol>\n<h2 id=\"关机-重启和用户登录注销\"><a class=\"markdownIt-Anchor\" href=\"#关机-重启和用户登录注销\">#</a> 关机、重启和用户登录注销</h2>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>shutdown -h now</td>\n<td>立刻关机</td>\n</tr>\n<tr>\n<td>shutdown -h 1</td>\n<td>1 分钟后关机，shutdown 默认结果</td>\n</tr>\n<tr>\n<td>shutdown -r now</td>\n<td>立即重启计算机</td>\n</tr>\n<tr>\n<td>halt</td>\n<td>关机</td>\n</tr>\n<tr>\n<td>reboot</td>\n<td>重启</td>\n</tr>\n<tr>\n<td>sync</td>\n<td>把内存中的数据同步到磁盘</td>\n</tr>\n</tbody>\n</table>\n<p>不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。目前的 shutdown/reboot/halt 等命令均已经在关机前进行了 sync。</p>\n<p>登录时尽量少用 root 帐号登录，因为它是系统管理员，拥有最大的权限，避免操作失误。可以利用 普通用户登录，登录后再用”su - 用户名’命令来切换成系统管理员身份.。</p>\n<p>在提示符下输入 logout 即可注销用户，logout 注销指令在图形运行级别无效，在运行级别 3 下有效。</p>\n<h2 id=\"用户管理\"><a class=\"markdownIt-Anchor\" href=\"#用户管理\">#</a> 用户管理</h2>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>useradd milan</td>\n<td>添加用户，默认该用户的家目录在 /home/milan</td>\n</tr>\n<tr>\n<td>useradd -d 指定目录 新用户名</td>\n<td>给新创建的用户指定家目录</td>\n</tr>\n<tr>\n<td>passwd 用户名</td>\n<td>修改用户的密码</td>\n</tr>\n<tr>\n<td>pwd</td>\n<td>显示当前用户所在目录</td>\n</tr>\n<tr>\n<td>userdel 用户名</td>\n<td>删除用户，但保留用户主目录</td>\n</tr>\n<tr>\n<td>userdel -r 用户名</td>\n<td>删除用户及其主目录</td>\n</tr>\n<tr>\n<td>id 用户名</td>\n<td>查询用户信息</td>\n</tr>\n<tr>\n<td>su - jack</td>\n<td>切换到 jack 用户</td>\n</tr>\n<tr>\n<td>who am i</td>\n<td>查询第一次登录的用户名</td>\n</tr>\n<tr>\n<td>whoami</td>\n<td>显示当前操作的用户名</td>\n</tr>\n</tbody>\n</table>\n<p>使用 su 切换用户时，从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。当需要返回到原来用户时，使用 exit/logout: 指令。</p>\n<p>在新建用户时，如果没有为其指定组，会默认创建一个与用户名同名的组，并进行绑定。</p>\n<h3 id=\"用户和组相关文件\"><a class=\"markdownIt-Anchor\" href=\"#用户和组相关文件\">#</a> 用户和组相关文件</h3>\n<p>/etc/passwd 文件：用户 (user) 的配置文件，记录用户的各种信息。每行的含义：用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录 Shell。</p>\n<p>/etc/shadow 文件：口令的配置文件。每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志。</p>\n<p>/etc/group 文件：组 (group) 的配置文件，记录 Linux 包含的组的信息。每行的含义：组名：口令：组标识号：组内用户列表。</p>\n<h2 id=\"实用指令\"><a class=\"markdownIt-Anchor\" href=\"#实用指令\">#</a> 实用指令</h2>\n<h3 id=\"文件目录类\"><a class=\"markdownIt-Anchor\" href=\"#文件目录类\">#</a> 文件目录类</h3>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>init [0123456]</td>\n<td>切换不同的运行级别</td>\n</tr>\n<tr>\n<td>systemctl get-default</td>\n<td>查看当前运行级别</td>\n</tr>\n<tr>\n<td>systemctl set-default [multi-user.target,graphical.target]</td>\n<td>前者类似运行级别 3，后者类似运行级别 5</td>\n</tr>\n<tr>\n<td>man [命令或配置文件]</td>\n<td>功能描述，获得帮助信息，使用空格键可以往下翻</td>\n</tr>\n<tr>\n<td>help</td>\n<td>获得 shell 内置命令的帮助信息</td>\n</tr>\n<tr>\n<td>pwd</td>\n<td>显示当前工作目录的绝对路径</td>\n</tr>\n<tr>\n<td>ls [选项] [目录或文件]</td>\n<td>-a：显示当前目录的所有文件和目录，包括隐藏的。-l：以列表的方式显示信息</td>\n</tr>\n<tr>\n<td>cd ~</td>\n<td>回到自己的家目录</td>\n</tr>\n<tr>\n<td>cd …</td>\n<td>回到当前目录的上一级目录</td>\n</tr>\n<tr>\n<td>mkdir 目录名</td>\n<td>创建目录，-p 创建多级目录</td>\n</tr>\n<tr>\n<td>rmdir 目录名</td>\n<td>删除空目录</td>\n</tr>\n<tr>\n<td>rm 目录名</td>\n<td>移除文件或目录，-r：递归删除整个文件夹，-f：强制删除不提示</td>\n</tr>\n<tr>\n<td>touch 文件名称</td>\n<td>创建空文件</td>\n</tr>\n<tr>\n<td>cp 要复制的文件名或文件夹 目录名</td>\n<td>拷贝文件到指定目录，-r：递归复制整个文件夹，\\cp 是强制覆盖不提示</td>\n</tr>\n<tr>\n<td>mv oldName newName</td>\n<td>重命名文件</td>\n</tr>\n<tr>\n<td>mv /temp/movefile /targetFolder</td>\n<td>移动文件与目录</td>\n</tr>\n<tr>\n<td>cat 文件名</td>\n<td>查看文件内容，-n：显示行号</td>\n</tr>\n<tr>\n<td>echo 输出内容</td>\n<td>输出内容到控制台</td>\n</tr>\n<tr>\n<td>head -n 5 文件名</td>\n<td>查看文件开头 5 行</td>\n</tr>\n<tr>\n<td>tail 文件名</td>\n<td>输出文件尾部的内容默认显示前 10 行；-n：指定行数；-f：实时追踪该文档的所有更新。使用 - f 时可以使用 ctrl+C 退出浏览。</td>\n</tr>\n<tr>\n<td>ln -s 原文件或目录 软链接名</td>\n<td>给原文件创建一个软链接，相当于快捷方式</td>\n</tr>\n<tr>\n<td>history</td>\n<td>查看历史命令</td>\n</tr>\n</tbody>\n</table>\n<p>基本介绍运行级别说明：0: 关机；1: 单用户，可以用来找回丢失密码； 2: 多用户状态没有网络服务；3: 多用户状态有网络服务；4：系统未使用保留给用户；5：图形界面 6: 系统重启。常用运行级别是 3 和 5，也可以指定默认运行级别。</p>\n<p>在 Linux 中，隐藏文件是以 &quot;.&quot; 开头。</p>\n<p>cat 只能浏览文件，而不能修改文件，为了浏览方便，通常加上管道命令 | more。</p>\n<p><code>&gt;输出重定向和&gt;&gt;追加指令</code> ，重定向是改变默认的输出位置。</p>\n<h4 id=\"more指令交互\"><a class=\"markdownIt-Anchor\" href=\"#more指令交互\">#</a> more 指令交互</h4>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>空白键 (space)</td>\n<td>向下翻一页</td>\n</tr>\n<tr>\n<td>Enter</td>\n<td>向下翻一行</td>\n</tr>\n<tr>\n<td>q</td>\n<td>立即离开 more，不再显示该文件内容</td>\n</tr>\n<tr>\n<td>Ctrl+F</td>\n<td>向下翻动一屏</td>\n</tr>\n<tr>\n<td>Ctrl+B</td>\n<td>返回上一屏</td>\n</tr>\n<tr>\n<td>=</td>\n<td>输出当前行的行号</td>\n</tr>\n<tr>\n<td>:f</td>\n<td>输出文件名和当前行的行号</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"less指令交互\"><a class=\"markdownIt-Anchor\" href=\"#less指令交互\">#</a> less 指令交互</h4>\n<p>less 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各种显示终端。Iess 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>空白键</td>\n<td>向下翻动一页</td>\n</tr>\n<tr>\n<td>pagedown</td>\n<td>向下翻动一页</td>\n</tr>\n<tr>\n<td>pageup</td>\n<td>向上翻动一页</td>\n</tr>\n<tr>\n<td>/ 字符串</td>\n<td>搜寻子串；n：向下查找；N：向上查找</td>\n</tr>\n<tr>\n<td>? 字符串</td>\n<td>搜寻子串；n：向上查找；N：向下查找</td>\n</tr>\n<tr>\n<td>q</td>\n<td>离开 less 程序</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"时间日期类\"><a class=\"markdownIt-Anchor\" href=\"#时间日期类\">#</a> 时间日期类</h3>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>date</td>\n<td>显示当前日期</td>\n</tr>\n<tr>\n<td>date -s 字符串时间</td>\n<td>设置系统时间</td>\n</tr>\n<tr>\n<td>cal</td>\n<td>查看日历</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"搜索查找类\"><a class=\"markdownIt-Anchor\" href=\"#搜索查找类\">#</a> 搜索查找类</h3>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>find 搜索范围 选项</td>\n<td>从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。有 name、user 和 size 三种查找选项。</td>\n</tr>\n<tr>\n<td>locate 搜索文件</td>\n<td>快速定位文件路径</td>\n</tr>\n<tr>\n<td>which</td>\n<td>可以查看指令的路径</td>\n</tr>\n<tr>\n<td>grep 选项 查找内容 源文件</td>\n<td>过滤查找。-n：显示匹配行及行号；-i：忽略字母大小写</td>\n</tr>\n</tbody>\n</table>\n<p>locate 指令利用事先建立的系统中所有文件名称及路径的 locate 数据库实现快速定位给定的文件。Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新 locatel 数据库。由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库。</p>\n<p><strong>管道符号 “|”，表示将前一个指令的处理结果输出传递给后面的指令处理。</strong></p>\n<h3 id=\"压缩和解压缩类\"><a class=\"markdownIt-Anchor\" href=\"#压缩和解压缩类\">#</a> 压缩和解压缩类</h3>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>gzip 文件名</td>\n<td>压缩文件</td>\n</tr>\n<tr>\n<td>gunzip 文件名.gz</td>\n<td>解压文件</td>\n</tr>\n<tr>\n<td>zip</td>\n<td>压缩文件或文件夹。-r：递归压缩，即压缩目录</td>\n</tr>\n<tr>\n<td>unzip</td>\n<td>解压文件或文件夹。-d：指定解压后文件的存放目录 -</td>\n</tr>\n<tr>\n<td>tar 选项 文件名.tar.gz 打包的内容</td>\n<td>将文件夹打包。-c：产生.tar 打包文件；-v：显示详细信息；-f：指定压缩后的文件名；-z：打包同时压缩；-x：解包 tar 文件</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"组管理和权限管理\"><a class=\"markdownIt-Anchor\" href=\"#组管理和权限管理\">#</a> 组管理和权限管理</h2>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ls -ahl</td>\n<td>查看文件的所有者</td>\n</tr>\n<tr>\n<td>chown 用户名 文件名</td>\n<td>修改文件所有者，-R：如果是目录，则使其下所有子文件或目录递归生效</td>\n</tr>\n<tr>\n<td>chgrp 组名 文件名</td>\n<td>修改文件所在的组，-R：如果是目录，则使其下所有子文件或目录递归生效</td>\n</tr>\n<tr>\n<td>groupadd 组名</td>\n<td>新增组</td>\n</tr>\n<tr>\n<td>groupdel 组名</td>\n<td>删除组</td>\n</tr>\n<tr>\n<td>useradd -g 用户组 用户名</td>\n<td>增加用户的时候直接加上组</td>\n</tr>\n<tr>\n<td>usermod -g 用户组 用户名</td>\n<td>修改用户的组</td>\n</tr>\n<tr>\n<td>chmod u=rwx,g=rx,o=x 文件或目录名</td>\n<td>给文件或目录的所有者读写执行的权限，给所在组读执行权限，给其他组执行权限。+ 增强权限，- 减少权限，= 赋予权限。u 所有者，g 所在组，o 其他组，a 全部用户。</td>\n</tr>\n<tr>\n<td>chmod 751 文件或目录名</td>\n<td>通过数字变更权限，r=4,w=2,x=1，相加得到数字，u=7=4+2+1=rwx,g=5=4+1=rx,o=1=x。因此相当于 chmod u=rwx,g=rx,o=x 文件或目录名。</td>\n</tr>\n</tbody>\n</table>\n<p>在 linux 中的每个用户必须属于一个组，不能独立于组外。在 Linux 中每个文件有所有者、所在组、其它组的概念。</p>\n<p>除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组。</p>\n<h4 id=\"权限基本介绍\"><a class=\"markdownIt-Anchor\" href=\"#权限基本介绍\">#</a> 权限基本介绍</h4>\n<ol>\n<li>第 0 位确定文件类型 (d,-,I,c,b)：I 是链接，相当于 windows 的快捷方式；- 是普通文件；d 是目录，相当于 windows 的文件夹；c 是字符设备：文件，鼠标，键盘；b 是块设备，比如硬盘。</li>\n<li>第 1-3 位确定所有者（该文件的所有者）拥有该文件的权限。</li>\n<li>第 4-6 位确定所属组（同用户组的）拥有该文件的权限。</li>\n<li>第 7-9 位确定其他用户拥有该文件的权限。</li>\n</ol>\n<p><strong>rwx 作用到文件：[r] 代表可读 (read): 可以读取，查看。[w] 代表可写 (write)：可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件。[x] 代表可执行 (execute): 可以被执行.</strong></p>\n<p><strong>rwx 作用到目录：[r] 代表可读 (read): 可以读取，Is 查看目录内容。[w] 代表可写 (write)：可以修改，对目录内创建 + 删除 + 重命名目录。[x] 代表可执行 (execute): 可以进入该目录。</strong></p>\n<p><strong>权限更新会有延时性，系统记录的是你刚开始登录的所在组，需要更新或者重新登录来更新自己的组。</strong></p>\n<h2 id=\"任务调度\"><a class=\"markdownIt-Anchor\" href=\"#任务调度\">#</a> 任务调度</h2>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>crontab</td>\n<td>-e：编辑定时任务；-l：查询任务；-r：删除所有任务</td>\n</tr>\n<tr>\n<td><code>*/1 * * * * ls -l /etc/ &gt; /tmp/to.txt</code></td>\n<td>每小时的每分钟执行一次后面的指令。</td>\n</tr>\n<tr>\n<td>at 选项 时间</td>\n<td>一次性定时任务，输入 ctrl+d 结束 at 命令的输入</td>\n</tr>\n<tr>\n<td>atrm 编号</td>\n<td>删除编号的 at 任务</td>\n</tr>\n</tbody>\n</table>\n<p>任务调度是指系统在某个时间执行的特定的指令或程序。</p>\n<p>at 命令是一次性定时计划任务，at 的守护进程 atd 会以后台模式运行，检查作业队列来运行。默认情况下，atd 守护进程每 60 秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业。 at 命令是一次性定时计划任务，执完一个任务后不再执行此任务了。在使用 at 命令的时候，一定要保证 atd 程的启动，可以使用相关指令 <code>ps -ef | grep atd</code>  来查看。</p>\n<h3 id=\"crontab\"><a class=\"markdownIt-Anchor\" href=\"#crontab\">#</a> crontab</h3>\n<h4 id=\"5个占位符\"><a class=\"markdownIt-Anchor\" href=\"#5个占位符\">#</a> 5 个占位符</h4>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>含义</th>\n<th>范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>第一个 *</td>\n<td>一小时当中的第几分钟</td>\n<td>0-59</td>\n</tr>\n<tr>\n<td>第二个 *</td>\n<td>一天中的第几小时</td>\n<td>0-23</td>\n</tr>\n<tr>\n<td>第三个 *</td>\n<td>一个月当中的第几天</td>\n<td>1-31</td>\n</tr>\n<tr>\n<td>第四个 *</td>\n<td>一年当中的第几月</td>\n<td>1-12</td>\n</tr>\n<tr>\n<td>第五个 *</td>\n<td>一周当中的星期几</td>\n<td>0-7（0 和 7 都代表星期日）</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"特殊符号\"><a class=\"markdownIt-Anchor\" href=\"#特殊符号\">#</a> 特殊符号</h4>\n<table>\n<thead>\n<tr>\n<th>特殊符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*</td>\n<td>代表任何时间。比如第一个 “*” 就代表一小时中每分钟都执行一次的意思。</td>\n</tr>\n<tr>\n<td>,</td>\n<td>代表不连续的时间。比如 “ <code>0 8,12,16 * * *</code>  命令”，就代表在每天的 8 点 0 分，12 点 0 分，16 点 0 分都执行一次命令。</td>\n</tr>\n<tr>\n<td>-</td>\n<td>代表连续的时间范围。比如 “ <code>0 5 * * 1-6</code>  命令”，代表在周一到周六的凌晨 5 点 0 分执行命令。</td>\n</tr>\n<tr>\n<td>*/n</td>\n<td>代表每隔多久执行一次。比如 “ <code>*/10 * * * *</code>  命令”，代表每隔 10 分钟就执行一遍命令。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"at命令\"><a class=\"markdownIt-Anchor\" href=\"#at命令\">#</a> at 命令</h3>\n<h4 id=\"at命令选项\"><a class=\"markdownIt-Anchor\" href=\"#at命令选项\">#</a> at 命令选项</h4>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-m</td>\n<td>当指定的任务被完成后，将给用户发送邮件，即使没有标准输出</td>\n</tr>\n<tr>\n<td>-I</td>\n<td>atq 的别名</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>atrm 的别名</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>显示任务将被执行的时间</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>打印任务的内容到标准输出</td>\n</tr>\n<tr>\n<td>-V</td>\n<td>显示版本信息</td>\n</tr>\n<tr>\n<td>-q &lt;队列&gt;</td>\n<td>使用指定的队列</td>\n</tr>\n<tr>\n<td>-f &lt;文件&gt;</td>\n<td>从指定文件读入任务而不是从标准输入读入</td>\n</tr>\n<tr>\n<td>-t &lt;时间参数&gt;</td>\n<td>以时间参数的形式提交要运行的任务</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"at时间定义\"><a class=\"markdownIt-Anchor\" href=\"#at时间定义\">#</a> at 时间定义</h4>\n<ol>\n<li>接受在当天的 hh:mm (小时：分钟) 式的时间指定。假如该时间已过去，那么就放在第二天执行。例如： 04:00。</li>\n<li>使用 midnight (深夜)，noon (中午)，teatime (饮茶时间，一般是下午 4 点) 等比较模糊的词语来指定时间。</li>\n<li>采用 12 小时计时制，即在时间后面加上 AM (上午) 或 PM (下午) 来说明是上午还是下午。例如：12pm。</li>\n<li>指定命令执行的具体日期，指定格式为 month day (月 日) 或 mm/dd/yy (月 / 日 / 年) 或 dd.mm.yy（日。月. 年)，指定的日期必须跟在指定时间的后面。例如：04:00 2021-03-1。</li>\n<li>使用相对计时法。指定格式为：now+count time-units,now 就是当前时间，time-units 是时间单位，这里能够是 minutes (分钟)、hours (小时)、days (天)、weeks (星期)。count 是时间的数量，几天，几小时。例如：now+5 minutes。</li>\n<li>直接使用 today (今天)、tomorrow (明天) 来指定完成命令的时间。</li>\n</ol>\n<h2 id=\"磁盘分区与挂载\"><a class=\"markdownIt-Anchor\" href=\"#磁盘分区与挂载\">#</a> 磁盘分区与挂载</h2>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>lsblk</td>\n<td>查看磁盘分区情况，-f 可以查看更详细的信息</td>\n</tr>\n<tr>\n<td>fdisk /dev/sdb</td>\n<td>对 sdb 硬盘进行分区</td>\n</tr>\n<tr>\n<td>mkfs -t 分区类型 /dev/sdb1</td>\n<td>格式化 sdb1 磁盘</td>\n</tr>\n<tr>\n<td>mount 磁盘名 文件夹名</td>\n<td>将磁盘挂载到文件夹上</td>\n</tr>\n<tr>\n<td>umount 磁盘名或文件夹名</td>\n<td>取消挂载</td>\n</tr>\n<tr>\n<td>df -h</td>\n<td>查询系统整体磁盘使用情况</td>\n</tr>\n<tr>\n<td>du -h 目录名</td>\n<td>查询指定目录的磁盘占用情况</td>\n</tr>\n<tr>\n<td>tree 目录名</td>\n<td>以树状显示目录结构，可能需要使用 yum install tree 安装该指令</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"增加硬盘的步骤\"><a class=\"markdownIt-Anchor\" href=\"#增加硬盘的步骤\">#</a> 增加硬盘的步骤</h3>\n<ol>\n<li>虚拟机添加硬盘：在【虚拟机】菜单中，选择【设置】，然后设备列表里添加硬盘，然后一路【下一步】，中间只有选择磁盘大小的地方需要修改，直到完成。然后重启系统（才能识别）！</li>\n<li>分区：开始分区后输入 n，新增分区，然后选择 p，分区类型为主分区。两次回车默认剩余全部空间。最后输入 w 写入分区并退出，若不保存退出输入 q。</li>\n<li>格式化。</li>\n<li>挂载：用命令行挂载是临时的，重启后会失效。永久挂载通过修改 /etc/fstab 文件实现挂载，添加完成后执行 mount -a 立即生效。</li>\n</ol>\n<h2 id=\"网络配置\"><a class=\"markdownIt-Anchor\" href=\"#网络配置\">#</a> 网络配置</h2>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ifconfig</td>\n<td>查看 Linux 的网络配置</td>\n</tr>\n<tr>\n<td>ipconfig</td>\n<td>查看 Windows 的网络配置</td>\n</tr>\n<tr>\n<td>ping 目的主机</td>\n<td>测试当前服务器是否可以连接目的主机</td>\n</tr>\n<tr>\n<td>service network restart</td>\n<td>重启网络服务</td>\n</tr>\n</tbody>\n</table>\n<p>指定 IP 地址：直接修改配置文件来指定 IP, 并可以连接到外网。编辑 vim /etc/sysconfig/network-scripts/ifcfg-ens33。修改后重启网络服务或重启系统生效。</p>\n<p>通过 vim /etc/hostname 修改主机名，修改后重启生效。</p>\n<p>主机名与 hosts 映射。Windows 端：在 C:\\Windows\\System32\\drivers\\etc\\hosts 文件指定。Linux 端：在 /etc/hosts 文件指定。</p>\n<h2 id=\"进程管理\"><a class=\"markdownIt-Anchor\" href=\"#进程管理\">#</a> 进程管理</h2>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ps</td>\n<td>查看目前系统中，有哪些正在执行，以及执行情况。-a：显示当前终端的所有进程信息；-u：以用户的格式显示进程信息；-x：显示后台程序运行的参数。</td>\n</tr>\n<tr>\n<td>kill 选项 进程号</td>\n<td>通过进程号终止进程。-9 表示强制进程立即停止。</td>\n</tr>\n<tr>\n<td>killall 进程名称</td>\n<td>通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用。</td>\n</tr>\n<tr>\n<td>pstree 选项</td>\n<td>查看进程树。-p：显示进程的 PID；-u：显示进程的所属用户。</td>\n</tr>\n<tr>\n<td>service 服务名 选项</td>\n<td>管理服务</td>\n</tr>\n<tr>\n<td>setup</td>\n<td>查看所有系统服务，带 * 的会自启动</td>\n</tr>\n<tr>\n<td>chkconfig</td>\n<td>给服务的各个运行级别设置自启动或关闭，需要重启后生效。</td>\n</tr>\n<tr>\n<td>systemctl 选项 服务名</td>\n<td>管理服务</td>\n</tr>\n<tr>\n<td>firewall-cmd --permanent --add-port = 端口号 / 协议</td>\n<td>打开端口，改为–remove=port 则是关闭端口</td>\n</tr>\n<tr>\n<td>firewall-cmd --reload</td>\n<td>重新载入后才能生效</td>\n</tr>\n<tr>\n<td>firewall-cmd --permanent --query-port = 端口号 / 协议</td>\n<td>查询端口是否开放</td>\n</tr>\n<tr>\n<td>top 选项</td>\n<td>用于动态更新正在执行的进程</td>\n</tr>\n<tr>\n<td>netstat 选项</td>\n<td>查看系统网络情况。-an：按一定顺序排列输出；-p：显示哪个进程在调用</td>\n</tr>\n<tr>\n<td>ping 对方 ip</td>\n<td>网络检测工具</td>\n</tr>\n</tbody>\n</table>\n<p>ps 指令依次显示进程执行用户、进程号、占用 CPU 的百分比、占用虚拟内存的百分比、占用物理内存的百分比、终端信息、当前运行状态、开始时间、占用的 CPU 时间和执行该进程的指令。</p>\n<p>PPID 是父进程 ID。</p>\n<p>服务 (service) 本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如 (mysqld,sshd 防火墙等)，因此我们又称为守护进程，是 Linux 中非常重要的知识点。</p>\n<p>systemctl 指令关闭或者启用防火墙后，立即生效。但这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置。如果希望设置某个服务自启动或关闭永久生效，要使用 systemctl 的 enable 和 disable 选项。</p>\n<p>service 管理的指令可以在 /etc/init.d 查看。</p>\n<p>systemctl 指令管理的服务在 /usr/Iib/systemd/system 查看。</p>\n<p>使用 dism /Online/Enable-Feature /FeatureName:TelnetClient 指令在 Windows 安装 Telnet 指令。</p>\n<h2 id=\"rpm和yum\"><a class=\"markdownIt-Anchor\" href=\"#rpm和yum\">#</a> RPM 和 YUM</h2>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rpm -qa</td>\n<td>查询已安装的 RPM 列表</td>\n</tr>\n<tr>\n<td>rpm -q firefox</td>\n<td>查询软件是否安装</td>\n</tr>\n<tr>\n<td>yum list</td>\n<td>查询可以安装的软件</td>\n</tr>\n<tr>\n<td>yum install 包名</td>\n<td>按照指定的 yum 包</td>\n</tr>\n</tbody>\n</table>\n<p>rpm 用于互联网下载包的打包及安装工具，它包含在某些 Linux 分发版中。它生成具有.RPM 扩展名的文件。RPM 是 RedHat Package Manager (RedHats 软件包管理工具) 的缩写，类似 windows 的 setup.exe，这一文件格式名称虽然打上了 RedHat 的标志，但理念是通用的。</p>\n<p>可以在光盘的 package 文件夹中找需要按照的 rpm 包。</p>\n<p>yum 是一个 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。</p>\n<h1 id=\"提高篇\"><a class=\"markdownIt-Anchor\" href=\"#提高篇\">#</a> 提高篇</h1>\n<h2 id=\"java\"><a class=\"markdownIt-Anchor\" href=\"#java\">#</a> java</h2>\n<p>安装 jdk 要注意写入环境变量，并在写入后更新文件。</p>\n<p>安装 Tomcat 要注意打开防火墙的端口。</p>\n<p>安装 idea 要注意在图像界面启动.sh 文件，因为安装时需要图形界面。</p>\n<p>安装 MySQL 时，centos7.6 自带的类 mysql 数据库是 mariadb，会跟 mysql 冲突，要先删除。</p>\n<h2 id=\"shell\"><a class=\"markdownIt-Anchor\" href=\"#shell\">#</a> shell</h2>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>set</td>\n<td>显示当前 shell 中的所有变量</td>\n</tr>\n<tr>\n<td>变量 = 值</td>\n<td>定义变量</td>\n</tr>\n<tr>\n<td>unset 变量</td>\n<td>撤销变量</td>\n</tr>\n<tr>\n<td>readonly 变量</td>\n<td>声明静态变量，不能 unset</td>\n</tr>\n<tr>\n<td>export 变量名 = 变量值</td>\n<td>将 shell 变量输出为环境变量 / 全局变量</td>\n</tr>\n<tr>\n<td>source 配置文件</td>\n<td>刷新配置文件使其生效</td>\n</tr>\n<tr>\n<td>echo $ 变量名</td>\n<td>输出变量的值</td>\n</tr>\n<tr>\n<td>:&lt;&lt;! 内容！</td>\n<td>多行注释，注释符号需要分行</td>\n</tr>\n<tr>\n<td>$$</td>\n<td>当前进程的进程号 (PID)</td>\n</tr>\n<tr>\n<td>$!</td>\n<td>后台运行的最后一个进程的进程号 (PID)</td>\n</tr>\n<tr>\n<td>$?</td>\n<td>最后一次执行的命令的返回状态。如果这个变量的值为 0，证明上一个命令正确执行；如果这个变量的值为非 0 则证明上一个命令执行不正确。</td>\n</tr>\n<tr>\n<td><code>$((运算符))</code>  或 <code>$[运算式]</code>  或 expr 运算式</td>\n<td>算术运算，expr 运算符间要有空格且乘法需要 / 转义符号</td>\n</tr>\n<tr>\n<td>[ condition ]</td>\n<td>条件判断，condition 前后有空格，非空返回 true</td>\n</tr>\n<tr>\n<td>read 选项 参数</td>\n<td>读取用户的输入。-p 设置提示信息；-t 设置等待时间。</td>\n</tr>\n<tr>\n<td>basename pathname suffix</td>\n<td>返回完整路径最后的 / 的部分，常用于获取文件名，suffix 选择是否去掉该后缀</td>\n</tr>\n<tr>\n<td>dirname</td>\n<td>返回完整路径最后的 / 的前面的部分，常用于获取路径部分。</td>\n</tr>\n</tbody>\n</table>\n<p>Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序。用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序。</p>\n<p>脚本需要以 #!/bin/bash 开头，还需要有可执行权限。</p>\n<p>Linux Shellr 中的变量分为，系统变量和用户自定义变量。系统变量： <code>$HOME、$PWD、$SHELL、$USER</code>  等等。</p>\n<h3 id=\"定义变量的规则\"><a class=\"markdownIt-Anchor\" href=\"#定义变量的规则\">#</a> 定义变量的规则</h3>\n<ol>\n<li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头。5A=200 这样是错误的。</li>\n<li>等号两侧不能有空格变量。</li>\n<li>名称一般习惯为大写。</li>\n<li>将命令的返回值赋给变量：A= <code>date</code>  反引号，运行里面的命令，并把结果返回给变量 A。A=$(date) 等价于反引号。</li>\n</ol>\n<h3 id=\"位置参数变量\"><a class=\"markdownIt-Anchor\" href=\"#位置参数变量\">#</a> 位置参数变量</h3>\n<p>当我们执行一个 shell 脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量。比如：./myshell.sh100 200，这个就是一个执行 shell 的命令行，可以在 myshell 脚本中获取到参数信息。</p>\n<table>\n<thead>\n<tr>\n<th>语法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$n</td>\n<td>n 为数字， <code>$0</code>  代表命令本身， <code>$1</code> - <code>$9</code>  代表第一到第九个参数，十以上的参数需要用大括号包含，如 <code>$&#123;10&#125;</code> 。</td>\n</tr>\n<tr>\n<td>$*</td>\n<td>这个变量代表命令行中所有的参数，$* 把所有的参数看成一个整体。</td>\n</tr>\n<tr>\n<td>$@</td>\n<td>这个变量也代表命令行中所有的参数，不过 $@把每个参数区分对待。</td>\n</tr>\n<tr>\n<td>$#</td>\n<td>这个变量代表命令行中所有参数的个数。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"流程控制\"><a class=\"markdownIt-Anchor\" href=\"#流程控制\">#</a> 流程控制</h3>\n<div class=\"highlight-container\" data-rel=\"Sh\"><figure class=\"iseeu highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> -ge 60 ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;及格了&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [ <span class=\"variable\">$1</span> -lt 60 ]</span><br><span class=\"line\"><span class=\"keyword\">then</span> </span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;不及格&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"variable\">$1</span> <span class=\"keyword\">in</span></span><br><span class=\"line\"><span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;周一&quot;</span></span><br><span class=\"line\">;;</span><br><span class=\"line\"><span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;周二&quot;</span></span><br><span class=\"line\">;;</span><br><span class=\"line\">*)</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;other&quot;</span></span><br><span class=\"line\">;;</span><br><span class=\"line\"><span class=\"keyword\">esac</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&quot;$*&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;num is <span class=\"variable\">$i</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\">SUM=0</span><br><span class=\"line\">i=0</span><br><span class=\"line\"><span class=\"keyword\">while</span> [ <span class=\"variable\">$i</span> -le <span class=\"variable\">$1</span> ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    SUM=$[<span class=\"variable\">$SUM</span>+<span class=\"variable\">$i</span>]</span><br><span class=\"line\">    i=$[<span class=\"variable\">$1</span>+1]</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure></div>\n<h3 id=\"自定义函数\"><a class=\"markdownIt-Anchor\" href=\"#自定义函数\">#</a> 自定义函数</h3>\n<h2 id=\"ubuntu\"><a class=\"markdownIt-Anchor\" href=\"#ubuntu\">#</a> Ubuntu</h2>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sudo apt-get update</td>\n<td>更新源</td>\n</tr>\n<tr>\n<td>sudo apt-get install package</td>\n<td>安装包</td>\n</tr>\n<tr>\n<td>sudo apt-get remove package</td>\n<td>删除包</td>\n</tr>\n<tr>\n<td>sudo apt-cache show package</td>\n<td>获取包的相关信息</td>\n</tr>\n<tr>\n<td>sudo apt-get source package</td>\n<td>下载包的源代码</td>\n</tr>\n<tr>\n<td>ssh 用户名 @IP</td>\n<td>在 Linux 上远程连接其他 Linux</td>\n</tr>\n</tbody>\n</table>\n<p>apt 是 Advanced Packaging Tool 的简称，是一款安装包管理工具。在 Ubuntu 下，我们可以使用 apt 命令进行软件包的安装、删除、清理等，类似于 Windows 中的软件管理工具。在 /etc/apt/sources.list 文件中有服务器地址（美国 APT），由于网络问题，通常我们将其改为国内的镜像站。</p>\n<p>和 CentOS 不一样，Ubuntu 默认没有安装 SSHD 服务（使用 netstat 指令查看：apt install net-tools)，因此，我们不能进行远程登录。</p>\n<h2 id=\"日志\"><a class=\"markdownIt-Anchor\" href=\"#日志\">#</a> 日志</h2>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cron</td>\n<td>系统定时任务相关的日志</td>\n</tr>\n<tr>\n<td>lastlog</td>\n<td>系统中所有用户最后一次的登录时间的日志</td>\n</tr>\n<tr>\n<td>message</td>\n<td>系统重要消息的日志。这个日志文件中会记录 Linux 系统的绝大多数重要信息。如果系统出现问题，首先要检查的应该就是这个日志文件。</td>\n</tr>\n<tr>\n<td>secure</td>\n<td>记录验证和授权方面的信息，只要涉及账户和密码的程序都会记录，比如系统的登录、ssh 的登录、su 的切换用户， sudo 的授权，甚至添加用户和修改用户密码都会记录在这个日志文件中。</td>\n</tr>\n<tr>\n<td>ulmp</td>\n<td>记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。这个文件不能用 vi 查看，而要使用 w、who、users 等命令查看</td>\n</tr>\n<tr>\n<td>journalctl</td>\n<td>查看内存日志，重启清空</td>\n</tr>\n</tbody>\n</table>\n<p>系统日志文件的保存位置是 /var/log/。</p>\n<p>在文件 /etc/rsyslog.conf 在可以查看日志的服务。</p>\n<p>由日志服务 rsyslog 记录的日志文件的格式包含以下 4 列：事件产生的时间；产生事件的服务器的主机名；产生事件的服务名或程序名和事件的具体信息。</p>\n<p>/etc/logrotate.conf 记录全局的日志轮替策略，当然也可以单独给某个日志文件指定策略。也可以把某个日志的轮替规则写到 /etc/logrotate.d 目录上。</p>\n<h2 id=\"定制自己的linux系统\"><a class=\"markdownIt-Anchor\" href=\"#定制自己的linux系统\">#</a> 定制自己的 Linux 系统</h2>\n<h3 id=\"linux启动流程\"><a class=\"markdownIt-Anchor\" href=\"#linux启动流程\">#</a> Linux 启动流程</h3>\n<ol>\n<li>Linux 要通过自检，检查硬件设备有没有故障。</li>\n<li>如果有多块启动盘的话，需要在 BIOS 中选择启动磁盘。</li>\n<li>启动 MBR 中的 bootloader 引导程序。</li>\n<li>加载内核文件。</li>\n<li>执行所有进程的父进程、老祖宗 systemd。</li>\n<li>欢迎界面。</li>\n</ol>\n<h2 id=\"源码阅读\"><a class=\"markdownIt-Anchor\" href=\"#源码阅读\">#</a> 源码阅读</h2>\n<table>\n<thead>\n<tr>\n<th>文件夹</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boot</td>\n<td>存放与系统引导相关的代码</td>\n</tr>\n<tr>\n<td>fs</td>\n<td>存放 Linux 支持的文件系统代码</td>\n</tr>\n<tr>\n<td>include</td>\n<td>存放 Linux 核心需要的头文件</td>\n</tr>\n<tr>\n<td>init</td>\n<td>存放初始化相关的源码</td>\n</tr>\n<tr>\n<td>kernel</td>\n<td>存放与内核相关的代码</td>\n</tr>\n<tr>\n<td>lib</td>\n<td>存放库代码</td>\n</tr>\n<tr>\n<td>mm</td>\n<td>内存管理的代码</td>\n</tr>\n<tr>\n<td>tools</td>\n<td>工具相关的代码</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"内核升级\"><a class=\"markdownIt-Anchor\" href=\"#内核升级\">#</a> 内核升级</h2>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>uname -a</td>\n<td>查看当前的内核版本</td>\n</tr>\n<tr>\n<td>yum info kernel -q</td>\n<td>检测内核版本，显示可以升级的内核</td>\n</tr>\n<tr>\n<td>yum update kernel</td>\n<td>升级内核</td>\n</tr>\n<tr>\n<td>yum list kernel -q</td>\n<td>查看已经安装的内核</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"备份与恢复\"><a class=\"markdownIt-Anchor\" href=\"#备份与恢复\">#</a> 备份与恢复</h2>\n<p>linux 的备份和恢复很简单，有两种方式： 1、把需要的文件 (或者分区) 用 TAR 打包就行，下次需要恢复的时候，再解压开覆盖即可。2、使用 dump 和 restore 命令。</p>\n<p>dump 指令在备份分区时，是可以支持增量备份的，如果备份文件或者目录，不再支持增量备份，即只能使用 0 级别备份。</p>\n<h2 id=\"权限管理\"><a class=\"markdownIt-Anchor\" href=\"#权限管理\">#</a> 权限管理</h2>\n<ol>\n<li>注意权限分离，比如：工作中，Liux 系统权限和数据库权限不要在同一个部门权限最小原则，即在满足使用的情况下最少优先。</li>\n<li>减少使用 root 用户，尽量用普通用户 + sudo 提权进行日常操作。</li>\n<li>重要的系统文件，比如 /etc/passwd，/etc/shadow etc/fstab，/etc/sudoers 等，日常建议使用 chattr（change attribute）锁定，需要操作时再打开。</li>\n<li>使用 SUID,SGID,Sticky 设置特殊权限。</li>\n<li>可以利用工具，比如 chkrootkit/rootkit hunter 检测 rootkit 脚本（rootkit 是入侵者使用工具，在不察觉的建立了入侵系统途径)。</li>\n<li>利用工具 Tripwire 检测文件系统完整性。</li>\n</ol>\n<h2 id=\"centos7启动\"><a class=\"markdownIt-Anchor\" href=\"#centos7启动\">#</a> CentOS7 启动</h2>\n<ol>\n<li>硬件引导启动</li>\n<li>GRUB2 启动引导</li>\n<li>内核引导</li>\n<li>systemd 初始化阶段</li>\n</ol>\n",
            "tags": [
                "java学习路线",
                "计算机基础"
            ]
        },
        {
            "id": "http://example.com/2023/10/12/java/%E9%9F%A9%E9%A1%BA%E5%B9%B3%20%E9%9B%B6%E5%9F%BA%E7%A1%8030%E5%A4%A9%E5%AD%A6%E4%BC%9AJava/",
            "url": "http://example.com/2023/10/12/java/%E9%9F%A9%E9%A1%BA%E5%B9%B3%20%E9%9B%B6%E5%9F%BA%E7%A1%8030%E5%A4%A9%E5%AD%A6%E4%BC%9AJava/",
            "title": "零基础30天学会Java-韩顺平-98",
            "date_published": "2023-10-12T10:49:32.884Z",
            "content_html": "<p><a class=\"link\"   href=\"https://www.bilibili.com/video/BV1fh411y7R8?p=9&amp;spm_id_from=pageDriver\" >韩顺平 零基础 30 天学会 Java <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<h1 id=\"第一章-概述\"><a class=\"markdownIt-Anchor\" href=\"#第一章-概述\">#</a> 第一章 概述</h1>\n<p>了解了该视频课程的大纲和 Java 的基本知识，Java1995 年推出，目前稳定维护的有 Java8 和 Java11 版本。</p>\n<p>JVM（Java 虚拟机）：JVM 包含于 JDK 中，Java 虚拟机机制屏蔽了底层运行平台的差别，实现了 “一次编译，到处运行 &quot;</p>\n<p>JRE（Java 运行环境）：JRE=JVM+Java 的核心类库。</p>\n<p>JDK（Java 开发工具包）：JDK=JRE+Java 的开发工具</p>\n<p>在桌面图标里勾选此电脑就可以在桌面显示此电脑了</p>\n<p>dos 命令行快捷键：win+r</p>\n<p>在对应文件夹上地址上输入 cmd 可以直接在该目录下打开命令行</p>\n<p>在控制台，输入 tab 键，可以实现命令补全</p>\n<p><strong>本机 Java8 的 JDK 安装位置：C:\\Program Files\\Java\\jdk1.8.0_211\\bin</strong></p>\n<p><strong>代码存放位置：E:\\java 韩顺平 \\ 练习代码</strong></p>\n<p>环境变量 path 的设置，增加 JAVA_HOME 环境变量，指向 JDK 的安装目录，编辑 path 环境变量，增加 % JAVA_HOME%\\bin</p>\n<p>如果程序中含有中文的时候，使用命令行编译的时候，需要将 sublime 中的文件 -&gt;Set File Encoding to-&gt;GBK，再保存，才能够正确编译成 class 文件，而 GBK 是根据 cmd 设置的编码方式相关</p>\n<p>运行的时候不是输入 Hello.java，而是 Hello，因为它实际运行的是 Hello 这个主类。</p>\n<p>一个源文件中最多只能有一个 public 类，其他类的个数不限。每一个类都就会生成一个对应的 class 文件。也可以将 main 方法写在非 public 类中，然后指定运行非 public 类，这样入口方法就是非 public 的 main 方法。</p>\n<p>在学习新技术时我们要思考它有什么好处，能应用到什么方面。学习新技术时先关注知识点的基本语法和基本语句，暂时不需要考虑细节，然后完成一个基础项目，最后开始考虑研究技术的注意事项、使用细节、使用规范、如何优化。</p>\n<p>java 对单引号和双引号敏感，输出时是使用双引号的。</p>\n<p>找不到文件，可能是文件名写错了，也可能没有在当前目录下。<br>\n最不好修改的是编译没有问题，但是业务逻辑错误，还有环境错误。</p>\n<p><strong>变量有三个基本要素：类型 + 名称 + 值</strong></p>\n<p>程序中的加号，当左右两边一方为字符串，则做拼接运算，运算顺序从左到右。</p>\n<h2 id=\"java转义字符\"><a class=\"markdownIt-Anchor\" href=\"#java转义字符\">#</a> java 转义字符</h2>\n<p>换行与回车的区别，回车后会直接到当前行的首位，而不是换下一行，而且会用当前字符覆盖掉之前的字符</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\t</td>\n<td>一个制表位，实现对齐功能</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>换行符</td>\n</tr>\n<tr>\n<td>&quot;</td>\n<td>一个 &quot;</td>\n</tr>\n<tr>\n<td>'</td>\n<td>一个’</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>一个回车</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"注释\"><a class=\"markdownIt-Anchor\" href=\"#注释\">#</a> 注释</h2>\n<p>多行注释内不允许内嵌多行注释，因为第一开始与第二个的结束符号匹配，导致第一的结束符号报错</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单行注释</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*多行注释</span></span><br><span class=\"line\"><span class=\"comment\">  多行注释*/</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//文档注释</span></span><br><span class=\"line\">java文件中</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@author</span> 西芹</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">cmd中：表示将结果存放在存放D盘的temp文件下，关键字根据上面的注释写，最后写文件名</span><br><span class=\"line\">E:\\java韩顺平\\练习代码&gt;javadoc -d d:\\\\temp -author -version Comment02.java</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"代码规范\"><a class=\"markdownIt-Anchor\" href=\"#代码规范\">#</a> 代码规范</h2>\n<ul>\n<li>类、方法的注释，要以 javadoc 的方式来写。</li>\n<li>非 Javadoc 的注释，往往是给代码的维护者看的，着重告诉读者为什么这样写，如何修改，注意什么问题。</li>\n<li>源代码使用 utf-8 编码。</li>\n<li>行宽度不要超过 80 字符。</li>\n<li>代码编写有次行风格和行尾风格，推荐行尾风格。</li>\n</ul>\n<h2 id=\"dos命令\"><a class=\"markdownIt-Anchor\" href=\"#dos命令\">#</a> dos 命令</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dir</td>\n<td>查看当前目录有什么</td>\n</tr>\n<tr>\n<td>cd</td>\n<td>切换到其他文件夹，切换到其他盘，需要加上 / D。例如 E:\\java 韩顺平 \\ 练习代码 &gt; cd /D c:</td>\n</tr>\n<tr>\n<td>md</td>\n<td>新建文件夹</td>\n</tr>\n<tr>\n<td>rd</td>\n<td>删除文件夹</td>\n</tr>\n<tr>\n<td>…</td>\n<td>到上级目录</td>\n</tr>\n<tr>\n<td>help</td>\n<td>查看命令的详细信息</td>\n</tr>\n<tr>\n<td>cd</td>\n<td>直接切换到根目录</td>\n</tr>\n<tr>\n<td>tree</td>\n<td>查看指定目录下的所有子级目录</td>\n</tr>\n<tr>\n<td>cls</td>\n<td>清屏</td>\n</tr>\n<tr>\n<td>exit</td>\n<td>退出 DOS</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"第二章-变量\"><a class=\"markdownIt-Anchor\" href=\"#第二章-变量\">#</a> 第二章 变量</h1>\n<p>java 的整型常量（具体值）<strong>默认为 int 型</strong>，声明 long 型常量需后加‘l’或’L‘。例如   <code>long num = 50L</code>  。</p>\n<p>浮点数构成：浮点数 = 符号位 + 指数位 + 尾数位。</p>\n<p>java 的浮点型常量（具体值）<strong>默认为 double 型</strong>，声明为 float 型常量需后加’f’或’F’。例如 <code>float num = 1.1F</code>  。</p>\n<p>浮点型常量有两种表现形式：1、十进制数形式  <code>double num = 5.12</code> ;2、科学计数法形式  <code>double num = 2.12e2</code>  。</p>\n<p>** 当我们对运算结果是小数的进行相等判断时，要小心，因为可能会有精度误差，应该是以两个数的差值的绝对值在某个精度范围类判断。** 如果是直接查询得到的小数或者赋值是可以正常判断的。</p>\n<p>API（应用程序编程接口）是 java 提供的基本编程接口（java 提供的类还有相关的方法）。<a class=\"link\"   href=\"https://www.matools.com/\" >中文在线文档 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p>字符类型可以直接存放一个数字，因为在 java 中 char 的本质是一个整数，例如  <code>char c4 = 97</code>  ，但是会输出数字对应的 Unicode 字符。</p>\n<p>字符常量需要使用单引号括起来，例如  <code>char c1 = 'a'</code>  , 双引号代表字符串。java 中还运行使用转义字符’' 将字符转变为特殊字符串常量，例如  <code>char c3 = '\\n'</code>  。char 类型是可以进行运算的，相当于一个整数，因为它都有对应的 Unicode 码。</p>\n<p><strong>布尔类型不可以使用 0 或非 0 的整数代替 false 和 true，这点和 C 语言不同。</strong></p>\n<p>当 java 程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转换。<strong>有多种类型的数据混合运算时，系统首先将所有数据转换成容量最大的数据类型，然后再进行计算。</strong></p>\n<p>char-&gt;int-&gt;long-&gt;float-&gt;double;byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double。</p>\n<p><strong>（byte,short）和 char 不会自动转换，但是它们三者之间是可以进行运算的，在计算时首先转换为 int 类型，包括自身的运算，例如 byte 和 byte 运算结果也是 int。</strong></p>\n<p>boolean 类型不参与自动转换。</p>\n<p>强制类型转换使用时用加上强制转换符 ()，例如  <code>int i = (int)1.9</code>  。可能造成精度丢失，需要格外注意。强制转换符号只对最近的操作数有效，往往会使用小括号提升优先级，例如  <code>int x = (int)(10 * 3.5 + 6 * 1.9)</code> 。</p>\n<p>基本数据类型转 String，使用加号和双引号即可，例如  <code>String s1 = n1 + &quot;&quot;</code>  。String 转基本数据类型，使用基本数据类型的包装类调用方法 parseXX 方法即可，例如  <code>int num = Integer.parseInt(s5)</code>  ，但是一定要确保能够转换成有效的数据。从 String 中取字符，指定需要获取的第几个元素，  <code>char c1 = s.charAt(0)</code>  。</p>\n<h2 id=\"java数据类型\"><a class=\"markdownIt-Anchor\" href=\"#java数据类型\">#</a> java 数据类型</h2>\n<p>基本数据类型：1、数值型：整数类型：byte [1]、short [2]、int [4]、long [8]；浮点类型：float [4]、double [8]。2、字符型 char [2]。3、布尔型 boolean [1]。</p>\n<p>引用数据类型：类 (class)、接口 (inferface)、数组 ([])。</p>\n<h2 id=\"字符编码表\"><a class=\"markdownIt-Anchor\" href=\"#字符编码表\">#</a> 字符编码表</h2>\n<table>\n<thead>\n<tr>\n<th>编码表</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ASCII</td>\n<td>一个字节表示一个字符，一共有 128 个字符，上限为 256 个字符</td>\n</tr>\n<tr>\n<td>Unicode</td>\n<td>使用两个字节表示字符，汉字和字母统一占用 2 个字节</td>\n</tr>\n<tr>\n<td>UTF-8</td>\n<td>大小可变的 编码表，字母使用 1 个字节，汉字使用 3 个字节，可以使用 1-6 个字符表示一个符号</td>\n</tr>\n<tr>\n<td>gbk</td>\n<td>字母使用 1 个字节，汉字使用 2 个字节</td>\n</tr>\n<tr>\n<td>big5 码</td>\n<td>存储繁体中文</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"第三章-运算符\"><a class=\"markdownIt-Anchor\" href=\"#第三章-运算符\">#</a> 第三章 运算符</h1>\n<p>java 取余的本质，公式  <code>a % b = a - a / b *b</code>  ，当 a 为小数时，公式转变为  <code>a % b = a - (int) a / b * b</code> 。</p>\n<p><code>&amp;和|是逻辑运算符，&amp;&amp;和||是短路运算符</code>  。</p>\n<p><code>x=flase</code>  的返回结果是 flase，同理  <code>x=true</code>  的返回结果是 true。</p>\n<p>有小数参与运算，得到结果是近似值。</p>\n<h2 id=\"算术运算符\"><a class=\"markdownIt-Anchor\" href=\"#算术运算符\">#</a> 算术运算符</h2>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>+</td>\n<td>正号；数字相加；字符串相加</td>\n</tr>\n<tr>\n<td>-</td>\n<td>负号；数字相减；</td>\n</tr>\n<tr>\n<td>*</td>\n<td>数字相乘</td>\n</tr>\n<tr>\n<td>/</td>\n<td>数字相除</td>\n</tr>\n<tr>\n<td>%</td>\n<td>取模（取余）</td>\n</tr>\n<tr>\n<td>++</td>\n<td>先运算后取值；先取值后运算</td>\n</tr>\n<tr>\n<td>–</td>\n<td>先运算后取值；先取值再运算</td>\n</tr>\n</tbody>\n</table>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//算术运算符例题</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">i = i++;</span><br><span class=\"line\">System.out.println(i);</span><br><span class=\"line\"><span class=\"comment\">//输出结果为1，因为规则使用临时变量,(1)temp=i;(2)i=i+1;(3)i=temp。所以结果为1。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">i = ++i;</span><br><span class=\"line\">System.out.println(i);</span><br><span class=\"line\"><span class=\"comment\">//输出结果为2，因为规则使用临时变量,(1)i=i+1;(2)temp=i;(3)i=temp.所以结果为2。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//复合运算符进行逻辑转换</span></span><br><span class=\"line\"><span class=\"type\">byte</span> b=<span class=\"number\">3</span>;</span><br><span class=\"line\">b+=<span class=\"number\">2</span>;<span class=\"comment\">//等价于b=(byte)(b+2)</span></span><br><span class=\"line\">b++;<span class=\"comment\">//等价于b=(byte)(b+1)</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"标识符\"><a class=\"markdownIt-Anchor\" href=\"#标识符\">#</a> 标识符</h2>\n<h3 id=\"标识符命名规则\"><a class=\"markdownIt-Anchor\" href=\"#标识符命名规则\">#</a> 标识符命名规则</h3>\n<ul>\n<li>有 26 个字母，0-9，_和 $ 组成。</li>\n<li>数字不可以开头。</li>\n<li>不可以使用关键字和保留字，但能包含关键字和保留字。</li>\n<li>java 中严格区分大小写，长度无限制。</li>\n</ul>\n<h3 id=\"标识符命名规范\"><a class=\"markdownIt-Anchor\" href=\"#标识符命名规范\">#</a> 标识符命名规范</h3>\n<ul>\n<li>包名：多单词组成时所有字母都小写：aaa.bbb.ccc，例如： <code>com.hsp.crm</code>   。</li>\n<li>类名、接口名：多单词组成时，所有单词的首字母大写（大驼峰）：XxxYyyZzz，例如：  <code>TankShotGame</code>  。</li>\n<li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始首字母大写（小驼峰）：xxxYyyZzz，例如： <code>tankShotGame</code>  。</li>\n<li>常量名：所有字母都大写，多单词时每个单词用下划线连接：XXX_YYY_ZZZ，例如： <code>TAX_RATE</code>  。</li>\n</ul>\n<h2 id=\"接收键盘输入\"><a class=\"markdownIt-Anchor\" href=\"#接收键盘输入\">#</a> 接收键盘输入</h2>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//导入对应的包</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"comment\">//创建Scanner对象</span></span><br><span class=\"line\"><span class=\"type\">Scanner</span> <span class=\"variable\">myscanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\"><span class=\"comment\">//调用方法，接收用户输入</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> myscanner.next()</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"进制\"><a class=\"markdownIt-Anchor\" href=\"#进制\">#</a> 进制</h2>\n<table>\n<thead>\n<tr>\n<th>进制</th>\n<th>表示方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>二进制</td>\n<td>以 0b 或 0B 开头</td>\n</tr>\n<tr>\n<td>十进制</td>\n<td>正常形式</td>\n</tr>\n<tr>\n<td>八进制</td>\n<td>以数字 0 开头</td>\n</tr>\n<tr>\n<td>十六进制</td>\n<td>以 0x 或 0X 开头，0-9 及 A (10)-F (15)，此处的 A-F 不区分大小写</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"位运算\"><a class=\"markdownIt-Anchor\" href=\"#位运算\">#</a> 位运算</h2>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>~</td>\n<td>取反</td>\n</tr>\n<tr>\n<td>&amp;</td>\n<td>按位与</td>\n</tr>\n<tr>\n<td>|</td>\n<td>按位或</td>\n</tr>\n<tr>\n<td>^</td>\n<td>按位异或</td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>算术右移，低位溢出，符号位不变，用符号位补溢出的高位</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>算术左移，符号位不变，低位补 0</td>\n</tr>\n<tr>\n<td>&gt;&gt;&gt;</td>\n<td>逻辑右移，也称为无符号右移。运算规则是低位溢出，高位补 0</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"原码-反码-补码\"><a class=\"markdownIt-Anchor\" href=\"#原码-反码-补码\">#</a> 原码、反码、补码</h2>\n<ul>\n<li>二进制的最高位是符号位：0 代表正数，1 代表负数。</li>\n<li>正数的原码、反码、补码都一样。</li>\n<li>负数的反码 = 原码符号位不变，其他位取反。</li>\n<li>负数的补码 = 反码 + 1，负数的反码 = 补码 + 1。</li>\n<li>0 的反码，补码都是 0。</li>\n<li>java 没有无符号数，java 中的数都是有符号的。</li>\n<li><strong>在计算机运行的时候，都是以补码的方式来运算的</strong>。</li>\n<li><strong>当我们看运算结果的时候，要看他的原码。</strong></li>\n</ul>\n<h2 id=\"位运算解析\"><a class=\"markdownIt-Anchor\" href=\"#位运算解析\">#</a> 位运算解析</h2>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1、先得到-2的原码，由于默认为int型，4个字节，32位，原码为10000000 00000000 00000000 00000010</span></span><br><span class=\"line\"><span class=\"comment\">//2、-2的反码：11111111 11111111 11111111 11111101</span></span><br><span class=\"line\"><span class=\"comment\">//3、-2的补码：11111111 11111111 11111111 11111110</span></span><br><span class=\"line\"><span class=\"comment\">//4、取反操作：00000000 00000000 00000000 00000001,运算后的补码</span></span><br><span class=\"line\"><span class=\"comment\">//5、运算后的原码就是00000000 00000000 00000000 00000001=&gt;1</span></span><br><span class=\"line\">System.out.println(~-<span class=\"number\">2</span>);<span class=\"comment\">//结果为1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1、得到2的补码：00000000 00000000 00000000 00000010</span></span><br><span class=\"line\"><span class=\"comment\">//~2操作:11111111 11111111 11111111 11111101，这是运算后的补码</span></span><br><span class=\"line\"><span class=\"comment\">//3、运算后的反码:11111111 11111111 11111111 11111100</span></span><br><span class=\"line\"><span class=\"comment\">//4、运算后的原码:10000000 00000000 00000000 00000011=&gt;-3</span></span><br><span class=\"line\">System.out.println(~<span class=\"number\">2</span>);<span class=\"comment\">//结果为-3</span></span><br></pre></td></tr></table></figure></div>\n<h1 id=\"第四章-控制结构\"><a class=\"markdownIt-Anchor\" href=\"#第四章-控制结构\">#</a> 第四章 控制结构</h1>\n<p>三大流程控制语句：顺序控制、分支控制、循环控制。</p>\n<p>在 java 中，只要有值返回，就是一个表达式。</p>\n<p><strong>break 语句出现在多层嵌套的语句块中，可以通过标签指明要终止的是哪一层语句块。</strong></p>\n<p><strong>字符串比较是否相同： <code>&quot;林黛玉&quot;.equals(name)</code>  。尽量把具体对象写在前面以避免空指针。</strong></p>\n<p>continue 语句用于结束本次循环，继续执行下一次循环。在多层嵌套的循环语句体中，可以通过标签指定要跳过哪一层循环，这个和前面的 break 语句类似。</p>\n<p>当 return 用在方法时，表示跳出方法，如果用在 main，表示退出程序。</p>\n<h2 id=\"switch注意事项\"><a class=\"markdownIt-Anchor\" href=\"#switch注意事项\">#</a> Switch 注意事项</h2>\n<ul>\n<li>表达式数据类型，应和 case 后的常量类型一致，或者是可以自动转成可以相互比较的类型。</li>\n<li>Switch 表达式中的返回值必须是：byte,short,int,char,enum,String。</li>\n<li>case 子句中的值必须是常量或常量表达式，而不能是变量。</li>\n<li>default 子句是可选的，当没有匹配的 case 时，执行 default。</li>\n<li>Switch 穿透：case 中没有 break 语句，运行结束后直接执行下一个 case 的语句，不会进行判断。</li>\n</ul>\n<h2 id=\"for使用细节\"><a class=\"markdownIt-Anchor\" href=\"#for使用细节\">#</a> for 使用细节</h2>\n<ul>\n<li>for (; 循环判断条件；) 中的初始化和变量迭代可以写到其他地方，但是两边的分号不能省略。</li>\n<li>循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开。</li>\n</ul>\n<h2 id=\"编程思想\"><a class=\"markdownIt-Anchor\" href=\"#编程思想\">#</a> 编程思想</h2>\n<ul>\n<li>化繁为简：将复杂的需求，拆解成简单的需求，逐步完成。</li>\n<li>先死后活：先考虑固定的值，然后转成灵活变化的值。</li>\n</ul>\n<h2 id=\"标签\"><a class=\"markdownIt-Anchor\" href=\"#标签\">#</a> 标签</h2>\n<ol>\n<li>label1 是标签，名字由程序员指定。</li>\n<li>break 后指定到哪个标签就退出到哪里。</li>\n<li>在实际的开发中，尽量不使用标签。因为会导致可读性变差。</li>\n</ol>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//标签的例子</span></span><br><span class=\"line\">label1:</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;j &lt; <span class=\"number\">4</span>;j++)&#123;<span class=\"comment\">//外层for循环</span></span><br><span class=\"line\">label2:  </span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;i &lt; <span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span> label1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;i = &quot;</span>+i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h1 id=\"第五章-数组\"><a class=\"markdownIt-Anchor\" href=\"#第五章-数组\">#</a> 第五章 数组</h1>\n<p>数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。</p>\n<p>二维数组指向多个一维数组，一维数组再指向具体的值。</p>\n<p><strong>二维数组允许每列的元素个数不相同。</strong></p>\n<h2 id=\"数组操作\"><a class=\"markdownIt-Anchor\" href=\"#数组操作\">#</a> 数组操作</h2>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//新建数组</span></span><br><span class=\"line\"><span class=\"type\">int</span> a[] = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"type\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"type\">int</span>[] hens = &#123;<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">8.8</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//先声明，再分配</span></span><br><span class=\"line\"><span class=\"type\">int</span> a[];<span class=\"comment\">//也可以使用int[] a;</span></span><br><span class=\"line\">a = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">10</span>];<span class=\"comment\">//此时才真正赋予存储空间</span></span><br><span class=\"line\"><span class=\"comment\">//获取数组长度</span></span><br><span class=\"line\">len = hens.length</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//二维数组的新建与一维的类似</span></span><br><span class=\"line\"><span class=\"type\">int</span>[][] arr = &#123;&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> a[][] = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">2</span>][<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"type\">int</span>[] y[];</span><br><span class=\"line\"><span class=\"comment\">//动态初始化,列数不等</span></span><br><span class=\"line\"><span class=\"comment\">//创建二维数组，有3个一维数组，但是每个一维数组没有开空间</span></span><br><span class=\"line\"><span class=\"type\">int</span>[][] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">3</span>][];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class=\"line\">  arr[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[i+<span class=\"number\">1</span>];<span class=\"comment\">//给每个一维数组开空间</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取行数和列数</span></span><br><span class=\"line\">row = arr.length;</span><br><span class=\"line\">col = arr[<span class=\"number\">0</span>].length;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//练习题</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">strs</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;a&quot;</span>,<span class=\"string\">&quot;b&quot;</span>,<span class=\"string\">&quot;c&quot;</span>&#125;<span class=\"comment\">//正确</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">strs</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">3</span>]&#123;<span class=\"string\">&quot;a&quot;</span>,<span class=\"string\">&quot;b&quot;</span>,<span class=\"string\">&quot;c&quot;</span>&#125;<span class=\"comment\">//错误，不可以指定数字</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"数组细节\"><a class=\"markdownIt-Anchor\" href=\"#数组细节\">#</a> 数组细节</h2>\n<ol>\n<li>数组创建后，如果没有赋值，有默认值。int、short、byte、long 的默认值为 0；float 和 double 的默认值为 0.0；char 的默认值为 \\u0000；Boolean 为 false；String 为 null。</li>\n<li>数组中的元素可以是任何数据类型。包括基本数据类型和引用类型，但是不能混用。</li>\n<li>数组下标从 0 开始。</li>\n<li>数组属引用类型，数组型数据是对象。</li>\n</ol>\n<h2 id=\"赋值方式\"><a class=\"markdownIt-Anchor\" href=\"#赋值方式\">#</a> 赋值方式</h2>\n<ol>\n<li>基本数据类型赋值，赋值方式为值拷贝。</li>\n<li>数组在默认情况下是引用传递，赋的值是地址，赋值方式为引用传递。</li>\n<li><strong>数组在栈中存储一个指向堆的地址，堆中存储实际的值，数组赋值时，实际上是将栈中的地址进行传递，这也是为什么将数组成为引用类型。</strong></li>\n</ol>\n<h2 id=\"二维数组内存示意图\"><a class=\"markdownIt-Anchor\" href=\"#二维数组内存示意图\">#</a> 二维数组内存示意图</h2>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/11606/97b2904d6220cca5a9e0944106126e87.jpg\"\n                      alt=\"二维数组内存示意图\" style=\"zoom:50%;\" \n                >\n<h1 id=\"第六章-面向对象基础\"><a class=\"markdownIt-Anchor\" href=\"#第六章-面向对象基础\">#</a> 第六章 面向对象 (基础)</h1>\n<p>属性如果不赋值，有默认值，与数组相同。</p>\n<p>由于对象也是引用类型，所以赋值也是引用传递。</p>\n<p><strong>方法不能嵌套定义。</strong></p>\n<p>方法重载：java 中允许同一个类中，多个重名方法的存在，但要求形参列表不一致。</p>\n<p>可变参数：java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。</p>\n<p><strong>全局变量（属性）可以不赋值，直接使用，因为有默认值，局部变量必须赋值后才能使用，因为没有默认值。我们说的局部变量一般是指在成员方法中定义的变量。</strong></p>\n<p>属性可以加修饰符，局部变量不可以加修饰符。</p>\n<p>可以使用 hashCode () 函数内存地址转换成的整数。例如  <code>this.hashCode()</code>  。</p>\n<p>使用 Double 包装类返回值，就可以返回 null 来提示错误信息。</p>\n<h2 id=\"类的操作\"><a class=\"markdownIt-Anchor\" href=\"#类的操作\">#</a> 类的操作</h2>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span>&#123;</span><br><span class=\"line\">  String name;</span><br><span class=\"line\">  <span class=\"type\">int</span> age;</span><br><span class=\"line\">  String color;</span><br><span class=\"line\">  <span class=\"comment\">//新建方法</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cal</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    System.out.printlin(<span class=\"string\">&quot;接收的信息：&quot;</span> + n);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实例化，创建对象</span></span><br><span class=\"line\"><span class=\"comment\">//cat1是对象名(对象引用),new Cat()创建的对象空间(数据)才是真正的对象。</span></span><br><span class=\"line\"><span class=\"type\">Cat</span> <span class=\"variable\">cat1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();</span><br><span class=\"line\">cat1.name = <span class=\"string\">&quot;小白&quot;</span>;</span><br><span class=\"line\">cat1.cal(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">//将cat1指针置空</span></span><br><span class=\"line\">cat1 = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"类与对象的区别\"><a class=\"markdownIt-Anchor\" href=\"#类与对象的区别\">#</a> 类与对象的区别</h2>\n<ol>\n<li>类是抽象的，概念的，代表一类事物，即它是数据类型。</li>\n<li>对象是具体的，实际的，代表一个具体事物，即是实例。</li>\n<li>类是对象的模板，对象是类的一个实体，对应一个实例。</li>\n</ol>\n<h2 id=\"对象内存示意图\"><a class=\"markdownIt-Anchor\" href=\"#对象内存示意图\">#</a> 对象内存示意图</h2>\n<p>基本数据类型存储于堆中，引用类型存储于方法区中的常量池。</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/11606/5f4a10b99b9515c31caf316ec5e16bae.jpg\"\n                      alt=\"对象内存示意图\" style=\"zoom:50%;\" \n                >\n<h2 id=\"java内存的结构分析\"><a class=\"markdownIt-Anchor\" href=\"#java内存的结构分析\">#</a> java 内存的结构分析</h2>\n<ol>\n<li>栈：一般存放基本数据类型（局部变量）。</li>\n<li>堆：存放对象（Cat cat，数组等）。</li>\n<li>方法区：常量池（常量，比如字符串），类加载信息。</li>\n</ol>\n<h2 id=\"java创建对象流程\"><a class=\"markdownIt-Anchor\" href=\"#java创建对象流程\">#</a> java 创建对象流程</h2>\n<ol>\n<li>先加载类信息（属性和方法信息，每个类只加载一次）。</li>\n<li>在堆中分配空间，进行默认初始化。</li>\n<li>把堆中地址赋给栈中的对象名，使得对象名指向对象。</li>\n<li>进行指定初始化。</li>\n</ol>\n<h2 id=\"方法调用\"><a class=\"markdownIt-Anchor\" href=\"#方法调用\">#</a> 方法调用</h2>\n<ol>\n<li>当程序执行到方法时，就会开辟一个独立的空间（栈空间）。</li>\n<li>当方法执行完毕，或者执行到 return 语句时，就会返回到调用方法的地方。</li>\n<li>返回后，继续执行方法后面的代码。</li>\n<li>当 main 方法 (栈) 执行完毕，整个程序退出。</li>\n</ol>\n<h2 id=\"返回数据\"><a class=\"markdownIt-Anchor\" href=\"#返回数据\">#</a> 返回数据</h2>\n<ol>\n<li>一个方法最多一个返回值，使用数组可以传递多个结果。<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>[] returnarr()&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span>[] resArr = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> resArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n</li>\n<li>返回类型可以为任意类型，包含基本数据类型或引用类型。</li>\n<li>如果方法要求有返回类型，则方法体中最后的执行语句必须为 return 值，而且要求返回值类型必须和 return 的值类型一致或兼容。</li>\n<li>如果方法返回类型为 void，则方法体中可以没有 return 或只写 return。</li>\n</ol>\n<h2 id=\"成员方法传参机制\"><a class=\"markdownIt-Anchor\" href=\"#成员方法传参机制\">#</a> 成员方法传参机制</h2>\n<ol>\n<li>基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参。</li>\n<li>引用类型传递的是地址（地址也是值），可以通过形参影响实参。对象也是引用类型。</li>\n</ol>\n<h2 id=\"递归使用规则\"><a class=\"markdownIt-Anchor\" href=\"#递归使用规则\">#</a> 递归使用规则</h2>\n<ol>\n<li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）。</li>\n<li>方法的局部变量是独立的，不会相互影响。</li>\n<li>如果方法中使用的是引用类型变量（比如数组，对象），就会共享该引用类型的数据。</li>\n<li>当方法执行完毕，或者遇到 return，就返回，遵守谁调用，就把结果返回给谁，同时方法执行完毕或者返回时，该方法执行完毕。</li>\n</ol>\n<h2 id=\"方法重载\"><a class=\"markdownIt-Anchor\" href=\"#方法重载\">#</a> 方法重载</h2>\n<ol>\n<li>方法名：必须相同</li>\n<li>形参列表：必须不同，形参类型或个数或顺序，至少有一个不同，参数名无要求</li>\n<li>返回类型：无要求</li>\n</ol>\n<h2 id=\"可变参数\"><a class=\"markdownIt-Anchor\" href=\"#可变参数\">#</a> 可变参数</h2>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可变函数声明</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HspMethod</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//计算多个数的和</span></span><br><span class=\"line\">  <span class=\"comment\">//int...表示接受的是可变参数，类型是int，使用可变参数时，可以当作数组来使用</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">sum</span><span class=\"params\">(<span class=\"type\">int</span>... nums)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class=\"line\">      res += nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"可变参数细节\"><a class=\"markdownIt-Anchor\" href=\"#可变参数细节\">#</a> 可变参数细节</h3>\n<ol>\n<li>可变参数的实参可为 0 到任意多个。</li>\n<li>可变参数的实参可以是数组。</li>\n<li><strong>可变参数的本质就是数组。</strong></li>\n<li>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数放在最后。</li>\n<li>一个形参列表只能出现一个可变参数。</li>\n</ol>\n<h2 id=\"构造器构造方法\"><a class=\"markdownIt-Anchor\" href=\"#构造器构造方法\">#</a> 构造器 / 构造方法</h2>\n<ol>\n<li>主要作用是完成对新对象的初始化，并不是创建对象</li>\n<li><strong>构造器没有返回值，也不能写 void</strong></li>\n<li>方法名和类名要一致</li>\n<li>参数列表和成员方法一样的规则</li>\n<li>构造器的调用由系统完成，不能自行调用</li>\n<li>构造器也允许重载</li>\n<li>如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器，可以使用 javap 指令反编译查看。例如  <code>javap Dog.class</code>  。</li>\n</ol>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造器/构造方法声明</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">  String name;</span><br><span class=\"line\">  <span class=\"type\">int</span> age;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Person</span><span class=\"params\">(String name,<span class=\"type\">int</span> age)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//使用this指定当前对象，即当前调用构造器的对象</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"this使用细节\"><a class=\"markdownIt-Anchor\" href=\"#this使用细节\">#</a> this 使用细节</h2>\n<ol>\n<li>this 关键字可以用来访问本类的属性、方法、构造器</li>\n<li>this 用于区分当前类的属性和局部变量<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;smith&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">//传统方式，输出局部变量smith</span></span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;name=&quot;</span> + name);</span><br><span class=\"line\">  <span class=\"comment\">//this方式，输出类属性jack</span></span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;name=&quot;</span> + <span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n</li>\n<li>访问成员方法的语法：this. 方法名 (参数列表)</li>\n<li>访问构造器语法：this (参数列表)；<strong>注意只能在构造器中调用本类的另一个构造器，而且必须放置于第一条语句，因此只能用一个</strong></li>\n<li>this 不能在类定义的外部使用，只能在类定义的方法中使用。</li>\n</ol>\n<h2 id=\"题目解析\"><a class=\"markdownIt-Anchor\" href=\"#题目解析\">#</a> 题目解析</h2>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">9</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">count1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    count = <span class=\"number\">10</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;count1=&quot;</span> + count);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">count2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;count2=&quot;</span> + count);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//Test类的main方法，任何一个类，都可以有自己的main方法</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String args[])</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//new Test()是匿名对象，只使用一次，因为没有对象名，使用后被销毁</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Test</span>().count1();<span class=\"comment\">//输出10</span></span><br><span class=\"line\">    <span class=\"type\">Test</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test</span>();</span><br><span class=\"line\">    t1.count2();<span class=\"comment\">//输出9</span></span><br><span class=\"line\">    t1.count2();<span class=\"comment\">//输出10</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h1 id=\"第七章-面向对象中级\"><a class=\"markdownIt-Anchor\" href=\"#第七章-面向对象中级\">#</a> 第七章 面向对象 (中级)</h1>\n<p>idea 编译后的文件会存放在 out 文件夹下，src 文件夹存放源码文件。</p>\n<p>文件 -&gt; 设置 -&gt; 编辑器 -&gt; 代码模板：可以查看模板或者编辑模板。遇到一个问题是我没有 java 的模板。可以使用代码模板加快速度，例如使用  <code>sout</code>  加缩进自动补全为打印。</p>\n<p>package 关键字，声明当前类所在的包，需要放在类的最上面。</p>\n<p><strong>包的本质实际上就是创建不同的文件夹来保存类文件。</strong></p>\n<p>当类重名的时候，默认使用引入的类，或者通过指定包名来指出使用的类。</p>\n<p><strong>包的命名只能包含数字、字母、下划线、小圆点，但不能用数字开头，不能是关键字或保留字。</strong></p>\n<p>继承声明： <code>class 子类 extends 父类</code>  。</p>\n<p>方法重写 (覆盖)：子类的方法和父类的方法的名称、返回类型和参数都一样，那么子类的该方法覆盖父类的对应方法。</p>\n<p>多态是指方法和对象具有多种形态，可以提高代码的复用性，利于代码维护。</p>\n<p>instanceof 比较操作符，用于判断对象的运行类型是否为某类型或某类型的子类型。例子： <code>cat instanceof Animal</code>  。</p>\n<p><strong>多态的方法首先看运行类型，属性首先看编译类型。</strong></p>\n<p>多态数组：数组的定义类型为父类类型，里面保存的实际元素为子类类型。</p>\n<p>toString 方法默认返回类的全类名 (包名 + 类名)+@+ 十六进制哈希值 (由 hashCode 获取)。当直接输出一个对象时，toString 方法会被默认调用。</p>\n<p>当某个对象没有任何引用时，则 JVM 就认为这个对象是一个垃圾对象，会使用垃圾回收机制销毁该对象，在销毁该对象前，会先调用 finalize 方法。垃圾回收并不是即时的，有自己的一套算法，使用 System.gc () 主动调用。</p>\n<p><strong>在断点调试过程中是运行状态，是以对象的运行类型来执行的。</strong></p>\n<p>设置步进至源码：文件 -&gt; 构建，执行，部署 -&gt; 调试器 -&gt; 步进 -&gt; 取消勾选  <code>java.*</code>  和  <code>javax*</code>  。</p>\n<p>建议一段代码完成一个小功能，尽量不要混在一起。</p>\n<p>数据校验时，可以采用找出不正确的金额条件，然后给出提示，就直接 break。</p>\n<h2 id=\"idea快捷键\"><a class=\"markdownIt-Anchor\" href=\"#idea快捷键\">#</a> idea 快捷键</h2>\n<table>\n<thead>\n<tr>\n<th>快捷键</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ctrl+d</td>\n<td>删除当前行</td>\n</tr>\n<tr>\n<td>ctrl+alt + 向下箭头</td>\n<td>复制当前行到下一行</td>\n</tr>\n<tr>\n<td>alt+/</td>\n<td>代码补全</td>\n</tr>\n<tr>\n<td>ctrl+/</td>\n<td>第一次添加注释，第二次取消注释</td>\n</tr>\n<tr>\n<td>alt+enter</td>\n<td>自动导入光标对应的 class</td>\n</tr>\n<tr>\n<td>ctrl+alt+L</td>\n<td>自动格式化代码</td>\n</tr>\n<tr>\n<td>alt+r</td>\n<td>运行代码</td>\n</tr>\n<tr>\n<td>alt+insert</td>\n<td>新建构造器，get 和 set 方法等</td>\n</tr>\n<tr>\n<td>ctrl+h</td>\n<td>查看类的继承关系</td>\n</tr>\n<tr>\n<td>ctrl+b</td>\n<td>快速定位到光标所在的方法</td>\n</tr>\n<tr>\n<td>声明类时在后面加上 var, 点击 enter</td>\n<td>自动分配变量名</td>\n</tr>\n<tr>\n<td>F7</td>\n<td>断点调试跳入方法内</td>\n</tr>\n<tr>\n<td>F8</td>\n<td>逐行执行代码</td>\n</tr>\n<tr>\n<td>F9</td>\n<td>继续，执行到下一个断点</td>\n</tr>\n<tr>\n<td>shift+F8</td>\n<td>跳出方法</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"包的作用\"><a class=\"markdownIt-Anchor\" href=\"#包的作用\">#</a> 包的作用</h2>\n<ol>\n<li>区分相同名字的类</li>\n<li>当类很多时，可以很好的管理类</li>\n<li>控制访问范围</li>\n</ol>\n<h2 id=\"访问修饰符\"><a class=\"markdownIt-Anchor\" href=\"#访问修饰符\">#</a> 访问修饰符</h2>\n<p>java 提供四种访问修饰符，用于控制方法和属性的访问权限，也可以修饰类，但只能使用 public 和默认修饰符。</p>\n<table>\n<thead>\n<tr>\n<th>访问修饰符</th>\n<th>访问级别</th>\n<th>同类</th>\n<th>同包</th>\n<th>子类</th>\n<th>不同包</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>公开</td>\n<td>可以</td>\n<td>可以</td>\n<td>可以</td>\n<td>可以</td>\n</tr>\n<tr>\n<td>protested</td>\n<td>受保护</td>\n<td>可以</td>\n<td>可以</td>\n<td colspan=\"2\">可以</td>\n</tr>\n<tr>\n<td>没有修饰符</td>\n<td>默认</td>\n<td>可以</td>\n<td colspan=\"3\">可以</td>\n</tr>\n<tr>\n<td>private</td>\n<td>私有</td>\n<td colspan=\"4\">可以</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"封装的实现步骤\"><a class=\"markdownIt-Anchor\" href=\"#封装的实现步骤\">#</a> 封装的实现步骤</h2>\n<ol>\n<li>将属性进行私有化 private，使用户不能直接修改属性。</li>\n<li>提供一个公共的 set 方法，用于对属性进行判断并赋值。</li>\n<li>提供一个公共的 get 方法，用于获取属性的值。</li>\n</ol>\n<h2 id=\"继承细节\"><a class=\"markdownIt-Anchor\" href=\"#继承细节\">#</a> 继承细节</h2>\n<ol>\n<li>子类继承父类的所有属性和方法，非私有的属性可以直接访问，私有的需要通过父类的公共方法使用。</li>\n<li>java 所有类都是 Object 类的子类，Object 类是所有类的父类。</li>\n<li>子类必须调用父类的构造器，完成父类的初始化。父类构造器的调用不限于直接父类，将一直往上追溯到 Object 类。</li>\n<li>如果希望指定去调用父类的某个构造器，则显式 3 的调用一下：super (参数列表)。super 只能在构造器中使用，且必须放在构造器第一行。</li>\n<li>super () 和 this () 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器中，使用了 this () 方法，就不会默认调用 super () 方法。</li>\n<li>子类最多只能继承一个父类 (指直接继承)，那么如何继承多个？让父类去继承。</li>\n<li>子类往上寻找属性时，遇到一个私有属性不能访问，不会跳过再往上查找，而是直接报错。</li>\n</ol>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//继承题目解析</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">  A()&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  A(String name)&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;a name&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">  B()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//由于有this()方法，所以没有默认调用super()方法</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>(<span class=\"string\">&quot;abc&quot;</span>);<span class=\"comment\">//调用自身的构造方法</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  B(String name) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//默认调用了super();</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;b name&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//B b = new B()的输出结果为a,b name,b</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"方法重写细节\"><a class=\"markdownIt-Anchor\" href=\"#方法重写细节\">#</a> 方法重写细节</h2>\n<ol>\n<li>子类的方法的参数、方法名称要和父类方法的参数，方法名称完全相同。</li>\n<li>子类方法的返回类型和父类方法的返回类型一样，或者是父类返回类型的子类，比如父类方法的返回类型是 object，子类方法的返回类型是 String。</li>\n<li>子类方法不能缩小父类的方法权限。</li>\n</ol>\n<h2 id=\"对象的多态\"><a class=\"markdownIt-Anchor\" href=\"#对象的多态\">#</a> 对象的多态</h2>\n<ol>\n<li>一个对象的编译类型和运行类型可以不一致。</li>\n<li>编译类型在定义对象时，就确定了，不能改变。</li>\n<li>运行类型是可以变化的。</li>\n<li>编译类型看定义时等号的左边，运行类型看等号的右边。</li>\n</ol>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//animal编译类型是Animal，运行类型是Dog，相当于披着Animal皮的Dog</span></span><br><span class=\"line\"><span class=\"type\">Animal</span> <span class=\"variable\">animal</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\"><span class=\"comment\">//因为animal运行类型是Dog，使用执行Dog的cry方法，而不是Animal的cry方法</span></span><br><span class=\"line\">animal.cry();</span><br><span class=\"line\"><span class=\"comment\">//animal的运行类型变成了Cat，编译类型仍然是Animal</span></span><br><span class=\"line\">animal = <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"多态的向上转型\"><a class=\"markdownIt-Anchor\" href=\"#多态的向上转型\">#</a> 多态的向上转型</h3>\n<ol>\n<li>多态的前提是两个对象 (类) 存在继承关系</li>\n<li>多态的向上转型的本质是父类的引用指向子类的对象</li>\n<li>多态的向上转型的特点是可以调用父类中的所有成员 (需遵守访问权限)，不能调用子类的特有成员，因为在编译阶段，能调用哪些成员是由编译类型决定的，最终运行效果看子类的具体实现。</li>\n<li><strong>编译阶段只看编译类型，运行时只看具体的运行类型。</strong></li>\n</ol>\n<h3 id=\"多态的向下转型\"><a class=\"markdownIt-Anchor\" href=\"#多态的向下转型\">#</a> 多态的向下转型</h3>\n<ol>\n<li>语法：子类类型 引用名 = （子类类型）父类引用</li>\n<li>只能强转父类的引用，不能强转父类的对象</li>\n<li>要求父类的引用必须指向当前目标类型的对象</li>\n<li>当向下转型后，可以调用子类类型中的所有成员</li>\n</ol>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//进行向下转型，此时cat的编译类型为Cat，运行类型也是Cat</span></span><br><span class=\"line\"><span class=\"comment\">//向下转型要求animal原来的引用指向的是Cat(第3个特点)</span></span><br><span class=\"line\"><span class=\"type\">Cat</span> <span class=\"variable\">cat</span> <span class=\"operator\">=</span> (Cat) animal;</span><br><span class=\"line\">cat.catchMouse();<span class=\"comment\">//此时可以调用Cat的特有方法</span></span><br></pre></td></tr></table></figure></div>\n<h3 id=\"多态的属性\"><a class=\"markdownIt-Anchor\" href=\"#多态的属性\">#</a> 多态的属性</h3>\n<p>属性没有重写，属性的值看编译类型</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span>&#123;<span class=\"comment\">//父类</span></span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Base</span>&#123;<span class=\"comment\">//子类</span></span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">20</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">Base</span> <span class=\"variable\">base</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Sub</span>();</span><br><span class=\"line\">System.out.println(base.count);</span><br><span class=\"line\"><span class=\"comment\">//base的编译类型的Base,输出值为编译类型的10</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"动态绑定\"><a class=\"markdownIt-Anchor\" href=\"#动态绑定\">#</a> 动态绑定</h2>\n<ol>\n<li>当调用对象方法时，该方法会和该对象的内存地址 / 运行类型绑定。</li>\n<li>当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用。</li>\n</ol>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">public</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"comment\">//由于B类没有sum()，于是往上找，父类A有，执行A的sum()</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">sum</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getI() + <span class=\"number\">10</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getI</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">20</span>;</span><br><span class=\"line\">  <span class=\"comment\">//getI()在B类有，执行B的getI()，将B类中的i返回</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getI</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">A</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">B</span>();</span><br><span class=\"line\">System.out.println(a.sum());</span><br><span class=\"line\"><span class=\"comment\">//输出结果为30，</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"和equals的对比\"><a class=\"markdownIt-Anchor\" href=\"#和equals的对比\">#</a> == 和 equals 的对比</h2>\n<ol>\n<li>== 是一个比较运算符，它既可以判断基本数据类型，也可以判断引用类型。判断基本数据类型是判断值是否相等；判断引用类型则是判断地址是否相等，即判断是否为同一个对象。</li>\n<li>equals 方法是 Object 类中的方法，只能判断引用类型。默认判断地址是否相同，子类中往往重写该方法，用于判断内容是否相等。</li>\n</ol>\n<h2 id=\"hashcode方法\"><a class=\"markdownIt-Anchor\" href=\"#hashcode方法\">#</a> hashCode 方法</h2>\n<ol>\n<li>提高具有哈希结构的容器的效率</li>\n<li>两个引用，如果指向的是同一个对象，则哈希值一定一样；如果指向不同对象，则哈希值通常不一样</li>\n<li>哈希值主要是根据地址号，但不能完全将哈希值等价于地址</li>\n</ol>\n<h1 id=\"第八章-面向对象高级\"><a class=\"markdownIt-Anchor\" href=\"#第八章-面向对象高级\">#</a> 第八章 面向对象 (高级)</h1>\n<p>类的单例 (单个实例) 模式：采用一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。</p>\n<p>当父类的某些方法需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类。</p>\n<p>接口就是给出一些没有实现的方法，封装在一起，到某个类要使用的时候，再根据具体情况将这些方法写出来，一种高层次的抽象。</p>\n<h2 id=\"类静态变量\"><a class=\"markdownIt-Anchor\" href=\"#类静态变量\">#</a> 类 (静态) 变量</h2>\n<ol>\n<li>类变量 (静态变量) 会被该类的所有对象实例共享，而且在类加载的时候就生成了。例子： <code>public static int count;</code>  。</li>\n<li>类变量是随着类的加载而创建的，所以即使没有创建对象实例也可以访问。</li>\n<li>类变量存放位置会由于 JDK 版本不同而产生差异。</li>\n<li>类变量可以通过类名。类变量名或者对象名。类变量名来访问，但是 java 设计者推荐使用类名。类变量名方式访问。</li>\n<li>类变量的生命周期是随着类的加载开始，随着类的消亡而销毁。</li>\n</ol>\n<h2 id=\"类静态方法\"><a class=\"markdownIt-Anchor\" href=\"#类静态方法\">#</a> 类 (静态) 方法</h2>\n<ol>\n<li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区。</li>\n<li>类方法不允许使用和对象有关的关键字，比如 this 和 super。</li>\n<li>当方法中不涉及任何和对象相关的成员时，则可以将该方法设计成静态方法，提高开发效率。</li>\n<li>当方法使用了 static 修饰符后，该方法就是静态方法，静态方法只能访问静态属性 / 变量和静态方法。普通方法既可以访问非静态成员，也可以访问静态成员。</li>\n<li>类变量可以通过类名。类方法名或者对象名。类方法名来访问，但是 java 设计者推荐使用类名。类方法名方式访问。</li>\n</ol>\n<h2 id=\"main方法\"><a class=\"markdownIt-Anchor\" href=\"#main方法\">#</a> main 方法</h2>\n<ol>\n<li>main 方法是由 Java 虚拟机调用的，处于不同的类，所以该方法的访问权限必须是 public。</li>\n<li>java 虚拟机在执行 main 方法时不需要创建对象，所以该方法的必须是 static。所以 main 方法本质上也是静态方法，遵守静态方法的规则。</li>\n<li>main 方法接收 String 类型的数组参数，该数组中保存执行 java 命令时传递给所运行的类的参数。String 数组是由命令行运行时传入的。idea 中可以点击编辑配置 -&gt; 程序参数中填写。</li>\n</ol>\n<h2 id=\"代码块\"><a class=\"markdownIt-Anchor\" href=\"#代码块\">#</a> 代码块</h2>\n<ol>\n<li>代码块又称为初始化块，属于类中的成员，类似于方法，将逻辑语句封装在方法体中。但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是在加载类时或创建对象时隐式调用。</li>\n<li>修饰符可不写或写 static，使用 static 的为静态代码块，作用就是对类进行初始化，而且随着类的加载而执行，并且只会执行一次；否则为普通代码块，每创建一个对象就执行一次，如果只是使用类的静态成员，普通代码块并不会执行。静态代码块只能调用静态成员。</li>\n<li>相当于另外一种形式的构造器 (对构造器的补充机制)，可以做初始化的操作。如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性。</li>\n<li>代码块的执行顺序优先于构造器。构造器的最前面其实隐含了 super 方法和调用普通代码块。</li>\n</ol>\n<h2 id=\"类的加载\"><a class=\"markdownIt-Anchor\" href=\"#类的加载\">#</a> 类的加载</h2>\n<ol>\n<li>创建对象实例时 (new)</li>\n<li>创建子类对象实例，父类也会被加载</li>\n<li>使用类的静态成员时</li>\n</ol>\n<h2 id=\"创建对象的顺序\"><a class=\"markdownIt-Anchor\" href=\"#创建对象的顺序\">#</a> 创建对象的顺序</h2>\n<ol>\n<li>调用静态代码块和静态属性初始化，两者的优先级相同，按照顺序执行。</li>\n<li>调用普通代码块和普通属性的初始化。</li>\n<li>调用构造方法。</li>\n</ol>\n<h2 id=\"子类创建对象的顺序\"><a class=\"markdownIt-Anchor\" href=\"#子类创建对象的顺序\">#</a> 子类创建对象的顺序</h2>\n<ol>\n<li><strong>父类</strong>的静态代码块和静态属性</li>\n<li>子类的静态代码块和静态属性</li>\n<li><strong>父类</strong>的普通代码块和普通属性初始化</li>\n<li>父类的构造方法</li>\n<li>子类的普通代码块和普通属性初始化</li>\n<li>子类的构造方法</li>\n</ol>\n<h2 id=\"单例模式实现步骤\"><a class=\"markdownIt-Anchor\" href=\"#单例模式实现步骤\">#</a> 单例模式实现步骤</h2>\n<ol>\n<li>构造器私有化，防止用户直接进行创建。</li>\n<li>类的内部创建对象</li>\n<li>向外暴露一个静态的方法：getInstance</li>\n<li>代码实现</li>\n</ol>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//饿汉式：在没有使用前就提前创建好对象，可以在getInstance方法中判断是否已经创建对象，改造为懒汉式</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GirlFriend</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"comment\">//类的内部创建对象,为了能够在静态方法中返回gf对象，需要将其修饰为static</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">GirlFriend</span> <span class=\"variable\">gf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">GirlFriend</span>(<span class=\"string\">&quot;小红&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">//构造器私有化</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">GirlFriend</span><span class=\"params\">(String name)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//向外暴露一个静态的方法：getInstance</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> GirlFriend <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gf;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"final关键字应用\"><a class=\"markdownIt-Anchor\" href=\"#final关键字应用\">#</a> final 关键字应用</h2>\n<ol>\n<li>final 可以修饰类、属性、方法和局部变量。</li>\n<li>当不希望类被继承，可以用 final 修饰。</li>\n<li>当不希望子类的某个方法被子类覆盖 / 重写时，可以用 final 关键字修饰。</li>\n<li>当不希望类的某个属性被修改，可以用 final 修饰。</li>\n<li>当不希望局部变量被修改，可以用 final 修饰。</li>\n</ol>\n<h3 id=\"final细节\"><a class=\"markdownIt-Anchor\" href=\"#final细节\">#</a> final 细节</h3>\n<ol>\n<li>final 修饰的属性又叫常量，一般用 XX_XX_XX 来命名</li>\n<li>final 修饰的属性在定义时必须赋初值，并且不能再进行修改，且只能在定义时、构造器和代码块中为其赋初值。</li>\n<li>如果该属性是静态的，则只能在定义时和静态代码块中赋初值。不能在构造器中赋初值，因为静态变量在类加载时创建，而构造器要在对象创建时才加载。</li>\n<li>如果一个类已经是 final 类了，就没有必要在将其方法修饰为 final 方法。</li>\n<li>final 不能修饰构造方法 (即构造器)。</li>\n<li>final 和 static 往往搭配使用，效率更高，不会导致类的加载，底层编译器做了优化处理。</li>\n<li>包装类 (Integer,Double,Float,Boolean 等都是 final)，String 也是 final 类。</li>\n<li>可以指定传入的形参为 final。</li>\n</ol>\n<h2 id=\"抽象类细节\"><a class=\"markdownIt-Anchor\" href=\"#抽象类细节\">#</a> 抽象类细节</h2>\n<ol>\n<li>抽象类不能被实例化。</li>\n<li>抽象类不一定要包含 abstract 方法，还可以有实现的方法。</li>\n<li>当一个类中存在抽象方法时，需要将该类声明为 abstract 类。</li>\n<li>abstract 只能修饰类和方法，不能修饰属性和其他的。</li>\n<li>抽象类可以有任意成员，因为其本质还是一个类，比如：非抽象方法、构造器、静态方法等。</li>\n<li>抽象方法不可以有主体。</li>\n<li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为抽象类。所谓实现方法就是有方法体。</li>\n<li>抽象方法不能使用 private、final 和 static 来修饰，因为这些关键字都是和重写相违背的。</li>\n</ol>\n<h2 id=\"接口\"><a class=\"markdownIt-Anchor\" href=\"#接口\">#</a> 接口</h2>\n<ol>\n<li>在 JDK7 之前，接口中所有方法都没有方法体，都是抽象方法。</li>\n<li>JDK8 后接口中可以有静态方法，默认方法，默认方法需要使用 default 关键字修饰，即接口中可以有方法的具体实现。</li>\n<li>多态传递，A 接口继承 B 接口，C 实现 A 接口，可以有 <code>B b = new c();</code> 。</li>\n<li>在接口中，抽象方法可以省略 abstract 关键字。</li>\n</ol>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Myinterface01</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">default</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;默认方法&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">t2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;静态方法&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Myinterface01</span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"接口细节\"><a class=\"markdownIt-Anchor\" href=\"#接口细节\">#</a> 接口细节</h3>\n<ol>\n<li>接口不能被实例化。</li>\n<li>接口中所有的方法都是 public 方法，接口中抽象方法可以不用 abstract 修饰。</li>\n<li>一个普通类实现接口，就必须将该接口的所有方法都实现。在 IJ 代码标黄处，使用 alt+enter 可以一键实现。</li>\n<li>抽象类实现接口，可以不用实现接口的方法。</li>\n<li>一个类可以同时多个接口。</li>\n<li><strong>接口中的属性，只能是 final 的，而且是 public static final 修饰符。</strong></li>\n<li>接口中属性的访问形式：接口名。属性名。</li>\n<li>接口不能继承其他的类，但是可以继承多个别的接口，使用 extends 关键字继承。</li>\n<li>接口的修饰符只能是 public 和默认，这点和类的修饰符是一样的。</li>\n</ol>\n<h3 id=\"接口与继承的区别\"><a class=\"markdownIt-Anchor\" href=\"#接口与继承的区别\">#</a> 接口与继承的区别</h3>\n<ol>\n<li>当子类继承了父类，就自动的拥有了父类的功能，如果子类需要扩展功能，可以通过实现接口的方式拓展。可以理解实现接口是对 java 单继承方式的补充。</li>\n<li>继承的价值主要在于：解决代码的复用性和可维护性。接口的价值主要在于：设计好各种规范，让其他类去实现这些方法。</li>\n<li>接口比继承更加灵活，继承满足 is-a 的关系，而接口只需满足 like-a 的关系。</li>\n<li>接口在一定程度上实现代码解耦。使用接口规范性 + 动态绑定。</li>\n</ol>\n<h3 id=\"接口练习\"><a class=\"markdownIt-Anchor\" href=\"#接口练习\">#</a> 接口练习</h3>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">B</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pX</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    System.out.println(x);<span class=\"comment\">//x不明确，访问接口使用A.x，父类使用super().x</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">C</span>().pX();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"内部类\"><a class=\"markdownIt-Anchor\" href=\"#内部类\">#</a> 内部类</h2>\n<p>一个类的内部又完整的嵌套了另一个类结构，被嵌套的类称为内部类，嵌套其他类的类称为外部类。</p>\n<p>内部类的最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。</p>\n<h3 id=\"内部类的划分\"><a class=\"markdownIt-Anchor\" href=\"#内部类的划分\">#</a> 内部类的划分</h3>\n<p>定义在外部类局部位置上（通常方法内）：</p>\n<ol>\n<li>局部内部类（有类名）</li>\n<li>匿名内部类（无类名，重点）</li>\n</ol>\n<p>定义在外部类的成员位置上：</p>\n<ol>\n<li>成员内部类（不使用 static 修饰）</li>\n<li>静态内部类（使用 static 修饰）</li>\n</ol>\n<h3 id=\"局部内部类\"><a class=\"markdownIt-Anchor\" href=\"#局部内部类\">#</a> 局部内部类</h3>\n<ol>\n<li>可以直接访问外部类的所有成员，包括私有的。</li>\n<li>除了可以使用 final 修饰，不能添加访问修饰符。</li>\n<li>内部类可以继续被同一外部类的内部类所继承。</li>\n<li>作用域仅仅在定义它的方法或代码块中。</li>\n<li>外部类在方法中，可以创建内部类对象，然后调用方法即可。</li>\n<li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类.this. 成员）去访问。</li>\n</ol>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Outer02</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">m2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Outer02 m2()&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">m1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//局部内部类是定义在外部类的局部位置，通常在方法</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Inner02</span>&#123;<span class=\"comment\">//本质还是一个类</span></span><br><span class=\"line\">      <span class=\"comment\">//可以直接访问外部类的所有成员，包括私有的</span></span><br><span class=\"line\">      <span class=\"type\">private</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">800</span>;</span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果外部类和局部内部类的成员重名时，默认遵循就近原则</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;n1=&quot;</span> + n1);<span class=\"comment\">//输出800</span></span><br><span class=\"line\">        <span class=\"comment\">//如果想访问外部类的成员，则可以使用（外部类.this.成员）去访问</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;外部类的n1=&quot;</span> + Outer02.<span class=\"built_in\">this</span>.n1);<span class=\"comment\">//输出100</span></span><br><span class=\"line\">        m2();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//外部类在方法中，可以创建内部类对象，然后调用方法即可</span></span><br><span class=\"line\">    <span class=\"type\">Inner02</span> <span class=\"variable\">inner02</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Inner02</span>();</span><br><span class=\"line\">    inner02.f1();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"匿名内部类\"><a class=\"markdownIt-Anchor\" href=\"#匿名内部类\">#</a> 匿名内部类</h3>\n<ol>\n<li>匿名内部类没有名字，底层有一个系统命名的名字，同时还是一个对象。</li>\n<li>tiger 的编译类型是 IA, 运行类型就是匿名内部类。</li>\n<li>底层分配的类名为外部类名 +$ 数字，可以使用 getClass () 查看。</li>\n<li>匿名内部类使用一次，就不能再使用，对象可以反复使用。</li>\n<li>我认为匿名内部类就是为了简便重写只需使用一次的类。</li>\n<li>匿名内部类可以当作实参直接传递，简介高效。</li>\n</ol>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Outer04</span>&#123;<span class=\"comment\">//外部类</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//基于接口的匿名内部类</span></span><br><span class=\"line\">    <span class=\"comment\">//以前想使用IA接口，是先写一个类实现该接口，并创建对象，如果只是使用一次，会很麻烦，此时使用匿名内部类</span></span><br><span class=\"line\">    <span class=\"comment\">//tiger的编译类型是IA,运行类型就是匿名内部类Outer04$1</span></span><br><span class=\"line\">    <span class=\"comment\">//底层分配的类名为外部类名+$次序，所以这个是Outer04$1，可以使用getClass()查看</span></span><br><span class=\"line\">    <span class=\"comment\">//jdk底层在创建匿名内部类后，马上就创建了实例，并且把地址返回给tiger。</span></span><br><span class=\"line\">    <span class=\"type\">IA</span> <span class=\"variable\">tiger</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IA</span>()&#123;</span><br><span class=\"line\">      <span class=\"meta\">@override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cry</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是老虎&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    tiger.cry();</span><br><span class=\"line\">    <span class=\"comment\">//由于有对象的性质，也可以直接调用,效果与上面的一样</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">IA</span>()&#123;</span><br><span class=\"line\">      <span class=\"meta\">@override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cry</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是老虎&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;.cry();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//基于类的匿名内部类</span></span><br><span class=\"line\">    <span class=\"comment\">//father编译类型是Father，运行类型是匿名内部类Outer04$2</span></span><br><span class=\"line\">    <span class=\"comment\">//参数列表会传递给Father的构造器</span></span><br><span class=\"line\">    <span class=\"type\">Father</span> <span class=\"variable\">father</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Father</span>(<span class=\"string\">&quot;jack&quot;</span>)&#123;</span><br><span class=\"line\">      <span class=\"meta\">@override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;匿名内部重写了test方法&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    father.test();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//基于抽象类的匿名内部类</span></span><br><span class=\"line\">    <span class=\"type\">Animal</span> <span class=\"variable\">animal</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span>()&#123;</span><br><span class=\"line\">      <span class=\"meta\">@override</span></span><br><span class=\"line\">      <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;eat东西&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IA</span>&#123;<span class=\"comment\">//接口</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cry</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Father</span>&#123;<span class=\"comment\">//类</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Father</span><span class=\"params\">(String name)</span>&#123;<span class=\"comment\">//构造器</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;<span class=\"comment\">//测试方法</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"成员内部类\"><a class=\"markdownIt-Anchor\" href=\"#成员内部类\">#</a> 成员内部类</h3>\n<ol>\n<li>成员内部类是定义在外部类的成员位置，并且没有 static 修饰。</li>\n<li>可以添加任意访问修饰符，因为它的地位就是一个成员。</li>\n<li>外部其他类访问成员内部类。<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Outer</span> <span class=\"variable\">outer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Outer</span>();</span><br><span class=\"line\"><span class=\"comment\">//方法1，相当于将new Inner()当作是outer的成员</span></span><br><span class=\"line\">Outer.<span class=\"type\">Inner</span> <span class=\"variable\">inner</span> <span class=\"operator\">=</span> outer.<span class=\"keyword\">new</span> <span class=\"title class_\">Inner</span>();</span><br><span class=\"line\"><span class=\"comment\">//方法2，在外部类中编写一个方法，返回对象实例</span></span><br><span class=\"line\">Outer.<span class=\"type\">Inner</span> <span class=\"variable\">inner</span> <span class=\"operator\">=</span> outer.getInner();</span><br></pre></td></tr></table></figure></div>\n</li>\n</ol>\n<h3 id=\"静态内部类\"><a class=\"markdownIt-Anchor\" href=\"#静态内部类\">#</a> 静态内部类</h3>\n<ol>\n<li>静态内部类是定义在外部类的成员位置，使用 static 进行修饰。</li>\n<li>可以访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员。</li>\n<li>外部其他类访问静态内部类<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法1,因为静态内部类是可以通过类名直接访问的</span></span><br><span class=\"line\">Outer.<span class=\"type\">Inner</span> <span class=\"variable\">inner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Outer</span>.Inner();</span><br><span class=\"line\"><span class=\"comment\">//方法2，在外部类中编写一个方法，返回对象实例</span></span><br><span class=\"line\">Outer.<span class=\"type\">Inner</span> <span class=\"variable\">inner</span> <span class=\"operator\">=</span> outer.getInner();</span><br></pre></td></tr></table></figure></div>\n</li>\n<li>重名时访问外部类的成员，可以使用外部类名。成员。</li>\n</ol>\n<h1 id=\"第九章-枚举和注解\"><a class=\"markdownIt-Anchor\" href=\"#第九章-枚举和注解\">#</a> 第九章 枚举和注解</h1>\n<h2 id=\"枚举\"><a class=\"markdownIt-Anchor\" href=\"#枚举\">#</a> 枚举</h2>\n<ol>\n<li>当我们使用 enum 关键字开发一个枚举类时，默认继承 Enum 类。</li>\n<li>如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略。</li>\n<li>枚举对象必须放在枚举类的行首。</li>\n</ol>\n<h3 id=\"枚举函数\"><a class=\"markdownIt-Anchor\" href=\"#枚举函数\">#</a> 枚举函数</h3>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ordinal()</td>\n<td>输出该枚举对象的次序，从 0 开始编号</td>\n</tr>\n<tr>\n<td>values()</td>\n<td>返回一个数组</td>\n</tr>\n<tr>\n<td>valueof()</td>\n<td>将字符串转换为枚举对象，要求字符串为已有的枚举对象</td>\n</tr>\n<tr>\n<td>compareTo()</td>\n<td>对比两个枚举对象的编号</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"枚举类\"><a class=\"markdownIt-Anchor\" href=\"#枚举类\">#</a> 枚举类</h3>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Season</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//要求将定义常量对象写在最前面</span></span><br><span class=\"line\">  SPRING(<span class=\"string\">&quot;春天&quot;</span>,<span class=\"string\">&quot;温暖&quot;</span>),WINTER(<span class=\"string\">&quot;冬天&quot;</span>,<span class=\"string\">&quot;寒冷&quot;</span>),AUTUMN(<span class=\"string\">&quot;秋天&quot;</span>,<span class=\"string\">&quot;凉爽&quot;</span>),SUMMER(<span class=\"string\">&quot;夏天&quot;</span>,<span class=\"string\">&quot;炎热&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String desc;</span><br><span class=\"line\">  <span class=\"comment\">//下面写构造器和各种方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"注解\"><a class=\"markdownIt-Anchor\" href=\"#注解\">#</a> 注解</h2>\n<p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入到代码中的补充信息。</p>\n<p>override 表示重写指定的父类方法（从编译层面验证），如果父类没有该方法，则会报错。</p>\n<p>元注解是修饰注解的注解。</p>\n<h3 id=\"常用注解\"><a class=\"markdownIt-Anchor\" href=\"#常用注解\">#</a> 常用注解</h3>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@override</td>\n<td>限定某个方法，是重写父类方法，该注释只能用于方法</td>\n</tr>\n<tr>\n<td>@Deprecated</td>\n<td>用于表示某个程序元素（类，方法，字段，包，参数等）已经过时</td>\n</tr>\n<tr>\n<td>@SuppressWarnings</td>\n<td>抑制编译器警告</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"元注解\"><a class=\"markdownIt-Anchor\" href=\"#元注解\">#</a> 元注解</h3>\n<table>\n<thead>\n<tr>\n<th>元注解</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Retention</td>\n<td>指定注解的作用范围，有 SOURCE、CLASS、RUNTINE</td>\n</tr>\n<tr>\n<td>Target</td>\n<td>指定注解可以在哪些地方使用</td>\n</tr>\n<tr>\n<td>Document</td>\n<td>指定该注解是否会在 javadoc 体现</td>\n</tr>\n<tr>\n<td>Inherited</td>\n<td>子类会继承父类注解</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"第十章-异常\"><a class=\"markdownIt-Anchor\" href=\"#第十章-异常\">#</a> 第十章 异常</h1>\n<p>java 语言中，将程序执行中发生的不正常现象称为 “异常”，开发中的语法错误和逻辑错误不是异常。</p>\n<p>异常分为两大类，运行时异常和编译时异常。</p>\n<p>编译时异常是必须处理的异常，是我们编写程序时需要避免的情况。</p>\n<p>自定义异常类名继承 Exception（编译异常）或 RuntimeException（运行异常）。</p>\n<h2 id=\"异常处理\"><a class=\"markdownIt-Anchor\" href=\"#异常处理\">#</a> 异常处理</h2>\n<p>IJ 中将该代码选中，输入快捷键 ctrl+alt+t，选中 try-catch 可以设置异常处理。</p>\n<p>如果异常发生了，则异常后的代码不再执行，直接进入 catch 代码块。</p>\n<p>可以有多个 catch 异常，捕获不同的异常，但要求父类异常在后，子类异常在前，如发生异常，只会匹配一个 catch。</p>\n<p>可以使用 try-finally，即不对异常进行任何处理。</p>\n<p>子类重写的方法所抛出的异常类型要么额父类抛出的异常一致，要么为父类抛出异常类型的子类型。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//try-catch-finally异常处理方式</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> num1 / num2;</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(ArithmeticException e)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//捕获不同的异常</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//程序捕获到异常后，将其封装成一个Exception对象</span></span><br><span class=\"line\">  e.printStackTrace();</span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//不管是否捕获到异常，始终执行</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//throws异常处理方式，返回给上一级函数处理，是系统默认的处理方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  f5();<span class=\"comment\">//会被标红，因为f2抛出的是编译异常</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">f2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> FileNotFoundException&#123;</span><br><span class=\"line\">  <span class=\"comment\">//使用throws抛出异常，让调用f2方法的调用者(方法)处理</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"常见运行异常\"><a class=\"markdownIt-Anchor\" href=\"#常见运行异常\">#</a> 常见运行异常</h2>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NullPointerException</td>\n<td>空指针异常</td>\n</tr>\n<tr>\n<td>ArithmeticException</td>\n<td>数学运算异常</td>\n</tr>\n<tr>\n<td>ArrayIndexOutOfBoundException</td>\n<td>数组下标越界异常</td>\n</tr>\n<tr>\n<td>ClassCastException</td>\n<td>类型转换异常</td>\n</tr>\n<tr>\n<td>NumberFormatException</td>\n<td>数字格式不正确异常</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"第十一章-常用类\"><a class=\"markdownIt-Anchor\" href=\"#第十一章-常用类\">#</a> 第十一章 常用类</h1>\n<h2 id=\"包装类\"><a class=\"markdownIt-Anchor\" href=\"#包装类\">#</a> 包装类</h2>\n<p>包装类是针对 8 种基本数据类型对应的引用类型。</p>\n<p>jdk5 以后实现了自动装箱和自动拆箱。</p>\n<p>三元运算符是一个整体，取最高精度。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"comment\">//装箱</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">integer1</span> <span class=\"operator\">=</span> Integer.valueOf(n1);<span class=\"comment\">//手动装箱</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">integer2</span> <span class=\"operator\">=</span> n1;<span class=\"comment\">//自动装箱，底层使用的仍是valueOf方法</span></span><br><span class=\"line\"><span class=\"comment\">//拆箱</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> integer1.intValue();<span class=\"comment\">//手动拆箱</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> integer2;<span class=\"comment\">//自动拆箱，底层使用的仍是intValue方法</span></span><br></pre></td></tr></table></figure></div>\n<h3 id=\"包装类与string转换\"><a class=\"markdownIt-Anchor\" href=\"#包装类与string转换\">#</a> 包装类与 String 转换</h3>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//包装类转String</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"comment\">//方式一，i本身没变化</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str1</span> <span class=\"operator\">=</span> i + <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//方式二,使用包装类的toString方法</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str2</span> <span class=\"operator\">=</span> i.toString();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str3</span> <span class=\"operator\">=</span> String.valueOf(i);</span><br><span class=\"line\"><span class=\"comment\">//String转包装类</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str4</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;12345&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i2</span> <span class=\"operator\">=</span> Integer.parseInt(str4);</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(str4);</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"例题\"><a class=\"markdownIt-Anchor\" href=\"#例题\">#</a> 例题</h3>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">obj1</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span> ? <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">1</span>):<span class=\"keyword\">new</span> <span class=\"title class_\">Double</span>(<span class=\"number\">2.0</span>);</span><br><span class=\"line\">System.out.println(obj1);</span><br><span class=\"line\"><span class=\"comment\">//输出结果为1.0，因为三元运算符为一个整体，最高为Double</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">System.out.println(i==j);</span><br><span class=\"line\"><span class=\"comment\">//输出FALSE，i和j此时是对象，对象相等判断地址是否相同</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">System.out.println(m==n);</span><br><span class=\"line\"><span class=\"comment\">//返回True，自动装箱底层是valueOf方法，在范围-128~127正确，这个数组是事先加载好的</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">127</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">127</span>;</span><br><span class=\"line\">System.out.println(i==j);</span><br><span class=\"line\"><span class=\"comment\">//返回True，只要有基本数据类型，判断的是值是否相同</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"string类\"><a class=\"markdownIt-Anchor\" href=\"#string类\">#</a> String 类</h2>\n<p>String 实现了 Serializable 接口，说明 String 可以串行化，即可以在网络中传输；Comparable 接口表示可以比较。</p>\n<p>字符串的字符使用 Unicode 编码，一个字符（不区分字母还是汉字）占两个字节。</p>\n<p>String 是 final 类，不能被其他的类继承。</p>\n<p>String 有属性 value [] 用于存放字符串内容，值得注意的是，该属性为 final，不可修改地址。</p>\n<h3 id=\"两种创建方法的区别\"><a class=\"markdownIt-Anchor\" href=\"#两种创建方法的区别\">#</a> 两种创建方法的区别</h3>\n<p><code>Srting s = 'hsp'</code> : 先从常量池查看是否有 “hsp” 数据空间，如果有则直接指向；如果没有则重新创建，然后指向，S 最终指向的是<strong>常量池</strong>的空间地址。</p>\n<p><code>String s = new String(&quot;hsp&quot;)</code> : 先在堆中创建空间，里面维护了 value 属性，指向常量池的 hsp 空间。如果常量池没有 “hsp”，重新创建，有则通过 value 指向。最终指向的是<strong>堆</strong>中的空间地址。可以使用 intern 方法返回常量池的地址。</p>\n<p><code>String a = &quot;hello&quot;+&quot;abc&quot;;</code>  只创建了一个对象，因为编译器会将其优化，先进行拼接。</p>\n<p><code>String s = a + &quot;hello&quot;</code>  底层会调用 StringBuilder，所以会指向<strong>堆</strong>中的空间地址。</p>\n<h3 id=\"string常用方法\"><a class=\"markdownIt-Anchor\" href=\"#string常用方法\">#</a> String 常用方法</h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>equals</td>\n<td>区分大小写</td>\n</tr>\n<tr>\n<td>equalsIgnoreCase</td>\n<td>忽略大小写判断内容是否相同</td>\n</tr>\n<tr>\n<td>length</td>\n<td>字符的个数，字符串的长度</td>\n</tr>\n<tr>\n<td>indexOf</td>\n<td>获取字符第一次出现的索引</td>\n</tr>\n<tr>\n<td>lastIndexOf</td>\n<td>获取字符最后一次出现的索引</td>\n</tr>\n<tr>\n<td>substring</td>\n<td>截取指定范围的子串</td>\n</tr>\n<tr>\n<td>trim</td>\n<td>去前后空格</td>\n</tr>\n<tr>\n<td>charAt</td>\n<td>获取某索引出的字符，注意不能使用 str [index] 方法</td>\n</tr>\n<tr>\n<td>contact</td>\n<td>拼接字符串</td>\n</tr>\n<tr>\n<td>replace</td>\n<td>替换字符串，原字符串不变化，返回的结果才是替换的</td>\n</tr>\n<tr>\n<td>split</td>\n<td>分割字符串</td>\n</tr>\n<tr>\n<td>toCharArray</td>\n<td>转换为字符数组</td>\n</tr>\n<tr>\n<td>compareTo</td>\n<td>比较大小</td>\n</tr>\n<tr>\n<td>format</td>\n<td>格式化字符串</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"例题-2\"><a class=\"markdownIt-Anchor\" href=\"#例题-2\">#</a> 例题</h3>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test1</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;hsp&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"type\">char</span>[] ch = &#123;<span class=\"string\">&#x27;j&#x27;</span>,<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;v&#x27;</span>,<span class=\"string\">&#x27;a&#x27;</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">change</span><span class=\"params\">(String str,<span class=\"type\">char</span> ch[])</span>&#123;</span><br><span class=\"line\">    str = <span class=\"string\">&quot;java&quot;</span>;<span class=\"comment\">//String类的更新实际上是更改地址</span></span><br><span class=\"line\">    ch[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;h&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">Text1</span> <span class=\"variable\">ex</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test1</span>();</span><br><span class=\"line\">  ex.change(ex.str,ex.ch);</span><br><span class=\"line\">  System.out.println(ex.str+<span class=\"string\">&quot;and&quot;</span>+ex.ch);</span><br><span class=\"line\">  <span class=\"comment\">//输出hspandhava</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"stringbuffer-stringbuilder类\"><a class=\"markdownIt-Anchor\" href=\"#stringbuffer-stringbuilder类\">#</a> StringBuffer、StringBuilder 类</h2>\n<p>StringBuffer 是一个容器，代表可变的字符序列，可以对字符串内容进行删减。</p>\n<p>String 保存的是字符串常量，里面的值不能更改，每次 String 类的实际上就是更改地址，效率较低；StringBuffer 值存放在堆中，每次更新实际上可以更新内容，不用每次更新地址。</p>\n<p>StringBuilder 一个可变的字符序列，提供与 StringBuffer 兼容的 API，但不保证同步，不是线程安全。其作为 StringBuffer 的一个简易替换，用于字符串缓冲区被单个线程使用，速度快于 StringBuffer。</p>\n<h3 id=\"string与stringbuffer转换\"><a class=\"markdownIt-Anchor\" href=\"#string与stringbuffer转换\">#</a> String 与 StringBuffer 转换</h3>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//String转StringBuffer</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello tom&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">StringBuffer</span> <span class=\"variable\">strB</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>(str);</span><br><span class=\"line\"><span class=\"comment\">//StringBuffer转String</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> strB.toString();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(strB);</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"stringbuffer常用方法\"><a class=\"markdownIt-Anchor\" href=\"#stringbuffer常用方法\">#</a> StringBuffer 常用方法</h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>append</td>\n<td>在末尾追加字符</td>\n</tr>\n<tr>\n<td>delete(start,end)</td>\n<td>删除区间内字符</td>\n</tr>\n<tr>\n<td>replace(start,end,string)</td>\n<td>将 start 到 end 中的字符替换成 string</td>\n</tr>\n<tr>\n<td>indexOf</td>\n<td>查找子串第一次出现的索引</td>\n</tr>\n<tr>\n<td>insert</td>\n<td>插入</td>\n</tr>\n<tr>\n<td>length</td>\n<td>获取长度</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"例题-3\"><a class=\"markdownIt-Anchor\" href=\"#例题-3\">#</a> 例题</h3>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"type\">StringBuffer</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">sb.append(str);<span class=\"comment\">//底层调用的是AbstractStringBuilder的appendNull，返回一个null字符串</span></span><br><span class=\"line\">System.out.println(sb.length());<span class=\"comment\">//输出4</span></span><br><span class=\"line\">System.out.println(sb);<span class=\"comment\">//输出null</span></span><br><span class=\"line\"><span class=\"type\">StringBuffer</span> <span class=\"variable\">sb1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>(str);<span class=\"comment\">//底层super(str.length()+16),length方法抛出空指针异常</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"math类\"><a class=\"markdownIt-Anchor\" href=\"#math类\">#</a> Math 类</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>abs</td>\n<td>绝对值</td>\n</tr>\n<tr>\n<td>pow</td>\n<td>求幂</td>\n</tr>\n<tr>\n<td>ceil</td>\n<td>向下取整</td>\n</tr>\n<tr>\n<td>floor</td>\n<td>向上取整</td>\n</tr>\n<tr>\n<td>round</td>\n<td>四舍五入</td>\n</tr>\n<tr>\n<td>sqrt</td>\n<td>开平方</td>\n</tr>\n<tr>\n<td>random</td>\n<td>返回 [0-1) 的随机数</td>\n</tr>\n<tr>\n<td>max</td>\n<td>最大值</td>\n</tr>\n<tr>\n<td>min</td>\n<td>最小值</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"arrays类\"><a class=\"markdownIt-Anchor\" href=\"#arrays类\">#</a> Arrays 类</h2>\n<h3 id=\"常用方法\"><a class=\"markdownIt-Anchor\" href=\"#常用方法\">#</a> 常用方法</h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>toString</td>\n<td>返回数组的字符串形式</td>\n</tr>\n<tr>\n<td>sort</td>\n<td>排序，分为自然排序和定制排序，因为数组是引用类型，所以会影响到实参</td>\n</tr>\n<tr>\n<td>binarySearch</td>\n<td>二分查找，要求已排序数组</td>\n</tr>\n<tr>\n<td>copyOf</td>\n<td>拷贝 n 个元素到新数组中</td>\n</tr>\n<tr>\n<td>fill</td>\n<td>数组填充，将原来的元素全部替换成新元素</td>\n</tr>\n<tr>\n<td>equals</td>\n<td>比较两个数组元素内容是否完全一致</td>\n</tr>\n<tr>\n<td>asList</td>\n<td>将一组数据转换为 list</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"定制排序\"><a class=\"markdownIt-Anchor\" href=\"#定制排序\">#</a> 定制排序</h4>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定制排序是通过传入一个接口Comparator实现定制排序规则</span></span><br><span class=\"line\">Arrays.sort(arr,<span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>()&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(object o1,object o2)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">i1</span> <span class=\"operator\">=</span> (Integer) o1;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">i2</span> <span class=\"operator\">=</span> (Integer) o2;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i2 - i1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"system类\"><a class=\"markdownIt-Anchor\" href=\"#system类\">#</a> System 类</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>exit</td>\n<td>退出当前程序</td>\n</tr>\n<tr>\n<td>arraycopy</td>\n<td>复制数组元素，比较适合底层调用</td>\n</tr>\n<tr>\n<td>currentTimeMillens</td>\n<td>返回当前时间距离 1970-1-1 的毫秒数</td>\n</tr>\n<tr>\n<td>gc</td>\n<td>垃圾回收机制</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"biginteger和bigdecimal\"><a class=\"markdownIt-Anchor\" href=\"#biginteger和bigdecimal\">#</a> BigInteger 和 BigDecimal</h2>\n<p>BigInteger 适合保存比较大的整型，BigDecimal 适合保存精度更高的浮点型。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明BigInteger</span></span><br><span class=\"line\"><span class=\"type\">BigInteger</span> <span class=\"variable\">big1</span> <span class=\"operator\">=</span>  <span class=\"keyword\">new</span> <span class=\"title class_\">BigInteger</span>(<span class=\"string\">&quot;57987978979879879&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">BigInteger</span> <span class=\"variable\">big2</span> <span class=\"operator\">=</span>  <span class=\"keyword\">new</span> <span class=\"title class_\">BigInteger</span>(<span class=\"string\">&quot;989898989898899879&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//在对BigInteger进行加减乘除的时候，需要使用对应的方法</span></span><br><span class=\"line\"><span class=\"type\">BigInteger</span> <span class=\"variable\">add</span> <span class=\"operator\">=</span> big1.add(big2);</span><br><span class=\"line\"><span class=\"type\">BigInteger</span> <span class=\"variable\">sub</span> <span class=\"operator\">=</span> big1.substract(big2);</span><br><span class=\"line\"><span class=\"type\">BigInteger</span> <span class=\"variable\">mul</span> <span class=\"operator\">=</span> big1.multiply(big2);</span><br><span class=\"line\"><span class=\"type\">BigInteger</span> <span class=\"variable\">div</span> <span class=\"operator\">=</span> big1.divide(big2);</span><br><span class=\"line\"><span class=\"comment\">//声明BigDecimal</span></span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">dec1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;489.5646545644454465&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">dec2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;8978978.564654564564544565&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//加减乘的方法与上面BigInteger相同，除法可能出现异常，结果可能无限循环小数</span></span><br><span class=\"line\"><span class=\"comment\">//在调用除法时，指定精度,ROUND_CEILING保留被除数原有的精度</span></span><br><span class=\"line\"><span class=\"type\">BigInteger</span> <span class=\"variable\">div</span> <span class=\"operator\">=</span> dec1.divide(dec2,BigDecimal.ROUND_CEILING);</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"日期类\"><a class=\"markdownIt-Anchor\" href=\"#日期类\">#</a> 日期类</h2>\n<h3 id=\"第一代日期类date\"><a class=\"markdownIt-Anchor\" href=\"#第一代日期类date\">#</a> 第一代日期类 Date</h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Date</td>\n<td>精确到毫秒，代表特定的瞬间</td>\n</tr>\n<tr>\n<td>SimpleDateFormat</td>\n<td>格式和解析日期的类</td>\n</tr>\n</tbody>\n</table>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();<span class=\"comment\">//获取日期</span></span><br><span class=\"line\"><span class=\"type\">SimpleDateFormat</span> <span class=\"variable\">sdf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleDateFormat</span>(<span class=\"string\">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);<span class=\"comment\">//设定格式</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">format</span> <span class=\"operator\">=</span> sdf.format(d1);</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;1996年01月01日 10:20:30 星期一&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">parse</span> <span class=\"operator\">=</span> sdf.parse(s);<span class=\"comment\">//将格式化字符串转化为日期</span></span><br></pre></td></tr></table></figure></div>\n<h3 id=\"第二代日期类calendar\"><a class=\"markdownIt-Anchor\" href=\"#第二代日期类calendar\">#</a> 第二代日期类 Calendar</h3>\n<p>Calender 是一个抽象类，并且构造器是 private，可以通过 getInstance () 来获取实例。</p>\n<p>存在的问题：可变性、偏移性、不可格式化、线程不安全、不能处理闰秒。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Calendar</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> Calendar.getInstance();<span class=\"comment\">//创建日历对象，不能使用new</span></span><br><span class=\"line\"><span class=\"comment\">//获取日历对象的字段，使用get方法</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;月：&quot;</span>+(c.get(Calendar.MONTH)+<span class=\"number\">1</span>));<span class=\"comment\">//月份从0开始，所以需要加1</span></span><br></pre></td></tr></table></figure></div>\n<h3 id=\"第三代日期类localdatetime\"><a class=\"markdownIt-Anchor\" href=\"#第三代日期类localdatetime\">#</a> 第三代日期类 LocalDateTime</h3>\n<p>LocalDate 只包含日期，LocalTime 只包含时间，LocalDateTime 日期和时间都包含。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">LocalDateTime</span> <span class=\"variable\">ldt</span> <span class=\"operator\">=</span> LocalDateTime.now();<span class=\"comment\">//创建对象，不能new</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;月=&quot;</span> + ldt.getMonth());<span class=\"comment\">//返回JULY</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;月=&quot;</span> + ldt.getMonthValue());<span class=\"comment\">//返回7</span></span><br><span class=\"line\"><span class=\"comment\">//使用DateTimeFormatter对象格式化</span></span><br><span class=\"line\"><span class=\"type\">DateTimeFormatter</span> <span class=\"variable\">dtf</span> <span class=\"operator\">=</span> DateTimeFormatter.ofPattern(<span class=\"string\">&quot;&quot;</span>yyyy年MM月dd日 HH小时mm分钟ss秒<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">format</span> <span class=\"operator\">=</span> dft.format(ldt);</span><br><span class=\"line\"><span class=\"comment\">//Instant时间戳，与Date相互转换</span></span><br><span class=\"line\"><span class=\"type\">Instant</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> Instant.now();</span><br><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">date</span> <span class=\"operator\">=</span> Date.from(now);</span><br><span class=\"line\"><span class=\"type\">Instant</span> <span class=\"variable\">instant</span> <span class=\"operator\">=</span> date.toInstant();</span><br><span class=\"line\"><span class=\"comment\">//提供plus和minus方法对当前日期进行加减操作</span></span><br><span class=\"line\"><span class=\"type\">LocalDateTime</span> <span class=\"variable\">ldt1</span> <span class=\"operator\">=</span> ldt.plusDays(<span class=\"number\">890</span>);<span class=\"comment\">//890天后的时间</span></span><br><span class=\"line\"><span class=\"type\">LocalDateTime</span> <span class=\"variable\">ldt1</span> <span class=\"operator\">=</span> ldt.minusMinutes(<span class=\"number\">8</span>);<span class=\"comment\">//8分钟前的时间</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"练习\"><a class=\"markdownIt-Anchor\" href=\"#练习\">#</a> 练习</h2>\n<p>编程技巧：对函数进行验证时，先写出正确的情况，然后取反即可。</p>\n<h1 id=\"第十二章-集合\"><a class=\"markdownIt-Anchor\" href=\"#第十二章-集合\">#</a> 第十二章 集合</h1>\n<p>集合可以动态保存任意多个对象，使用比较方便，并提供了一系列方便操作对象的方法。</p>\n<p>集合主要分为单列集合 (Collection) 和双列集合 (Map, 一般以键值对形式存在)。</p>\n<h2 id=\"collection接口\"><a class=\"markdownIt-Anchor\" href=\"#collection接口\">#</a> Collection 接口</h2>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/11606/f59eb486d97f8445f82ac823e1181265.png\"\n                      alt=\"Collection接口\" style=\"zoom:67%;\" \n                >\n<h3 id=\"collection常用方法\"><a class=\"markdownIt-Anchor\" href=\"#collection常用方法\">#</a> Collection 常用方法</h3>\n<p>Collection 接口没有被实例化，以实现子类 ArrayList 来演示。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>add</td>\n<td>增加元素</td>\n</tr>\n<tr>\n<td>remove</td>\n<td>删除元素，指定删除元素会返回布尔值，指定对象则返回被删除对象</td>\n</tr>\n<tr>\n<td>contains</td>\n<td>查找元素是否存在</td>\n</tr>\n<tr>\n<td>size</td>\n<td>返回元素个数</td>\n</tr>\n<tr>\n<td>isEmpty</td>\n<td>判断是否为空</td>\n</tr>\n<tr>\n<td>clear</td>\n<td>清空</td>\n</tr>\n<tr>\n<td>addAll</td>\n<td>添加多个元素</td>\n</tr>\n<tr>\n<td>containsAll</td>\n<td>查找多个元素是否都存在</td>\n</tr>\n<tr>\n<td>removeAll</td>\n<td>删除多个元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"迭代器的执行原理\"><a class=\"markdownIt-Anchor\" href=\"#迭代器的执行原理\">#</a> 迭代器的执行原理</h3>\n<p>快捷键 itit 快速生成 while 循环，而且 ctrl+j 可以查看所有快捷键。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Iterator</span> <span class=\"variable\">iterator</span> <span class=\"operator\">=</span> col.iterator();<span class=\"comment\">//获取迭代器</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(iterator.hasNext())&#123;<span class=\"comment\">//判断是否有下一元素</span></span><br><span class=\"line\">  <span class=\"type\">Object</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> iterator.next();<span class=\"comment\">//返回下一元素，类型为Object</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">iterator = col.iterator();<span class=\"comment\">//重置迭代器</span></span><br><span class=\"line\"><span class=\"comment\">//增强for循环，简化版的iterator</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(Object book:col)&#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;book=&quot;</span> + book);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"list接口\"><a class=\"markdownIt-Anchor\" href=\"#list接口\">#</a> List 接口</h3>\n<p>List 集合类中元素有序（即添加顺序和取出顺序一致），且可重复。</p>\n<p>List 集合中的每个元素都有其对应的顺序索引，支持索引，可以根据序号存取容器中的元素。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>add(int index,Object ele)</td>\n<td>在 index 位置插入 ele 元素</td>\n</tr>\n<tr>\n<td>addAll(int index,Collection eles)</td>\n<td>从 index 位置开始将 eles 的元素添加进来</td>\n</tr>\n<tr>\n<td>get</td>\n<td>获取指定位置的元素</td>\n</tr>\n<tr>\n<td>indexOf</td>\n<td>返回元素在集合中首次出现的位置</td>\n</tr>\n<tr>\n<td>lastIndexOf</td>\n<td>返回元素在集合中最后出现的位置</td>\n</tr>\n<tr>\n<td>remove</td>\n<td>删除指定位置的元素，并返回该元素</td>\n</tr>\n<tr>\n<td>set(int index,Object ele)</td>\n<td>设置指定位置的元素为 ele，相当于替换</td>\n</tr>\n<tr>\n<td>subList(int from,int to)</td>\n<td>返回从 from 到 to 的子集合</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"arraylist\"><a class=\"markdownIt-Anchor\" href=\"#arraylist\">#</a> ArrayList</h4>\n<p>ArrayList 可以放入 null，而且可以放多个。</p>\n<p>ArrayList 底层是由数组实现数据存储的，维护了一个 Object 类型的数组 elementData []。当创建 ArrayList 对象时，如果使用无参构造器，则 elementData<strong> 容量为 0</strong>，第一次添加时则扩容 elementData 为<strong> 10</strong>，如需要再次扩容，则扩容 elementData 为<strong> 1.5 倍</strong>。如果使用的是指定大小的构造器，则初始扩容 elementData 为指定大小，如需要再次扩容，则扩容 elementData 为<strong> 1.5 倍</strong>。</p>\n<p>ArrayList 基本等同于 Vector，除了 ArrayList 是线程不安全的（执行效率高），在多线程情况下，建议使用 Vector。</p>\n<p>transient 关键字表示该属性不会被序列化。</p>\n<h4 id=\"vector\"><a class=\"markdownIt-Anchor\" href=\"#vector\">#</a> Vector</h4>\n<p>Vector 底层也是一个对象数组，维护了一个 Object 类型的数组 elementData []。当创建 Vector 对象时，如果使用无参构造器，则调用有参构造器，设置<strong>容量为 10</strong>，需要扩容，则扩容 elementData 为<strong> 2 倍</strong>。如果使用的是指定大小的构造器，则初始扩容 elementData 为指定大小，如需要再次扩容，则扩容 elementData 为<strong> 2 倍</strong>。不过扩容大小可以自行指定。</p>\n<p>与 ArrayList 不同的是，Vector 是线程同步的，即线程安全的，带有 synchronized 关键字。</p>\n<h4 id=\"linkedlist\"><a class=\"markdownIt-Anchor\" href=\"#linkedlist\">#</a> LinkedList</h4>\n<p>LinkedList 底层实现了双向链表和双端队列，可以添加任意元素，且元素可以重复或为 null，但线程不安全，没有实现同步。</p>\n<h3 id=\"set接口\"><a class=\"markdownIt-Anchor\" href=\"#set接口\">#</a> Set 接口</h3>\n<p>Set 接口是无序的，即添加和取出的顺序不一致 (但是取出的顺序是固定的)，没有索引；不允许重复数据，使用最多只有一个 null。</p>\n<p>同 Collection 的迭代方式一样，因为 Set 接口是 Collection 接口的子接口，可以使用迭代器和增强 for，但是不能使用索引的方式来获取。</p>\n<h4 id=\"hashset\"><a class=\"markdownIt-Anchor\" href=\"#hashset\">#</a> HashSet</h4>\n<p>HashSet 的底层其实是 HashMap，而 HashMap 的底层是数组 + 链表 + 红黑树，在数据量小的时候为哈希中的拉链法，数据量大时会转化为红黑树。</p>\n<p>在添加数据时，先得到 hash 值，然后会转化为索引值，找到索引位置后判断是否已有元素，没有则直接加入，有则逐个调用 equals 方法比较，如果相同则放弃添加，否则将其添加到最后。在 java8 中，如果一条链表的元素个数超过 TREEIFY-THRESHOLD (默认是 8)，而且数组大小大于等于 MIN-TREEIFY-CAPACITY (默认为 64)，就会进行红黑树化。</p>\n<p>第一次添加时，table 扩容到 16，临界值为容量 * 加载因子 0.75 为 12。到达临界值后，会扩容 2 倍到 32，因此新的临界值等于 32 乘以 0.75=24，以此类推。还有一种导致扩容的情况是单条链已经超越 TREEIFY-THRESHOLD (默认是 8)，每超越一次，触发一次扩容。该容量是指元素的个数，不是只计算在第一个位置上的。</p>\n<p>LinkedHashSet 是 HashSet 的子类，底层是 LinkedHashMap，维护了一个数组 + 双向链表。其使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的。第一次添加时，直接将数组扩容到 16，数组类型是 <code>HashMap$Node</code>  存放的结点类型是 <code>LinkedHashMap$Entry</code> 。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//HashSet不能添加相同的元素</span></span><br><span class=\"line\">set.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"string\">&quot;Tom&quot;</span>));</span><br><span class=\"line\">set.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"string\">&quot;Tom&quot;</span>));<span class=\"comment\">//是可以的，因为是两个不同的元素</span></span><br><span class=\"line\">set.add(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;hsp&quot;</span>));</span><br><span class=\"line\">set.add(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;hsp&quot;</span>);<span class=\"comment\">//是不可以的，因为按照String的equals方法判断，两者是相同的</span></span><br><span class=\"line\"><span class=\"comment\">//哈希计算公式</span></span><br><span class=\"line\">hash = <span class=\"literal\">null</span> ? <span class=\"number\">0</span>:(h = key.hashcode())^(h&gt;&gt;&gt;<span class=\"number\">16</span>);</span><br><span class=\"line\"><span class=\"comment\">//相等判断,equals会根据key进行动态绑定</span></span><br><span class=\"line\">(k = e.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))</span><br></pre></td></tr></table></figure></div>\n<h4 id=\"treeset\"><a class=\"markdownIt-Anchor\" href=\"#treeset\">#</a> TreeSet</h4>\n<p>TreeSet 的底层是 TreeMap，可以进行排序，可以通过传入一个比较器 (匿名内部类) 来实现排序效果。构造器把传入的比较器对象赋给 TreeSet 底层的 TreeMap 的属性 this.comparator。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">TreeSet</span> <span class=\"variable\">treeset</span> <span class=\"operator\">=</span>  <span class=\"keyword\">new</span> <span class=\"title class_\">TreeSet</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>()&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(object o1,object o2)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((String) o1).compareTo((String) o2);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></div>\n<p>不允许传入相同 (以 Comparator 为准) 的元素，如果设定比较长度，则长度一样的不能加入。</p>\n<h2 id=\"mapjdk8\"><a class=\"markdownIt-Anchor\" href=\"#mapjdk8\">#</a> Map(JDK8)</h2>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/11606/01ad78be19da71cc384c01b6b8deeebb.png\"\n                      alt=\"Map接口\" style=\"zoom:50%;\" \n                >\n<p>Map 用于具有映射关系的数据，key 和 value 可以是任何引用类型的数据，会封装到 HashMap$Node 对象中。key 不允许重复，但允许为 null，而 value 允许重复，这种情况相当于进行替换。</p>\n<p>常用 String 类作为 Map 的 key。key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到对应的 value。</p>\n<p>HashMap 是 Map 接口使用频率最高的实现类，其没有实现同步，因此是线程不安全。</p>\n<p>HashTable 的键和值都不能为 null，而且是线程安全的。HashTable 的元素是 HashTable$Entry 类型的，使用 addEntry 方法添加元素。其初始容量为 11，扩容为 2 倍 + 1。</p>\n<p>Properties 还可以从 xxx.propertises 文件 (作为配置文件) 中加载数据到 Properties 类对象，并进行读取和修改</p>\n<h3 id=\"map常用方法\"><a class=\"markdownIt-Anchor\" href=\"#map常用方法\">#</a> Map 常用方法</h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>put</td>\n<td>添加</td>\n</tr>\n<tr>\n<td>remove</td>\n<td>根据键删除映射关系</td>\n</tr>\n<tr>\n<td>get</td>\n<td>根据键获取值</td>\n</tr>\n<tr>\n<td>size</td>\n<td>获取元素个数</td>\n</tr>\n<tr>\n<td>isEmpty</td>\n<td>判断是否为空</td>\n</tr>\n<tr>\n<td>clear</td>\n<td>清除</td>\n</tr>\n<tr>\n<td>containsKey</td>\n<td>查找键是否存在</td>\n</tr>\n<tr>\n<td>keySet</td>\n<td>获取所有的键</td>\n</tr>\n<tr>\n<td>entrySet</td>\n<td>获取所有的关系</td>\n</tr>\n<tr>\n<td>values</td>\n<td>获取所有的值</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"map遍历方式\"><a class=\"markdownIt-Anchor\" href=\"#map遍历方式\">#</a> Map 遍历方式</h3>\n<ol>\n<li>先取出所有的 key，通过 key 取出对应的 value。</li>\n<li>把所有 values 取出。</li>\n<li>通过 entrySet 方法获取，集合存放的数据的元素类型是 Entry，提供了 getKey 和 getValue 方法。<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Set</span> <span class=\"variable\">set</span> <span class=\"operator\">=</span> map.entrySet();<span class=\"comment\">//转换成entry类型</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(Object obj:set)&#123;</span><br><span class=\"line\">  Map.<span class=\"type\">Entry</span> <span class=\"variable\">entry</span> <span class=\"operator\">=</span> (Map.Entry) obj;<span class=\"comment\">//向下转型</span></span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">&quot;-&quot;</span> +entry.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n</li>\n</ol>\n<h2 id=\"collections工具类\"><a class=\"markdownIt-Anchor\" href=\"#collections工具类\">#</a> Collections 工具类</h2>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Collections的方法都是静态方法，传入参数即可调用</span></span><br><span class=\"line\">Collections.sort(list);</span><br></pre></td></tr></table></figure></div>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>reverse</td>\n<td>反转 List 中元素的顺序</td>\n</tr>\n<tr>\n<td>shuffle</td>\n<td>对 List 中元素进行随机排序</td>\n</tr>\n<tr>\n<td>sort</td>\n<td>对 List 元素进行升序排序，可以自行指定排序接口</td>\n</tr>\n<tr>\n<td>swap</td>\n<td>交换 List 中两个元素的位置</td>\n</tr>\n<tr>\n<td>max</td>\n<td>返回集合中的最大元素，可以自行指定排序接口</td>\n</tr>\n<tr>\n<td>min</td>\n<td>返回集合中的最小元素，可以自行指定排序接口</td>\n</tr>\n<tr>\n<td>frequency</td>\n<td>返回集合中指定元素的出现次数</td>\n</tr>\n<tr>\n<td>copy(List dest,List src)</td>\n<td>将一个 src 复制到 dest 中，需要 dest 的大小大于等于 src</td>\n</tr>\n<tr>\n<td>replaceAll</td>\n<td>使用新值替换 List 中的所有值</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"例题-4\"><a class=\"markdownIt-Anchor\" href=\"#例题-4\">#</a> 例题</h2>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">TreeSet</span> <span class=\"variable\">treeset</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeSet</span>();</span><br><span class=\"line\"><span class=\"comment\">//add方法，因为构造器没有传入Comparator接口的匿名内部类，</span></span><br><span class=\"line\"><span class=\"comment\">//所以底层会将尝试将Person转为Comparable类型，而Person没有实现，因此会报错，解决方法是实行Comparable接口</span></span><br><span class=\"line\">treeset.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//修改了hashcode为id和name绑定，equals是判断id和name是否相同</span></span><br><span class=\"line\"><span class=\"type\">HashSet</span> <span class=\"variable\">set</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>();</span><br><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">p1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"number\">1001</span>,<span class=\"string\">&quot;AA&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">p2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"number\">1002</span>,<span class=\"string\">&quot;BB&quot;</span>);</span><br><span class=\"line\">set.add(p1);</span><br><span class=\"line\">set.add(p2);</span><br><span class=\"line\">p1.name = <span class=\"string\">&quot;CC&quot;</span>;</span><br><span class=\"line\">set.remove(p1);<span class=\"comment\">//由于此时p1已被改变，哈希值改变，不能查找到原来位置，删除失败</span></span><br><span class=\"line\">set.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"number\">1001</span>,<span class=\"string\">&quot;AA&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">//p1的name发生改变，但在内部存储的位置不变，和新加入的不相同，所以能成功加入</span></span><br></pre></td></tr></table></figure></div>\n<h1 id=\"第十三章-泛型\"><a class=\"markdownIt-Anchor\" href=\"#第十三章-泛型\">#</a> 第十三章 泛型</h1>\n<p>传统方法不能对加入到集合中的数据进行约束，而且遍历的时候，需要类型转换，如果集合中的数据量较大，对效率有影响。</p>\n<p>泛型又称参数化类型，是 JDK5 出现的新特性，解决数据类型的安全性问题，在类声明或实例化时只要指定需要的具体类型即可。</p>\n<p>泛型的作用是在类声明时通过一个标识表示类中某个属性的类型，或者某个方法的返回值类型，或者参数类型。</p>\n<p>JUnit 单元测试框架首先输入 <code>@Test</code> ，然后在后面按 <code>alt+enter</code> ，然后点击方法旁边的运行键即可。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;Dog&gt; arraylist = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Dog&gt;();</span><br><span class=\"line\">ArrayList&lt;Dog&gt; arraylist = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();<span class=\"comment\">//简写形式，推荐使用</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Dog dog:arraylist)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//此时可以不再使用Object类，直接使用Dog，不用进行类型转换</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&lt;T&gt;&#123;</span><br><span class=\"line\">  T s;<span class=\"comment\">//此时s的数据类型指定的泛型决定&#x27;</span></span><br><span class=\"line\">  T[] ts = <span class=\"keyword\">new</span> <span class=\"title class_\">T</span>[<span class=\"number\">8</span>];<span class=\"comment\">//错误的，使用泛型的数组，不能初始化，因为数组在new不能确定T的类型，就无法在内存中开空间</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Person</span><span class=\"params\">(T s)</span>&#123;<span class=\"comment\">//T可以是参数类型</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.s = s;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> T <span class=\"title function_\">f</span><span class=\"params\">()</span>&#123;<span class=\"comment\">//E可以是返回类型</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>&lt;M,R&gt; <span class=\"keyword\">void</span> <span class=\"title function_\">fly</span><span class=\"params\">(M m,R r)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//泛型方法，调用方法声明的泛型</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fly1</span><span class=\"params\">(T t)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//不能称作泛型方法，只是使用了泛型，里面的泛型只能使用类声明的泛型</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">m1</span><span class=\"params\">(T t)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//静态方法不能使用泛型，因为静态是和类相关的，所以无法得知泛型的类型</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IA</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">IUsb</span>&lt;String,Double&gt;&#123;</span><br><span class=\"line\">  <span class=\"comment\">//在继承接口时指定泛型接口的类型</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IUsb</span>&lt;U,R&gt;&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"泛型使用细节\"><a class=\"markdownIt-Anchor\" href=\"#泛型使用细节\">#</a> 泛型使用细节</h2>\n<ol>\n<li><strong>泛型只能是引用类型，不可以是基本数据类型。</strong></li>\n</ol>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();<span class=\"comment\">//True</span></span><br><span class=\"line\">List&lt;<span class=\"type\">int</span>&gt; list2 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;<span class=\"type\">int</span>&gt;();<span class=\"comment\">//False</span></span><br></pre></td></tr></table></figure></div>\n<ol start=\"2\">\n<li>在给泛型指定具体类型后，可以传入该类型或其子类类型。</li>\n<li>如果没有指定泛型，则默认是 Object 类。</li>\n<li>使用泛型的数组，不能初始化，因为数组在 new 不能确定 T 的类型，就无法在内存中开空间。</li>\n<li>静态方法不能使用泛型，因为静态是和类相关的，所以无法得知泛型的类型。</li>\n</ol>\n<h2 id=\"泛型的通配符\"><a class=\"markdownIt-Anchor\" href=\"#泛型的通配符\">#</a> 泛型的通配符</h2>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//泛型不具备继承性</span></span><br><span class=\"line\">List&lt;Object&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\"><span class=\"comment\">//&lt;?&gt;:支持任意泛型类型</span></span><br><span class=\"line\"><span class=\"comment\">//&lt;? extends A&gt;:支持A类以及A类的子类，规定了泛型的上限</span></span><br><span class=\"line\"><span class=\"comment\">//&lt;? super A&gt;:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限</span></span><br></pre></td></tr></table></figure></div>\n<h1 id=\"第十四章-坦克大战\"><a class=\"markdownIt-Anchor\" href=\"#第十四章-坦克大战\">#</a> 第十四章 坦克大战</h1>\n<p>写并发程序，一定要考虑清楚，该线程什么时候结束。</p>\n<p>线程消亡了不代表它的对象会变为 null。</p>\n<p>主要实现了英雄坦克和敌人坦克的范围内移动和子弹的发射功能，还有子弹击中效果实现。</p>\n<h2 id=\"绘图\"><a class=\"markdownIt-Anchor\" href=\"#绘图\">#</a> 绘图</h2>\n<p>当组件第一次在屏幕显示的时候，程序会自动的调用 paint () 方法来绘制组件，还有在窗口最小化后在最大化；窗口的大小发生变化；repaint 函数被调用。</p>\n<p>画笔基础 JPanel 画笔类，主类继承 JFrame 画框类，这样才能画出图像。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DrawCircle</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">JFrame</span>&#123;<span class=\"comment\">//JFrame相当于画框</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">MyPenal</span> <span class=\"variable\">mp</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">DrawCircle</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DrawCircle</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//初始化面板</span></span><br><span class=\"line\">        mp = <span class=\"keyword\">new</span> <span class=\"title class_\">MyPenal</span>();</span><br><span class=\"line\">        <span class=\"comment\">//将面板放入到画框中</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.add(mp);</span><br><span class=\"line\">        <span class=\"comment\">//设置画框大小</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.setSize(<span class=\"number\">400</span>,<span class=\"number\">300</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<span class=\"comment\">//点击关闭按钮后程序退出</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.setVisible(<span class=\"literal\">true</span>);<span class=\"comment\">//可以显示</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyPenal</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">JPanel</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">paint</span><span class=\"params\">(Graphics g)</span> &#123;<span class=\"comment\">//绘图方法</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>.paint(g);<span class=\"comment\">//调用父类方法完成初始化</span></span><br><span class=\"line\">        <span class=\"comment\">//此处画椭圆的x,y不是圆心的坐标，而是椭圆形成的长方形的左上角坐标</span></span><br><span class=\"line\">        g.setColor(Color.BLUE);<span class=\"comment\">//设置颜色为蓝色</span></span><br><span class=\"line\">        g.drawOval(<span class=\"number\">10</span>,<span class=\"number\">10</span>,<span class=\"number\">100</span>,<span class=\"number\">100</span>);</span><br><span class=\"line\">        <span class=\"comment\">//绘制图片</span></span><br><span class=\"line\">        <span class=\"type\">Image</span> <span class=\"variable\">image</span> <span class=\"operator\">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class=\"string\">&quot;/哈哈.jpg&quot;</span>));</span><br><span class=\"line\">        g.drawImage(image,<span class=\"number\">10</span>,<span class=\"number\">10</span>,<span class=\"number\">500</span>,<span class=\"number\">500</span>,<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">//绘制文字</span></span><br><span class=\"line\">        g.setColor(Color.red);</span><br><span class=\"line\">        g.setFont(<span class=\"keyword\">new</span> <span class=\"title class_\">Font</span>(<span class=\"string\">&quot;宋体&quot;</span>,Font.BOLD,<span class=\"number\">50</span>));</span><br><span class=\"line\">        g.drawString(<span class=\"string\">&quot;北京你好&quot;</span>,<span class=\"number\">100</span>,<span class=\"number\">100</span>);<span class=\"comment\">//此处的x,y位置为左下角</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"常用方法-2\"><a class=\"markdownIt-Anchor\" href=\"#常用方法-2\">#</a> 常用方法</h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>drawLine</td>\n<td>画直线</td>\n</tr>\n<tr>\n<td>drawRect</td>\n<td>画矩形边框</td>\n</tr>\n<tr>\n<td>drawOval</td>\n<td>画椭圆边框</td>\n</tr>\n<tr>\n<td>fillRect</td>\n<td>填充矩形</td>\n</tr>\n<tr>\n<td>fillOval</td>\n<td>填充椭圆</td>\n</tr>\n<tr>\n<td>drawImage</td>\n<td>画图片，图片需要放在 out 文件夹下的 idea 文件夹下</td>\n</tr>\n<tr>\n<td>drawString</td>\n<td>画字符串</td>\n</tr>\n<tr>\n<td>setFont</td>\n<td>设置画笔的字体</td>\n</tr>\n<tr>\n<td>setColor</td>\n<td>设置画笔的颜色</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"事件处理\"><a class=\"markdownIt-Anchor\" href=\"#事件处理\">#</a> 事件处理</h2>\n<p>java 事件处理是采用 “委派事件模型”，当事件发生时，产生事件的对象，会将此 “信息” 传递给 “事件的监听者” 处理。</p>\n<p>控制小球移动需要画笔实现 KeyListener 接口监听键盘的操作，以实现对小球的控制，同时需要在主函数中监听对应的画笔才能实现功能。</p>\n<p>使用 getKeyCode () 方法可以获取键盘输入，每当发生变化时需要调用 repaint 方法进行图像重绘。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BallMove</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">JFrame</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">MyPenal</span> <span class=\"variable\">mp</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">BallMove</span> <span class=\"variable\">ballMove</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BallMove</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">BallMove</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        mp = <span class=\"keyword\">new</span> <span class=\"title class_\">MyPenal</span>();</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.add(mp);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.setSize(<span class=\"number\">400</span>, <span class=\"number\">300</span>);</span><br><span class=\"line\">        <span class=\"comment\">//窗口JFrame可以监听键盘事件，即可以监听面板发生的键盘事件</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.addKeyListener(mp);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.setVisible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//面板，可以画小球</span></span><br><span class=\"line\"><span class=\"comment\">//KeyListener是一个监听器，可以监听键盘时间，可以点击显示上下文生成三个需要实现的方法</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyPenal</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">JPanel</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">KeyListener</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//为了小球可以移动，把左上角坐标设置为变量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">y</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">paint</span><span class=\"params\">(Graphics g)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.paint(g);</span><br><span class=\"line\">        g.fillOval(x, y, <span class=\"number\">20</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//监听有字符输出时</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">keyTyped</span><span class=\"params\">(KeyEvent e)</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//当某个键被按下时</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">keyPressed</span><span class=\"params\">(KeyEvent e)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//System.out.println((char) e.getKeyCode() + &quot;被按下&quot;);</span></span><br><span class=\"line\">        <span class=\"comment\">//根据用户按下的不同键，来处理小球的移动</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.getKeyCode() == KeyEvent.VK_DOWN) &#123;<span class=\"comment\">//向下的箭头</span></span><br><span class=\"line\">            y++;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(e.getKeyCode()==KeyEvent.VK_UP)&#123;</span><br><span class=\"line\">            y--;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(e.getKeyCode()==KeyEvent.VK_LEFT)&#123;</span><br><span class=\"line\">            x--;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(e.getKeyCode()==KeyEvent.VK_RIGHT)&#123;</span><br><span class=\"line\">            x++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//让画笔重绘图像</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.repaint();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//当某个键被释放</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">keyReleased</span><span class=\"params\">(KeyEvent e)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h1 id=\"第十五章-线程基础\"><a class=\"markdownIt-Anchor\" href=\"#第十五章-线程基础\">#</a> 第十五章 线程 (基础)</h1>\n<p>** 在 java 中使用线程有两种方法，一种是继承 Thread 类，重写 run 方法；另一种是实行 Runnable，重写 run 方法。** 从 java 的设计来看，两者本质上没有区别，但实现 Runnable 接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制。</p>\n<p>Thread 类实现了 Runnable 接口的 run 方法。</p>\n<p>在控制台中输入 jconsole 可以查看线程信息。</p>\n<p><strong>为啥调用的是 start 方法，而不是 run 方法，因为 run 方法就是一个普通的方法，没有真正的启动一个线程，只是像以前一样顺序执行。线程是通过底层的 start0 方法实现的。</strong></p>\n<p>当线程完成任务后会自动退出，除此之外还可以通过使用变量来控制 run 方法停止线程，即通知方式。</p>\n<p>用户线程：也叫工作线程，当线程的任务执行完成或通知方式结束。</p>\n<p>守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束。最常见的守护线程是垃圾回收机制。</p>\n<p>可以在方法上加上 synchronized 关键字来实现同步。同步方法如果没有使用 static 修饰，默认锁对象为 this，如果方法使用 static 修饰，默认锁对象为当前类.class。</p>\n<p>在代码块上加锁：同步方法（非静态的）的锁可以是 this，也可以是其他对象（要求是同一个对象）；而同步方法（静态的）的锁是当前类本身。</p>\n<p>线程同步关键在于要求多个线程的锁的对象为同一个即可。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Thread01</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Cat</span> <span class=\"variable\">cat</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();</span><br><span class=\"line\">        cat.start();<span class=\"comment\">//启动线程，是start方法而不是run方法</span></span><br><span class=\"line\">        <span class=\"comment\">//如果是通过继承Runnable接口的方法，没有start方法，则要使用下面的方式</span></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(cat);<span class=\"comment\">//设计模式中的代理模式</span></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(cat);<span class=\"comment\">//多个线程共享一个资源</span></span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">        cat.setDaemon(<span class=\"literal\">true</span>);<span class=\"comment\">//设置为守护线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">time</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;<span class=\"comment\">//重写run方法，写上自己的业务逻辑</span></span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span>(<span class=\"built_in\">this</span>)&#123;<span class=\"comment\">//给该代码块加锁</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (time &lt; <span class=\"number\">20</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;我是西芹啊&quot;</span> + (++time));</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">//休眠1秒</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"常用方法-3\"><a class=\"markdownIt-Anchor\" href=\"#常用方法-3\">#</a> 常用方法</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>setName</td>\n<td>设置线程名称，使其与参数 name 相同</td>\n</tr>\n<tr>\n<td>getName</td>\n<td>返回线程的名称</td>\n</tr>\n<tr>\n<td>start</td>\n<td>使该线程开始执行，java 虚拟机底层调用该线程的 start0 方法</td>\n</tr>\n<tr>\n<td>run</td>\n<td>调用线程对象 run 方法</td>\n</tr>\n<tr>\n<td>setPriority</td>\n<td>更改线程的优先级</td>\n</tr>\n<tr>\n<td>getPriority</td>\n<td>获取线程的优先级</td>\n</tr>\n<tr>\n<td>sleep</td>\n<td>指定线程休眠的毫秒数</td>\n</tr>\n<tr>\n<td>interrupt</td>\n<td>中断线程，一般用于中断正在休眠的线程，此时会进入 catch 方法中</td>\n</tr>\n<tr>\n<td>yield</td>\n<td>线程的礼让，让出 CPU 使其他线程执行，但礼让的时间不确定，所以也不一定礼让成功</td>\n</tr>\n<tr>\n<td>join</td>\n<td>线程的插队，插队的线程一旦插队成功，则肯定让先执行完插入的线程所有的任务</td>\n</tr>\n<tr>\n<td>getState</td>\n<td>获取线程当前状态</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"线程的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#线程的生命周期\">#</a> 线程的生命周期</h2>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/11606/197a9592f2d9e99b7739720a71f36c13.png\"\n                      alt=\"线程的生命周期\"\n                ></p>\n<table>\n<thead>\n<tr>\n<th>生命周期</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NEW</td>\n<td>尚未启动的线程</td>\n</tr>\n<tr>\n<td>RUNNABLE</td>\n<td>在 java 虚拟机中执行的线程，可细分为 READY 和 RUNNING 两种状态</td>\n</tr>\n<tr>\n<td>BLOCKED</td>\n<td>被阻塞等待监视器锁定的线程</td>\n</tr>\n<tr>\n<td>WAITTING</td>\n<td>正在等待另一个线程执行特定动作的线程</td>\n</tr>\n<tr>\n<td>TIMED_WAITING</td>\n<td>正在等待另一个线程执行动作达到指定等待时间的线程</td>\n</tr>\n<tr>\n<td>TERMINATED</td>\n<td>已退出的线程</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"释放锁\"><a class=\"markdownIt-Anchor\" href=\"#释放锁\">#</a> 释放锁</h2>\n<h3 id=\"释放锁情况\"><a class=\"markdownIt-Anchor\" href=\"#释放锁情况\">#</a> 释放锁情况</h3>\n<ol>\n<li>当前线程的同步方法、同步代码块执行结束。</li>\n<li>当前线程在同步方法、同步代码块中遇到 break、return。</li>\n<li>当前线程在同步方法、同步代码块中出现了未处理的 Error 或 Exception，导致异常结束。</li>\n<li>当前线程在同步方法、同步代码块中执行了线程对象的 wait () 方法，当前线程释放，并释放锁。</li>\n</ol>\n<h3 id=\"不释放锁情况\"><a class=\"markdownIt-Anchor\" href=\"#不释放锁情况\">#</a> 不释放锁情况</h3>\n<ol>\n<li>线程执行同步方法、同步代码块时，程序调用了 Thread.sleep ()、Thread.yield () 方法暂停当前线程的执行，不会释放锁。</li>\n<li>线程执行同步代码块时，其他线程调用了该线程的 suspend () 方法将该线程挂起，不会释放锁。但应尽量避免使用 suspend () 和 resume () 来控制线程。</li>\n</ol>\n<h1 id=\"第十六章-io文件流\"><a class=\"markdownIt-Anchor\" href=\"#第十六章-io文件流\">#</a> 第十六章 IO 文件流</h1>\n<p>当文件读取完成后应将子资源释放，避免造成浪费。</p>\n<h2 id=\"新建文件\"><a class=\"markdownIt-Anchor\" href=\"#新建文件\">#</a> 新建文件</h2>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一种方式:new File(String pathname)根据路径创建一个File对象</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">filePath</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;e:\\\\news1.txt&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//这里的File对象，在java程序中只是一个对象</span></span><br><span class=\"line\"><span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(filePath);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二种方式:new File(File parent,String child)根据父目录文件+子路径创建</span></span><br><span class=\"line\"><span class=\"type\">File</span> <span class=\"variable\">parentFile</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;e:\\\\&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">fileName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;news2.txt&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(parentFile, fileName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第三种方法:new File(String parent,String child)根据父目录+子路径创建</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">parentPath</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;e:\\\\&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">fileName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;news3.txt&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(parentPath, fileName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//只有执行了createNewFile方法才会真正的在磁盘中创建该文件</span></span><br><span class=\"line\">file.createNewFile();</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"常用方法-4\"><a class=\"markdownIt-Anchor\" href=\"#常用方法-4\">#</a> 常用方法</h2>\n<p>在 java 编程中，目录也被当作是一种文件。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getName</td>\n<td>获取文件名称</td>\n</tr>\n<tr>\n<td>getAbsolutePath</td>\n<td>获取绝对路径</td>\n</tr>\n<tr>\n<td>getParent</td>\n<td>获取文件父级目录</td>\n</tr>\n<tr>\n<td>length</td>\n<td>文件大小，按字节统计</td>\n</tr>\n<tr>\n<td>exists</td>\n<td>文件或目录是否存在</td>\n</tr>\n<tr>\n<td>isFile</td>\n<td>是不是一个文件</td>\n</tr>\n<tr>\n<td>isDirectory</td>\n<td>是不是一个目录</td>\n</tr>\n<tr>\n<td>mkdir</td>\n<td>创建一级目录</td>\n</tr>\n<tr>\n<td>mkdirs</td>\n<td>创建多级目录</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>删除空目录或文件</td>\n</tr>\n<tr>\n<td>close</td>\n<td>关闭输入输出流</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"输入流和输出流\"><a class=\"markdownIt-Anchor\" href=\"#输入流和输出流\">#</a> 输入流和输出流</h2>\n<table>\n<thead>\n<tr>\n<th>抽象基类</th>\n<th>字节流 (二进制文件)</th>\n<th>字符流 (文本文件)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>输入流</td>\n<td>InputStream</td>\n<td>Reader</td>\n</tr>\n<tr>\n<td>输出流</td>\n<td>OutputStream</td>\n<td>Writer</td>\n</tr>\n</tbody>\n</table>\n<p>InputStream 常用子类：文件输入流 FileInputStream、缓冲字节输入流 BufferedInputStream、对象字节输入流 ObjectInputStream。</p>\n<p>可以使用 String 中的 getBytes () 方法将字符串转换为字符数组，使其可以使用 write 方法写入到文件中： <code>fileOutputStream.write(str.getBytes());</code> 。</p>\n<p>FileWriter 使用后，必须要关闭 (close) 或刷新 (flush)，否则写入不到指定的文件。</p>\n<p>比较特殊的是 read 方法返回的是 int 类型，所以要使用 int 变量接收后进行强转后输出。</p>\n<h2 id=\"节点流和处理流\"><a class=\"markdownIt-Anchor\" href=\"#节点流和处理流\">#</a> 节点流和处理流</h2>\n<p>节点流可以从一个特定的数据源读取数据。处理流 (又称包装流) 是 “连接” 在已存在的流之上，为程序提供更为强大的读写功能。</p>\n<p>节点流是底层流 / 低级流，直接跟数据源连接。</p>\n<p>处理流包装节点流，使用了修饰器设计模式，不会与数据源直接相连，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。</p>\n<p>处理流的功能主要体现在：性能的提高，以增加缓冲的方式提高输入输出的效率；操作的便捷，处理流提供了一系列便捷大方法来一次性输入输出大批量的数据，使用更加方便。</p>\n<p><strong>处理流对节点流的包装使用的多态，处理流拥有自身管理的节点流的父类属性，通过动态绑定机制实现对不同节点流的统一处理。</strong></p>\n<p>关闭处理流时只需关闭外层流即可，因为底层会自动的去关闭节点流。</p>\n<p>BufferedReader 和 BufferedWriter 都是按照字符串操作的处理流，不要去操作二进制文件，可能会导致文件损坏。</p>\n<h3 id=\"序列化和反序列化\"><a class=\"markdownIt-Anchor\" href=\"#序列化和反序列化\">#</a> 序列化和反序列化</h3>\n<p>序列化是指在保存数据时，保存数据的值和数据类型；反序列化是指在恢复数据时，恢复数据的值和数据类型。</p>\n<p>需要让某个对象支持序列化机制，则必须让其类是可序列化的，因此该类必须实现如下接口之一：Serializable 和 Exterenalizable。而 ObjectOutputStream 和 ObjectInputStream 提供了对基本数据类型或对象类型的序列化和反序列化的方法。</p>\n<p>序列化后保存的文件格式，不是存文本，而是按照它的格式进行存储。</p>\n<p>对于自定义的类而言，通过 readObject 方法读取到的对象的编译类型是 Object 类，而运行类型是本身的类型。</p>\n<p>序列化中的类中建议添加 SerialVersionUID，这个是序列化的版本号，可以提高版本的兼容性。</p>\n<p><strong>序列化对象时，默认将里面所有的对象进行序列化，除了 static 或 transient 修饰的成员，还有没有实现序列化接口的属性也是不会进行序列化的。</strong></p>\n<p>序列化具备可继承性，如果父类已经实现了序列化，则其所有子类也默认实现了序列化。</p>\n<h3 id=\"默认输入输出\"><a class=\"markdownIt-Anchor\" href=\"#默认输入输出\">#</a> 默认输入输出</h3>\n<p>System.in 的编译类型是 InputStream，运行类型是 BufferInputStream，默认输入是键盘。</p>\n<p>System.out 的编译类型是 PrintStream，运行类型是 PrintStream，默认输出是显示器。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//切换输出位置</span></span><br><span class=\"line\">System.setOut(<span class=\"keyword\">new</span> <span class=\"title class_\">PrintStream</span>(<span class=\"string\">&quot;e\\\\f1.txt&quot;</span>));</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;hello,world&quot;</span>);</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"转换流\"><a class=\"markdownIt-Anchor\" href=\"#转换流\">#</a> 转换流</h3>\n<p>在默认情况下，我们读取文件是按照 UTF-8 编码。</p>\n<p>转换流有 InputStreamReader 和 OutputStreamWriter，可以实现将字节流转换为字符流，并为其指定编码类型 (比如 UTF-8、gbk、gb2312、ISO8859-1 等)。</p>\n<p>当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换为字符流。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//首先将字节流转换为字符流</span></span><br><span class=\"line\"><span class=\"type\">InputStreamReader</span> <span class=\"variable\">isr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(file),<span class=\"string\">&quot;gbk&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//然后放入BufferedReader中提高读取效率，也可以将两步合成一步写</span></span><br><span class=\"line\"><span class=\"type\">BufferedReader</span> <span class=\"variable\">br</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(isr);</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"properties类\"><a class=\"markdownIt-Anchor\" href=\"#properties类\">#</a> Properties 类</h2>\n<p>该类是专门用于读写配置文件的集合类，键值对不需要有空格，值不需要引号，默认类型是 String。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Properties</span> <span class=\"variable\">properties</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">properties.load(<span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>(<span class=\"string\">&quot;src\\\\mysql.properties&quot;</span>));</span><br><span class=\"line\">properties.list(System.out);</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> properties.getProperty(<span class=\"string\">&quot;user&quot;</span>);</span><br><span class=\"line\">System.out.println(user);</span><br><span class=\"line\">properties.setProperty(<span class=\"string\">&quot;charset&quot;</span>,<span class=\"string\">&quot;utf8&quot;</span>);</span><br><span class=\"line\">properties.store(<span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(<span class=\"string\">&quot;src\\\\mysql2.properties&quot;</span>),<span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"常用方法-5\"><a class=\"markdownIt-Anchor\" href=\"#常用方法-5\">#</a> 常用方法</h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>load</td>\n<td>加载配置文件的键值对到 Properties 对象</td>\n</tr>\n<tr>\n<td>list</td>\n<td>将数据显示到指定设备</td>\n</tr>\n<tr>\n<td>getProperty(key)</td>\n<td>根据键获取值</td>\n</tr>\n<tr>\n<td>setProperty(key,value)</td>\n<td>设置键值对到 Properties 对象</td>\n</tr>\n<tr>\n<td>store</td>\n<td>将 Properties 中的键值对存储到配置文件，在 idea 中保存数据到配置文件，中文会存储为 Unicode 码</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"第十七章-网络通信\"><a class=\"markdownIt-Anchor\" href=\"#第十七章-网络通信\">#</a> 第十七章 网络通信</h1>\n<p>IPV4 使用 32 位表示地址，IPV6 使用 128 位地址。</p>\n<p>端口范围为 0-65535，而 0-1024 已经被占用，例如 ssh 占用 22，ftp 占用 21，smtp 占用 25，http 占用 90，常用的网络程序端口号 Tomcat 是 8080，mysql 是 3306，Oracle 是 1521，SQLserver 是 1433。</p>\n<p><strong>当客户端连接到服务端后，实际上客户端也是通过一个端口和服务端进行通信的，这个端口是 TCP/IP 进行随机分配的。</strong></p>\n<p><strong>语言本身就是协议。</strong></p>\n<h2 id=\"inetaddress类\"><a class=\"markdownIt-Anchor\" href=\"#inetaddress类\">#</a> InetAddress 类</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getLocalHost</td>\n<td>获取本机 InetAddress 对象</td>\n</tr>\n<tr>\n<td>getByName</td>\n<td>根据指定主机名 / 域名获取 ip 对象</td>\n</tr>\n<tr>\n<td>getHostName</td>\n<td>获取 InetAddress 对象的主机名</td>\n</tr>\n<tr>\n<td>getHostAddress</td>\n<td>获取 InetAddress 对象的地址</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"socket\"><a class=\"markdownIt-Anchor\" href=\"#socket\">#</a> Socket</h2>\n<p>套接字 (Socket) 开发网络应用程序被广泛采用，以至于成为事实上的标准。</p>\n<p><strong>通信的两端都要有 Socket，是两台机器间通信的端点，网络通信其实就是 Socket 之间的通信。</strong></p>\n<p>Socket 允许程序把网络连接当成一个流，数据在两个 Socket 间通过 IO 传输。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//客户端</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SocketTCP01Client</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.链接服务端(IP,端口)，连接本机9999端口，可以指定对应的IP地址，如果连接成功则返回socket对象</span></span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">socket</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Socket</span>(InetAddress.getLocalHost(), <span class=\"number\">9999</span>);</span><br><span class=\"line\">        <span class=\"comment\">//2.连接上后，生产socket，通过socket。getOutputStream()得到和socket对象关联的输出流对象</span></span><br><span class=\"line\">        <span class=\"type\">OutputStream</span> <span class=\"variable\">outputStream</span> <span class=\"operator\">=</span> socket.getOutputStream();</span><br><span class=\"line\">        <span class=\"comment\">//3.通过输出流，写入数据到数据通道</span></span><br><span class=\"line\">        outputStream.write(<span class=\"string\">&quot;hello,server&quot;</span>.getBytes());</span><br><span class=\"line\">        <span class=\"comment\">//设置结束标志,这样对方才能回复</span></span><br><span class=\"line\">        <span class=\"comment\">//在字符流中可以使用writer.newLine()写入结束标记，但对方需要使用readLine()</span></span><br><span class=\"line\">        socket.shutdownOutput();</span><br><span class=\"line\">        <span class=\"comment\">//4.关闭流对象和socket</span></span><br><span class=\"line\">        outputStream.close();</span><br><span class=\"line\">        socket.close();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;客户端结束&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//服务端</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SocketTCP01Server</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.在本机的9999端口监听，等待链接，要求本机没有其他服务在监听9999端口</span></span><br><span class=\"line\">        <span class=\"comment\">//这个ServerSocket可以通过accept()返回多个Socket对象</span></span><br><span class=\"line\">        <span class=\"type\">ServerSocket</span> <span class=\"variable\">serverSocket</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerSocket</span>(<span class=\"number\">9999</span>);</span><br><span class=\"line\">        <span class=\"comment\">//2.当没有客户端连接9999端口时，程序会阻塞，等待链接;如果有客户连接，则会返回Socket对象，程序继续</span></span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">socket</span> <span class=\"operator\">=</span> serverSocket.accept();</span><br><span class=\"line\">        <span class=\"comment\">//3.通过socket.getInputStream()读取客户端写入到数据通道的数据，显示</span></span><br><span class=\"line\">        <span class=\"type\">InputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> socket.getInputStream();</span><br><span class=\"line\">        <span class=\"comment\">//4.IO读取</span></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">readLen</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((readLen = inputStream.read(buf)) != -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(buf,<span class=\"number\">0</span>,readLen));<span class=\"comment\">//根据读取到的实际长度，显示内容</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//5.关闭流和socket</span></span><br><span class=\"line\">        inputStream.close();</span><br><span class=\"line\">        socket.close();</span><br><span class=\"line\">        serverSocket.close();<span class=\"comment\">//关闭</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"上传图片到客户端\"><a class=\"markdownIt-Anchor\" href=\"#上传图片到客户端\">#</a> 上传图片到客户端</h3>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//文件上传服务端</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TCPFileUploadServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.服务端在本机监听8888端口</span></span><br><span class=\"line\">        <span class=\"type\">ServerSocket</span> <span class=\"variable\">serverSocket</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerSocket</span>(<span class=\"number\">8888</span>);</span><br><span class=\"line\">        <span class=\"comment\">//2.等待连接</span></span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">socket</span> <span class=\"operator\">=</span> serverSocket.accept();</span><br><span class=\"line\">        <span class=\"comment\">//3.读取客户端发送的数据，通过socket得到一个输入流</span></span><br><span class=\"line\">        <span class=\"type\">BufferedInputStream</span> <span class=\"variable\">bis</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedInputStream</span>(socket.getInputStream());</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bytes = StreamUtils.streamToByteArray(bis);<span class=\"comment\">//使用老韩的工具</span></span><br><span class=\"line\">        <span class=\"comment\">//4.将数组写入到指定的路径，就得到一个文件了</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">destFilePath</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;src\\\\qie2.png&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">BufferedOutputStream</span> <span class=\"variable\">bos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedOutputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(destFilePath));</span><br><span class=\"line\">        bos.write(bytes);</span><br><span class=\"line\">        bos.close();</span><br><span class=\"line\">        <span class=\"comment\">//5.向客户端回复“收到图片”</span></span><br><span class=\"line\">        <span class=\"type\">BufferedWriter</span> <span class=\"variable\">writer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedWriter</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class=\"line\">        writer.write(<span class=\"string\">&quot;收到图片&quot;</span>);</span><br><span class=\"line\">        writer.flush();<span class=\"comment\">//刷新内容到数据通道</span></span><br><span class=\"line\">        socket.shutdownOutput();<span class=\"comment\">//写入结束标志</span></span><br><span class=\"line\">        <span class=\"comment\">//6.关闭其他资源</span></span><br><span class=\"line\">        writer.close();</span><br><span class=\"line\">        bis.close();</span><br><span class=\"line\">        socket.close();</span><br><span class=\"line\">        serverSocket.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//文件上传的客户端</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TCPFileUploadClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.客户端连接服务端8888，得到Socket对象</span></span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">socket</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Socket</span>(InetAddress.getLocalHost(), <span class=\"number\">8888</span>);</span><br><span class=\"line\">        <span class=\"comment\">//2.创建读取磁盘文件的输入流</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">filePath</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;e:\\\\qie.png&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">BufferedInputStream</span> <span class=\"variable\">bis</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(filePath));</span><br><span class=\"line\">        <span class=\"comment\">//调用老韩的文件实现转换</span></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bytes = StreamUtils.streamToByteArray(bis);</span><br><span class=\"line\">        <span class=\"comment\">//3.通过socket获取到输出流，将byte数据发送给服务端</span></span><br><span class=\"line\">        <span class=\"type\">BufferedOutputStream</span> <span class=\"variable\">bos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedOutputStream</span>(socket.getOutputStream());</span><br><span class=\"line\">        bos.write(bytes);<span class=\"comment\">//将文件的内容写入数据通道</span></span><br><span class=\"line\">        bis.close();</span><br><span class=\"line\">        socket.shutdownOutput();<span class=\"comment\">//结束标记</span></span><br><span class=\"line\">        <span class=\"comment\">//4.接受服务端回复的消息</span></span><br><span class=\"line\">        <span class=\"type\">InputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> socket.getInputStream();</span><br><span class=\"line\">        <span class=\"comment\">//使用老韩工具，将接受到的数据转换为字符串</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> StreamUtils.streamToString(inputStream);</span><br><span class=\"line\">        System.out.println(s);</span><br><span class=\"line\">        <span class=\"comment\">//5.关闭流</span></span><br><span class=\"line\">        inputStream.close();</span><br><span class=\"line\">        bos.close();</span><br><span class=\"line\">        socket.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"netstat指令\"><a class=\"markdownIt-Anchor\" href=\"#netstat指令\">#</a> netstat 指令</h2>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>netstat -an</td>\n<td>可以查看当前主机网络情况，包括端口监听情况和网络连接情况。 netstat -an|more 可以分页显示</td>\n</tr>\n<tr>\n<td>netstat -an|more</td>\n<td>可以分页显示</td>\n</tr>\n<tr>\n<td>netstat -anb</td>\n<td>查看是哪个程序在使用该端口，需要管理员权限</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"udp网络编程\"><a class=\"markdownIt-Anchor\" href=\"#udp网络编程\">#</a> UDP 网络编程</h2>\n<p>类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。</p>\n<p>UDP 数据报数据通过数据报套接字 DatagramSocket 发送和接收，系统不保证 UDP 数据报一定能安全送到目的地，也不能确定什么时候可以抵达。</p>\n<p>DatagramPacket 对象封装了 UDP 数据，在数据报中包含了发送端的 IP 地址和端口号已经接收端的 IP 地址和端口号。UDP 协议中每个数据报都给出了完整的地址信息，因此无需建立发送方和接收方的连接。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//UDP接收端</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UDPReceiverA</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.创建一个DatagramSocket对象，准备在9999接收数据</span></span><br><span class=\"line\">        <span class=\"type\">DatagramSocket</span> <span class=\"variable\">socket</span>  <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DatagramSocket</span>(<span class=\"number\">9999</span>);</span><br><span class=\"line\">        <span class=\"comment\">//2.构建一个DatagramPacket对象，准备接收数据,数据包最大64k</span></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">        <span class=\"type\">DatagramPacket</span> <span class=\"variable\">packet</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DatagramPacket</span>(buf, buf.length);</span><br><span class=\"line\">        <span class=\"comment\">//3.调用接收方法，准备接收数据，将数据填充到packet中</span></span><br><span class=\"line\">        socket.receive(packet);</span><br><span class=\"line\">        <span class=\"comment\">//4.将packet进行拆包，取出数据并显示</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> packet.getLength();<span class=\"comment\">//获取实际接收到的长度</span></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] data = packet.getData();<span class=\"comment\">//实际上的数据</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(data, <span class=\"number\">0</span>, length);</span><br><span class=\"line\">        System.out.println(s);</span><br><span class=\"line\">        <span class=\"comment\">//5.关闭资源</span></span><br><span class=\"line\">        socket.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//UDP发送端</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UDPSenderB</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.创建DatagramSocket对象，准备在9998接收数据</span></span><br><span class=\"line\">        <span class=\"type\">DatagramSocket</span> <span class=\"variable\">socket</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DatagramSocket</span>(<span class=\"number\">9998</span>);</span><br><span class=\"line\">        <span class=\"comment\">//2.将需要发送的数据封装到DatagramPacket对象，使用ipconfig查询ip地址</span></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] data = <span class=\"string\">&quot;hello,明天吃火锅~&quot;</span>.getBytes();</span><br><span class=\"line\">        <span class=\"type\">DatagramPacket</span> <span class=\"variable\">packet</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DatagramPacket</span>(data, data.length, InetAddress.getByName(<span class=\"string\">&quot;192.168.116.1&quot;</span>), <span class=\"number\">9999</span>);</span><br><span class=\"line\">        socket.send(packet);</span><br><span class=\"line\">        <span class=\"comment\">//3.关闭资源</span></span><br><span class=\"line\">        socket.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h1 id=\"第十八章-反射\"><a class=\"markdownIt-Anchor\" href=\"#第十八章-反射\">#</a> 第十八章 反射</h1>\n<p>反射可以通过外部文件设置，在不修改源码的基础上来控制程序，也符合设计模式的开闭原则。</p>\n<p>反射机制允许程序在执行期借助反射取得任何类的内部信息 (比如成员变量、构造器和成员方法等等)，并能操作对象的属性及方法。反射的应用广泛，在设计模式和框架底层都会用到。</p>\n<p>加载完类之后，在堆中就产生了一个 class 类型的对象 (一个类只有一个 Class 对象)，这个对象包含了类的完整结构信息。通过这个对象可以得到类的结构。这个 Class 对象就像是一面镜子，透过这个镜子可以看到类的结构，所以形象的将其称为：反射。</p>\n<p><strong>反射的优点是可以动态的创建和使用对象 (也是框架底层核心)，使用灵活，没有反射机制，框架技术就失去底层支撑。缺点是反射基本是解释执行，对执行速度有影响。</strong></p>\n<p>Method 和 Field、Constructor 对象都有 setAccessible () 方法，该方法作用是启动和禁止访问安全检查的开关，参数值为 true 表示反射的对象在使用时取消访问检查，提高反射的效率。</p>\n<p>静态加载在编译时加载相关的库，如果没有则报错，依赖性太强。动态加载在运行时加载需要的库，如果运行时不用该类，即使不存在该类，则不报错，降低了依赖性。</p>\n<p>** 类加载的时机：创建对象、子类被加载、调用类中的静态方法、通过反射。** 其中只有反射是动态加载，其余都是静态加载。</p>\n<p>在反射中，如果方法有返回值，统一返回 Object 类型，但运行类型和方法定义的返回类型一致。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/11606/bc8de307116765133225103e6b99267a.png\"\n                      alt=\"反射机制\"\n                ></p>\n<h2 id=\"反射的使用\"><a class=\"markdownIt-Anchor\" href=\"#反射的使用\">#</a> 反射的使用</h2>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从配置文件中读取到类cat和需要被调用的方法methodName</span></span><br><span class=\"line\"><span class=\"comment\">//1.加载类，返回class类型的对象cls</span></span><br><span class=\"line\"><span class=\"type\">Class</span> <span class=\"variable\">cls</span> <span class=\"operator\">=</span> Class.forName(classfullpath);</span><br><span class=\"line\"><span class=\"comment\">//2.通过cls得到加载的类Cat的对象实例</span></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> cls.newInstance();</span><br><span class=\"line\"><span class=\"comment\">//3.通过cls得到你加载的Cat的methodName对应的方法&quot;hi&quot;的方法对象</span></span><br><span class=\"line\"><span class=\"comment\">//在反射中，可以把方法视为对象（万物皆对象）</span></span><br><span class=\"line\"><span class=\"type\">Method</span> <span class=\"variable\">method1</span> <span class=\"operator\">=</span> cls.getMethod(methodName);</span><br><span class=\"line\"><span class=\"comment\">//4.通过method1调用方法，即通过方法对象来实现调用方法</span></span><br><span class=\"line\">method1.invoke(o);<span class=\"comment\">//反射机制：方法.invoke(对象)</span></span><br><span class=\"line\"><span class=\"type\">Field</span> <span class=\"variable\">nameField</span> <span class=\"operator\">=</span> cls.getField(<span class=\"string\">&quot;age&quot;</span>);</span><br><span class=\"line\">System.out.println(nameField.get(o));</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"创建实例\"><a class=\"markdownIt-Anchor\" href=\"#创建实例\">#</a> 创建实例</h2>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取User类的Class对象</span></span><br><span class=\"line\"><span class=\"type\">Class</span> <span class=\"variable\">userclass</span> <span class=\"operator\">=</span> Class.forName(<span class=\"string\">&quot;User&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//调用无参构造器创建实例</span></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> userClass.newInstance();</span><br><span class=\"line\"><span class=\"comment\">//调用有参public构造器创建实例</span></span><br><span class=\"line\"><span class=\"type\">Constructor</span> <span class=\"variable\">constructor</span> <span class=\"operator\">=</span> userClass.getConstructor(String.class);<span class=\"comment\">//获取构造器</span></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">hsp</span> <span class=\"operator\">=</span> constructor.newInstance(<span class=\"string\">&quot;hsp&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//调用非public构造器创建实例</span></span><br><span class=\"line\"><span class=\"type\">Constructor</span> <span class=\"variable\">constructor</span> <span class=\"operator\">=</span> userClass.getDeclaredConstructor(<span class=\"type\">int</span>.class,String.class);<span class=\"comment\">//获取构造器</span></span><br><span class=\"line\">constructor.setAccessible(<span class=\"literal\">true</span>);<span class=\"comment\">//暴破，强行访问非public的构造方法</span></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">hsp</span> <span class=\"operator\">=</span> constructor.newInstance(<span class=\"number\">100</span>,<span class=\"string\">&quot;hsp&quot;</span>);</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"反射的作用\"><a class=\"markdownIt-Anchor\" href=\"#反射的作用\">#</a> 反射的作用</h2>\n<ol>\n<li>在运行时判断任意一个对象所属的类</li>\n<li>在运行时构造任意一个类的对象</li>\n<li>在运行时得到任意一个类所具有的成员变量和方法</li>\n<li>在运行时调用任意一个对象的成员变量和方法</li>\n<li>生成动态代理</li>\n</ol>\n<h2 id=\"反射的主要类\"><a class=\"markdownIt-Anchor\" href=\"#反射的主要类\">#</a> 反射的主要类</h2>\n<p>这些类在 java.lang.reflection</p>\n<table>\n<thead>\n<tr>\n<th>类</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>java.lang.Class</td>\n<td>代表一个类，Class 对象表示某个类加载后在堆中的对象</td>\n</tr>\n<tr>\n<td>java,lang.reflect.Method</td>\n<td>代表类的方法，Method 对象表示某个类的方法</td>\n</tr>\n<tr>\n<td>java.lang.reflect.Field</td>\n<td>代表类的成员变量，获取公有的成员变量</td>\n</tr>\n<tr>\n<td>java.lang.reflect.Constructor</td>\n<td>代表类的构造方法</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"class类\"><a class=\"markdownIt-Anchor\" href=\"#class类\">#</a> Class 类</h2>\n<ol>\n<li>Class 也是类，因此也继承 Object 类</li>\n<li>Class 类对象不是 new 出来的，而是系统创建的</li>\n<li>对于某个类的 Class 对象，在内存中只有一份，因为类只加载一次</li>\n<li>每个类的实例都会知道自己是由哪个 Class 实例所生成</li>\n<li>通过 Class 对象可以完整地得到一个类的完整结构</li>\n<li>Class 对象是存放在堆的</li>\n<li>类的字节码二进制数据是放在方法区的，有的地方称为类的元数据 (包括方法代码、变量名、方法名、访问权限等)。</li>\n</ol>\n<h2 id=\"类加载\"><a class=\"markdownIt-Anchor\" href=\"#类加载\">#</a> 类加载</h2>\n<p>加载阶段：JVM 在该阶段的主要目的是将字节码从不同的数据源 (可能是 class 文件，也可能是 jar 包，甚至是网络) 转化为二进制字节流加载到内存中，并生成一个代表该类的 java.lang.Class 对象。</p>\n<p>连接阶段 - 验证：目的是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证包括文件格式验证、元数据验证、字符码验证和符号引用验证。</p>\n<p>连接阶段 - 准备：JVM 会在该阶段对静态变量分配内存并默认初始化 (对应数据类型的默认初始化值)。这些变量所使用的内存将在方法区中进行分配。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//n1是实例变量，不是静态变量，因此在准备阶段不会分配内存</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"comment\">//n2是静态变量，分配内存并初始化为默认值0，而不是20</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">n2</span> <span class=\"operator\">=</span> <span class=\"number\">20</span>;</span><br><span class=\"line\">  <span class=\"comment\">//n3是static final是常量，和静态变量不一样，直接赋值为30</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">n3</span> <span class=\"operator\">=</span> <span class=\"number\">30</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>连接阶段 - 解析：虚拟机将常量池内的符号引用替换为直接引用的过程。</p>\n<p>初始化：到初始化阶段才真正开始执行类中定义的 java 程序代码，此阶段是执行 <code>&lt;clinit&gt;()</code>  方法的过程。该方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值语句和静态代码块中的语句，并进行合并。</p>\n<p>虚拟机会保证一个类的 <code>&lt;clinit()&gt;</code>  方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行该方法，其他线程都需要阻塞等待，直到活动线程执行该方法完毕。</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/11606/80ec4d8b21e1f9775fbc5bc6f0f628a8.png\"\n                      alt=\"连接 Linking\"  \n                >\n<h1 id=\"第十九章-mysql\"><a class=\"markdownIt-Anchor\" href=\"#第十九章-mysql\">#</a> 第十九章 MySQL</h1>\n<p>数据库表的一行成为一条记录，在 java 程序中，一行记录往往使用对象表示。</p>\n<p>在创建数据库，表的时候，为了规避关键字，可以使用反引号解决。</p>\n<p>delete 语句不能删除某一列的数据，可以使用 update 设为 null 或者‘’。</p>\n<p>select 语句可以通过指定 distinct 参数来选择是否显示重复的数据。</p>\n<p>count (*) 返回满足条件的记录的行数；count (‘列名’) 也会返回满足条件的记录的某列有多少个，但是会排除为 null。</p>\n<p>like 模糊查找，% 表示多个任意字符，_表示单个任意字符。</p>\n<p>为了给某个 SQL 语句进行效率测试，我们需要海量数据时，可以使用该方法为表创建海量数据。</p>\n<p>union all 将两个查询结果合并，不会去重；union 合并时会进行去重。</p>\n<p>可以使用 auto_increment 实现自增长，填入数据时只需填入 null，数据会自行增长，如果填入值，则以该值为准。自增长的机制是选取当前的最大值进行加一。</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into my_tab01 select * from my_tab01 # 自我复制</span><br><span class=\"line\"># 将my_tab01表的结构(列)复制到my_tab02中</span><br><span class=\"line\">create table my_tab02 like my_tab01;</span><br><span class=\"line\"># 修改自增长的起始值为100</span><br><span class=\"line\">alter table t25 auto_increment = 100;</span><br><span class=\"line\">select empno,ename name,sal salary from emp;# 正确，可以省略as</span><br><span class=\"line\"># 错误，Annual Salary中间有空格，编译器无法明白，改为&quot;Annual Salary&quot;，或者中间加上下划线</span><br><span class=\"line\">select ename,sal*12 Annual Salary from emp;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"索引\"><a class=\"markdownIt-Anchor\" href=\"#索引\">#</a> 索引</h2>\n<p><strong>索引是最物美价廉的东西，不用加内存，不用改程序，不用调 SQL，查询速度就可能提高百倍千倍。但是会影响更新，删除和插入的效率，因为要更新搜索二叉树。</strong></p>\n<p>索引的类型：主键索引 (primary key)，唯一索引 (unique)，普通索引 (index)，全文索引 (fulltext)，但一般不使用全文索引，而是使用全文搜索 Solr 和 ElasticSearch。</p>\n<p>较频繁的作为查询条件字段应该创建索引，唯一性太差的和更新非常频繁字段不适合单独创建索引。</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 在emp表的empno列创建索引</span><br><span class=\"line\">create index empno_index on emp(empno)</span><br><span class=\"line\">alter table emp add index empno_index(empno)</span><br><span class=\"line\"># 查询表是否有索引</span><br><span class=\"line\">show index from t25</span><br><span class=\"line\"># 删除索引</span><br><span class=\"line\">drop index empno_index on t25</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"数据库备份\"><a class=\"markdownIt-Anchor\" href=\"#数据库备份\">#</a> 数据库备份</h2>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#备份数据库，将数据库保存到指定目录:mysqldump -u 用户名 -p -B 数据库1 数据库2 &gt; 文件名.sql</span><br><span class=\"line\">mysqldump -u root -p -B hsp_db02 hsp_db03 &gt; d:\\\\bak.sql</span><br><span class=\"line\">#备份数据库中指定的表:mysqldump -u 用户名 -p 数据库 表1 表2 &gt; 文件名.sql</span><br><span class=\"line\">mysqldump -u root -p hsp num1 num2 &gt; d:\\\\bak.sql</span><br><span class=\"line\">#恢复数据库，需要先进入MySQL命令行，输入mysql -u root -p</span><br><span class=\"line\">source d:\\\\bak.sql</span><br><span class=\"line\">#由于备份的数据库中含有所有操作，所有可以全部执行一遍来进行恢复</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"数据类型列类型\"><a class=\"markdownIt-Anchor\" href=\"#数据类型列类型\">#</a> 数据类型 (列类型)</h2>\n<p>数据默认是有符号的，添加 unsigned 关键字变为无符号。</p>\n<p>Decimal [M,D]，M 是小数位的总数，D 是小数点后面的位数。M 的最大值是 65，默认值是 10；D 的最大值为 30，默认值是 0。</p>\n<p>timestamp 时间戳可以指定 on update current_timestamp，这样每次更新时都会自动更新为当前时间。</p>\n<p>字符和日期型数据应包含在单引号中。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/11606/81bf2d9b3a518e97ccb968574b30080f.png\"\n                      alt=\"MySQL数据类型\"\n                ></p>\n<h2 id=\"char与varchar\"><a class=\"markdownIt-Anchor\" href=\"#char与varchar\">#</a> char 与 varchar</h2>\n<ol>\n<li><strong>char 最多可存储 255 个字符，varchar 最大可存储 65532 个字节，注意是字节，因此能最多能存储的字符取决于编码方式。但填入的参数都是指定字符数。</strong></li>\n<li>char 是定长，会固定占用声明的空间；varchar 是变长，存储实际占用的空间，但会使用一定长度的字节存储长度。</li>\n<li>char 的查询速度大于 varchar。</li>\n</ol>\n<h2 id=\"常用函数\"><a class=\"markdownIt-Anchor\" href=\"#常用函数\">#</a> 常用函数</h2>\n<h3 id=\"字符串\"><a class=\"markdownIt-Anchor\" href=\"#字符串\">#</a> 字符串</h3>\n<p>dual 是亚元表，系统表，可以作为一个测试表使用。</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>charset</td>\n<td>获取字符串所属字符集</td>\n</tr>\n<tr>\n<td>concat</td>\n<td>连接字符串，将多个列拼接成一列</td>\n</tr>\n<tr>\n<td>instr(string,substring)</td>\n<td>返回 substring 在 string 出现的位置，没有则返回 0</td>\n</tr>\n<tr>\n<td>ucase</td>\n<td>转换为大写</td>\n</tr>\n<tr>\n<td>lcase</td>\n<td>转换为小写</td>\n</tr>\n<tr>\n<td>left(string,length)</td>\n<td>从字符串的左边起取 length 个字符</td>\n</tr>\n<tr>\n<td>right(string,length)</td>\n<td>从字符串的右边起取 length 个字符</td>\n</tr>\n<tr>\n<td>length</td>\n<td>获取字符串长度 (字节)</td>\n</tr>\n<tr>\n<td>replace(str,search,replace)</td>\n<td>将 str 列中的 search 替换成 replace</td>\n</tr>\n<tr>\n<td>strcmp</td>\n<td>比较两个字符串大小</td>\n</tr>\n<tr>\n<td>substring(str,position,[,length])</td>\n<td>截取字符串，从 position 开始取 length 个字符，从 1 开始计数</td>\n</tr>\n<tr>\n<td>ltrim,rtrim,trim</td>\n<td>去除前端或后端空格</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数学\"><a class=\"markdownIt-Anchor\" href=\"#数学\">#</a> 数学</h3>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>abs</td>\n<td>返回绝对值</td>\n</tr>\n<tr>\n<td>bin</td>\n<td>十进制转二进制</td>\n</tr>\n<tr>\n<td>celling</td>\n<td>向上取整</td>\n</tr>\n<tr>\n<td>conv</td>\n<td>进制转换</td>\n</tr>\n<tr>\n<td>floor</td>\n<td>向下取整</td>\n</tr>\n<tr>\n<td>format</td>\n<td>保留小数位数，四舍五入</td>\n</tr>\n<tr>\n<td>hex</td>\n<td>转十六进制</td>\n</tr>\n<tr>\n<td>least</td>\n<td>求最小值</td>\n</tr>\n<tr>\n<td>mod</td>\n<td>求余</td>\n</tr>\n<tr>\n<td>rand</td>\n<td>返回随机数，范围为 [0,1]，可以填入 seed，生产对应的随机数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"时间日期\"><a class=\"markdownIt-Anchor\" href=\"#时间日期\">#</a> 时间日期</h3>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>current_date</td>\n<td>当前日期</td>\n</tr>\n<tr>\n<td>current_time</td>\n<td>当前时间</td>\n</tr>\n<tr>\n<td>current_timestamp</td>\n<td>当前时间戳</td>\n</tr>\n<tr>\n<td>date</td>\n<td>返回 datetime 的日期部分</td>\n</tr>\n<tr>\n<td>date_add(date,interval d_value d_type)</td>\n<td>在 date 中加上日期或时间</td>\n</tr>\n<tr>\n<td>date_sub(date,interval d_value d_type)</td>\n<td>在 date 上减去日期或时间</td>\n</tr>\n<tr>\n<td>datediff</td>\n<td>两个时间差，结果返回天数</td>\n</tr>\n<tr>\n<td>timediff</td>\n<td>两个时间差，返回多少小时多少分钟多少秒</td>\n</tr>\n<tr>\n<td>now</td>\n<td>当前时间</td>\n</tr>\n<tr>\n<td>year|month</td>\n<td>date(date)</td>\n</tr>\n<tr>\n<td>from_unixtime</td>\n<td>可以将 unix_timestamp 转换为指定格式的日期</td>\n</tr>\n<tr>\n<td>unix_timestamp</td>\n<td>返回从 1970-1-1 到现在的秒数</td>\n</tr>\n<tr>\n<td>last_day</td>\n<td>返回填入日期该月的最后一天</td>\n</tr>\n</tbody>\n</table>\n<p>date_add 和 date_sub 中的 interval 后面可以是 year,month,day,hour,second,minute</p>\n<h3 id=\"加密函数\"><a class=\"markdownIt-Anchor\" href=\"#加密函数\">#</a> 加密函数</h3>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>user</td>\n<td>查询登录到 mysql 的有哪些用户，已经登录的 IP</td>\n</tr>\n<tr>\n<td>database</td>\n<td>查询当前的数据库名称</td>\n</tr>\n<tr>\n<td>md5</td>\n<td>为字符串算出一个 MD5 的 32 位字符串，进行加密</td>\n</tr>\n<tr>\n<td>password</td>\n<td>加密函数，MySQL 数据库的用户密码函数使用该函数进行加密</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"流程控制函数\"><a class=\"markdownIt-Anchor\" href=\"#流程控制函数\">#</a> 流程控制函数</h3>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>if(expr1,expr2,expr3)</td>\n<td>然后 expr1 为 true，则返回 expr2，否则返回 expr3</td>\n</tr>\n<tr>\n<td>ifnull(expr1,expr2)</td>\n<td>如果 expr1 不为空，则返回 expr1，否则返回 expr2</td>\n</tr>\n<tr>\n<td>when a then b when c then d else e</td>\n<td>多分支选择</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"查询\"><a class=\"markdownIt-Anchor\" href=\"#查询\">#</a> 查询</h2>\n<p>在默认情况下，当两张表查询时，规则是从第一张表中取出一行和第二张表的每一行进行组合，返回结果。因此一共返回的记录数为两张表的行数之积，称为笛卡尔集。</p>\n<p><strong>自连接是指在同一张表的连接查询，将同一张表看做两张表，此时需要为该表起别名才能进行操作。</strong></p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from emp worker,emp boss; #分别取别名为worker和boss</span><br><span class=\"line\"># 多列子查询，查询和Allen的deptno和job完全一样的员工</span><br><span class=\"line\">select * from emp</span><br><span class=\"line\">where (deptno,job)=(select deptno,job from emp where ename=&#x27;allen&#x27;) and ename!=&#x27;allen&#x27;</span><br></pre></td></tr></table></figure></div>\n<p>子查询是指嵌入到其他 SQL 语句中的 select 语句，也叫嵌套查询。子查询还可以当做临时表使用。</p>\n<h2 id=\"约束\"><a class=\"markdownIt-Anchor\" href=\"#约束\">#</a> 约束</h2>\n<p>约束用于确保数据库的数据满足特定的商业规则，在 MySQL 中，约束包括：not null,unique,primary key,foreign key 和 check 五种。</p>\n<p>如果没有指定 not null，则 unique 字段可以有多个 null。</p>\n<p>外键 (foreign key) 用于定义主表和从表的之间的关系：主表约束要定义在从表上，主表则必须具有主键约束或者 unique 约束，要求外键列数据必须在主键列存在或者是为 null。</p>\n<p>表的类型必须是 InnoDB，这样的表才支持外键。</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">primary key(id,name)#复合主键</span><br><span class=\"line\">#指定外键关系</span><br><span class=\"line\">foreign key (class_id) references my_class(id)</span><br></pre></td></tr></table></figure></div>\n<p>check 用于强制行数据必须满足的条件。Oracle 和 SQL server 均支持 check，但是 MySQL5.7 目前还不支持 check，只做语法校验，但不会生效。在 MySQL 中实现 check 的功能，一般是在程序中控制或者通过触发器完成。</p>\n<h2 id=\"事务\"><a class=\"markdownIt-Anchor\" href=\"#事务\">#</a> 事务</h2>\n<p>当执行回退事务时，通过指定保存点可以回退到指定的点。</p>\n<p>提交事务后会确认事务的变化，结束事务，删除保存点，释放锁，数据生效。当使用 commit 语句结束事务后，其他会话将可以查看到事务变化后的新数据。</p>\n<p>如果不开启事务，在默认情况下，操作是自动提交的，不能回滚。</p>\n<p>InnoDB 存储引擎支持事务，MyISAM 不支持。</p>\n<p><strong>事务的特性：原子性、一致性、隔离性和持久性。</strong></p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 开始事务，也可以写set autocommit=off</span><br><span class=\"line\">start transaction</span><br><span class=\"line\"># 设置保存点</span><br><span class=\"line\">savepoint a</span><br><span class=\"line\">savepoint b</span><br><span class=\"line\"># 回退到a保存点,此时就无法再回退到b点，只写rollback的话直接回退到事务开始的状态</span><br><span class=\"line\">rollback to a</span><br><span class=\"line\"># 提交操作，此时不可以回退</span><br><span class=\"line\">commit</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"事务隔离\"><a class=\"markdownIt-Anchor\" href=\"#事务隔离\">#</a> 事务隔离</h3>\n<p>多个连接开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个连接在获取数据时的准确性。如果不考虑隔离性，可能会导致：脏读、不可重复读、幻读。</p>\n<p>脏读：当一个事务读取到另一个事务<strong>尚未提交</strong>的修改时，产生脏读。</p>\n<p>不可重复读：同一查询在同一事务中多次进行，由于其他提交事务所做的<strong>修改或删除</strong>，每次返回不同的结果集，产生不可重复读。</p>\n<p>幻读：同一查询在同一事务中多次出现，由于其他提交事务所做的<strong>插入</strong>操作，每次返回不同的结果集，产生幻读。</p>\n<p><strong>我希望看到的数据是我连接到数据库时的数据，而不可重复读和幻读影响了我能看到的数据，不同事务之间正常来说应该不会互相影响。</strong></p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看当前MySQL的隔离级别</span><br><span class=\"line\">select @@tx_isolation;</span><br><span class=\"line\"># 查看系统当前隔离级别</span><br><span class=\"line\">select @@global.tx_isolation</span><br><span class=\"line\"># 设置控制台的隔离级别</span><br><span class=\"line\">set session transaction isolation level read uncommitted</span><br><span class=\"line\"># 设置系统的隔离级别</span><br><span class=\"line\">set global transaction isolation level read uncommitted</span><br></pre></td></tr></table></figure></div>\n<h4 id=\"隔离级别\"><a class=\"markdownIt-Anchor\" href=\"#隔离级别\">#</a> 隔离级别</h4>\n<p>MySQL 默认的隔离级别是 repeated read，一般情况下，没有特殊要求就没有必要修改。若要修改，可以在 my.ini 文件中写入 transaction-isolation = 想要的隔离级别</p>\n<table>\n<thead>\n<tr>\n<th>MySQL 隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n<th>加锁读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读未提交 (Read uncommitted)</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>不加锁</td>\n</tr>\n<tr>\n<td>读已提交 (Read committed)</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n<td>不加锁</td>\n</tr>\n<tr>\n<td>可重复读 (Repeatable read)</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n<td>不加锁</td>\n</tr>\n<tr>\n<td>可串行化 (Serializable)</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n<td>加锁</td>\n</tr>\n</tbody>\n</table>\n<p>√表示可能出现，× 表示不会出现；加锁后需要其他事务均已提交才能运行。</p>\n<h2 id=\"存储引擎\"><a class=\"markdownIt-Anchor\" href=\"#存储引擎\">#</a> 存储引擎</h2>\n<p>MySQL 的表类型由存储引擎决定，主要包括 Myisam、innoDB、Memory 等。</p>\n<p>MySQL 数据表主要支持六种类型，分别是：CSV、Memory、Archive、Mge_Myisam、Myisam 和 InnoDB，这六种又分为两类，一类为事务安全型，例如 InnoDB；其余为非事务安全型，例如 MyISAM 和 Memory。</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看所有的存储引擎</span><br><span class=\"line\">show engines</span><br><span class=\"line\"># 修改存储引擎</span><br><span class=\"line\">alter table &#x27;tb01&#x27; engine = innodb;</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"常用引擎比较\"><a class=\"markdownIt-Anchor\" href=\"#常用引擎比较\">#</a> 常用引擎比较</h3>\n<p>Myisam 不支持事务也不支持外键，但其访问速度快，对事务完整性没有要求。</p>\n<p>InnoDB 提供了具有提交、回滚和崩溃恢复能力的事物安全。但是比起 Myisam，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</p>\n<p>Memory 使用存储在内存中的内容来创建表。每个 Memory 表只实际对应一个磁盘文件，Memory 类型的表访问非常快，因为它的数据是放在内存的，而且默认使用 hash 索引，但是一旦 MySQL 服务关闭，表中的数据就会丢失掉，表的结构还在。</p>\n<table>\n<thead>\n<tr>\n<th>特点</th>\n<th>Myisam</th>\n<th>InnoDB</th>\n<th>Memory</th>\n<th>Archive</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>批量插入的速度</td>\n<td>高</td>\n<td>低</td>\n<td>高，内存级别</td>\n<td>非常高</td>\n</tr>\n<tr>\n<td colspan=\"2\">事务安全</td>\n<td colspan=\"3\">支持</td>\n</tr>\n<tr>\n<td>全文索引</td>\n<td colspan=\"4\">支持</td>\n</tr>\n<tr>\n<td>锁机制</td>\n<td>表级</td>\n<td>行锁</td>\n<td>表锁</td>\n<td>行锁</td>\n</tr>\n<tr>\n<td>存储限制</td>\n<td>没有</td>\n<td>64TB</td>\n<td>有</td>\n<td>没有</td>\n</tr>\n<tr>\n<td>B 树索引</td>\n<td>支持</td>\n<td>支持</td>\n<td colspan=\"2\">支持</td>\n</tr>\n<tr>\n<td colspan=\"2\">哈希索引</td>\n<td>支持</td>\n<td colspan=\"2\">支持</td>\n</tr>\n<tr>\n<td colspan=\"2\">集群索引</td>\n<td colspan=\"3\">支持</td>\n</tr>\n<tr>\n<td colspan=\"2\">数据缓存</td>\n<td>支持</td>\n<td colspan=\"2\">支持</td>\n</tr>\n<tr>\n<td>索引缓存</td>\n<td>支持</td>\n<td>支持</td>\n<td colspan=\"2\">支持</td>\n</tr>\n<tr>\n<td>数据可压缩</td>\n<td colspan=\"3\">支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>空间使用</td>\n<td>低</td>\n<td colspan=\"2\">高</td>\n<td>非常低</td>\n</tr>\n<tr>\n<td>内存使用</td>\n<td>低</td>\n<td>高</td>\n<td>中等</td>\n<td>低</td>\n</tr>\n<tr>\n<td colspan=\"2\">支持外键</td>\n<td colspan=\"3\">支持</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"视图\"><a class=\"markdownIt-Anchor\" href=\"#视图\">#</a> 视图</h2>\n<p>视图是一个虚拟表，其内容由查询定义，其数据来自于对应的真实表 (基表)。创建视图后到数据库去看，对应视图只有一个视图结构文件，而没有数据文件。</p>\n<p>视图的数据变化会影响到基表，基表的数据变化也会影响视图。</p>\n<p>视图中仍可以生成视图。</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建视图emp_view01，只能查询emp表的empno、ename、job和deptno信息</span><br><span class=\"line\">create view emp_view as select empno,ename,job,deptno from emp;</span><br><span class=\"line\"># 查看视图</span><br><span class=\"line\">select empno,job from emp_view</span><br><span class=\"line\"># 查看创建视图的指令</span><br><span class=\"line\">show create view emp_view01</span><br><span class=\"line\"># 删除视图</span><br><span class=\"line\">drop view emp_view01</span><br></pre></td></tr></table></figure></div>\n<h1 id=\"第二十章-jdbc和连接池\"><a class=\"markdownIt-Anchor\" href=\"#第二十章-jdbc和连接池\">#</a> 第二十章 jdbc 和连接池</h1>\n<p>jdbc 为访问不同的数据库提供了统一的接口，为使用者屏蔽了细节问题。java 程序员使用 jdbc，可以连接任何提供了 jdbc 驱动程序的数据库系统，从而完成对数据库的各种操作。</p>\n<p>jdbc 的 API 是一系列的接口，它统一和规范了应用程序和数据库的连接、执行 SQL 语句，并得到返回结果等各类操作，相关类和接口在 java.sql 和 javax.sql 包中。</p>\n<p>jdbc 程序编写步骤：注册驱动，加载 Driver 类；获取连接，得到 Connection；执行增删改查，发生 SQL 给数据库执行；释放资源，关闭相关连接。</p>\n<p><strong>mysql 的连接本质上是 socket 连接。</strong></p>\n<p><strong>jdbc 连接 MySQL 时，如果要使用批处理功能，需要在 URL 中加参数 <code>?rewriteBatchedStatements=true</code> 。</strong></p>\n<p>批处理往往和 PreparedStatement 一起搭配使用，既可以减少编译次数，又减少运行次数，效率大大提高。</p>\n<p>遇到异常时，可以使用 <code>throw new RuntimeException(e);</code>  将其转换为运行异常。</p>\n<p><strong>新建 Propertises 文件时选择文件类型为 Text 即可。</strong></p>\n<p>BasicDao 是专门和数据库交互的，即完成对数据库的 crud 操作。在 BasicDao 的基础上，实现一张表对应一个 Dao，更好的完成功能，比如 Customer 表 - Customer.java 类 - CustomerDao.java。</p>\n<p>声明使用可变参数可以使用省略号，例如 <code>Object... parameters</code> 。</p>\n<p><strong>idea 注释中的作者和版本信息都会对程序运行有影响。</strong></p>\n<p>进行多表查询时，增加来自另一张表的属性需要和原来表的属性名保持一致，因为底层会通过列名来调用 set 方法进行赋值，或者在 SQL 语句中通过取别名的方法解决。</p>\n<h2 id=\"preparedstatement\"><a class=\"markdownIt-Anchor\" href=\"#preparedstatement\">#</a> PreparedStatement</h2>\n<p>使用 PreparedStatement 进行预处理可以解决 Statement 的 SQL 注入问题。PreparedStatement 不再使用加号拼接 SQL 语句，而是使用占位符和 set 方法，有效解决了 SQL 注入问题。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;select name from class where name = ? and pwd = ?&quot;</span>;<span class=\"comment\">//？作为占位符</span></span><br><span class=\"line\"><span class=\"type\">PreparedStatement</span> <span class=\"variable\">preparedStatement</span> <span class=\"operator\">=</span> connection.preparedStatement(sql);</span><br><span class=\"line\">preparedStatement.setString(<span class=\"number\">1</span>,admin_name);<span class=\"comment\">//给第一个？号处填入值</span></span><br><span class=\"line\"><span class=\"comment\">//由于前面已经填了，此处不需要再填入sql</span></span><br><span class=\"line\"><span class=\"type\">ResultSet</span> <span class=\"variable\">resultSet</span> <span class=\"operator\">=</span> preparedStatement.executeQuery();</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"resultset\"><a class=\"markdownIt-Anchor\" href=\"#resultset\">#</a> ResultSet</h2>\n<p>ResultSet 表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。ResultSet 对象保存一个光标指向其当前的数据行，光标在最初位于第一行之前，next 方法可以将光标移动到下一行，当对象没有更多行时会返回 false，因此可以使用 while 循环进行遍历。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;select * from class&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//执行SQL语句，返回单个的ResultSet对象</span></span><br><span class=\"line\"><span class=\"type\">ResultSet</span> <span class=\"variable\">resultSet</span> <span class=\"operator\">=</span> statement.executeQuery(sql);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (resultSet.next()) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> resultSet.getInt(<span class=\"number\">1</span>);<span class=\"comment\">//获取第一列的数据</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> resultSet.getNString(<span class=\"number\">2</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;id是&quot;</span> + id + <span class=\"string\">&quot;;班级是&quot;</span> + name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//4.关闭连接</span></span><br><span class=\"line\">resultSet.close();</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"jdbc操作数据库\"><a class=\"markdownIt-Anchor\" href=\"#jdbc操作数据库\">#</a> jdbc 操作数据库</h2>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//首先将jar文件加入到项目中，并右键选择“添加到库”</span></span><br><span class=\"line\"><span class=\"comment\">//1.注册驱动</span></span><br><span class=\"line\"><span class=\"type\">Driver</span> <span class=\"variable\">driver</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Driver</span>();</span><br><span class=\"line\"><span class=\"comment\">//2.得到连接，表示通过jdbc的方式连接mysql，localhost表示主机，可以使用ip地址，</span></span><br><span class=\"line\"><span class=\"comment\">//3306是监听的端口，day27db是连接的数据库，高版本的mysql包需要写上?serverTimezone=UTC</span></span><br><span class=\"line\"><span class=\"comment\">//mysql的连接本质上是socket连接</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;jdbc:mysql://localhost:3306/day27db?serverTimezone=UTC&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//将用户名和密码放入到Properties对象中</span></span><br><span class=\"line\"><span class=\"type\">Properties</span> <span class=\"variable\">properties</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\"><span class=\"comment\">//user和password是规定好的，后面的值根据实际情况填写</span></span><br><span class=\"line\">properties.setProperty(<span class=\"string\">&quot;user&quot;</span>, <span class=\"string\">&quot;root&quot;</span>);<span class=\"comment\">//用户</span></span><br><span class=\"line\">properties.setProperty(<span class=\"string\">&quot;password&quot;</span>, <span class=\"string\">&quot;hsp&quot;</span>);<span class=\"comment\">//密码</span></span><br><span class=\"line\"><span class=\"type\">Connection</span> <span class=\"variable\">connect</span> <span class=\"operator\">=</span> driver.connect(url, properties);</span><br><span class=\"line\"><span class=\"comment\">//3.执行SQL语句</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;insert into class values(null,&#x27;数学&#x27;)&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//用于执行静态SQL语句并返回其生成的结果的对象</span></span><br><span class=\"line\"><span class=\"type\">Statement</span> <span class=\"variable\">statement</span> <span class=\"operator\">=</span> connect.createStatement();</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">row</span> <span class=\"operator\">=</span> statement.executeUpdate(sql);<span class=\"comment\">//如果是dml语句，返回影响的行数</span></span><br><span class=\"line\">System.out.println(row &gt; <span class=\"number\">0</span> ? <span class=\"string\">&quot;成功&quot;</span> : <span class=\"string\">&quot;失败&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//4.关闭连接</span></span><br><span class=\"line\">statement.close();</span><br><span class=\"line\">connect.close();</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"连接方式\"><a class=\"markdownIt-Anchor\" href=\"#连接方式\">#</a> 连接方式</h2>\n<p>MySQL 驱动在 5.1.6 之后可以无需 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 。从 jdk1.5 以后使用了 jdbc4，不需要显式调用该方法注册驱动，而是自动调用驱动 jar 包下 META-INF\\services\\java.sql.Driver 文本中的类名去注册。</p>\n<p>本质上只有两种连接方式：静态加载和动态加载。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式1，创建Driver对象，静态加载</span></span><br><span class=\"line\"><span class=\"type\">Driver</span> <span class=\"variable\">driver</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Driver</span>();</span><br><span class=\"line\"><span class=\"comment\">//方式2，使用反射加载Driver类，动态加载，更加灵活，减少依赖性</span></span><br><span class=\"line\">Class&lt;?&gt; aClass = Class.forName(<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Driver</span> <span class=\"variable\">driver</span> <span class=\"operator\">=</span> (Driver)aClass.newInstance();</span><br><span class=\"line\"><span class=\"comment\">//方式3，使用DriverManager替代Driver进行统一管理</span></span><br><span class=\"line\"><span class=\"comment\">//先获取Driver对象，然后传入URL，用户名和密码</span></span><br><span class=\"line\">DriverManager.registerDriver(driver);<span class=\"comment\">//注册Driver驱动</span></span><br><span class=\"line\"><span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> DriverManage.getConnection(url,user,password);</span><br><span class=\"line\"><span class=\"comment\">//方式4，如果使用了Class.forName方法则会自动完成注册驱动，可以省略registerDriver的步骤，这是最推荐使用的</span></span><br><span class=\"line\"><span class=\"comment\">//方式5则是在方式4上进行改进，使用配置文件</span></span><br><span class=\"line\"><span class=\"type\">Properties</span> <span class=\"variable\">properties</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">properties.load(<span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;src\\\\mysql.propertises&quot;</span>));</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> properties.getProperty(<span class=\"string\">&quot;user&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">password</span> <span class=\"operator\">=</span> properties.getProperty(<span class=\"string\">&quot;password&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> properties.getProperty(<span class=\"string\">&quot;url&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">driver</span> <span class=\"operator\">=</span> properties.getProperty(<span class=\"string\">&quot;driver&quot;</span>);</span><br><span class=\"line\">Class.forName(driver);</span><br><span class=\"line\"><span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> DriverManager.getConnection(url, user, password);</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"常用api\"><a class=\"markdownIt-Anchor\" href=\"#常用api\">#</a> 常用 API</h2>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/11606/ff73ede308799b2baad8f194c544c270.png\"\n                      alt=\"常用API\"\n                ></p>\n<h2 id=\"数据库连接池\"><a class=\"markdownIt-Anchor\" href=\"#数据库连接池\">#</a> 数据库连接池</h2>\n<p>传统的 jdbc 数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证 IP 地址，用户名和密码。需要数据库连接的时候，就向数据库要求一个，频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃。</p>\n<p>每一次数据库连接，使用完后都得断开，如果程序出现异常而未能关闭，将导致数据库内存泄露，最终导致重启数据库。为解决传统开发中的数据库连接问题，可以采用 数据库连接池技术。</p>\n<p><strong>数据库连接池预先在缓冲区放入一定数量的连接，当需要建立数据库连接时，只需从 “缓冲池” 中取出一个，使用完毕后放回去。连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立。</strong></p>\n<h3 id=\"常见连接池\"><a class=\"markdownIt-Anchor\" href=\"#常见连接池\">#</a> 常见连接池</h3>\n<p>jdbc 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口由第三方提供实现。</p>\n<table>\n<thead>\n<tr>\n<th>连接池</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>C3P0</td>\n<td>速度相对较慢，稳定性不错，hibernate 和 spring 使用</td>\n</tr>\n<tr>\n<td>DBCP</td>\n<td>速度相对 C3P0 较快，但不稳定</td>\n</tr>\n<tr>\n<td>Proxool</td>\n<td>有监控连接池状态的功能，稳定性较 C3P0 差一点</td>\n</tr>\n<tr>\n<td>BoneCP</td>\n<td>速度快</td>\n</tr>\n<tr>\n<td>Druid (德鲁伊)</td>\n<td>来自阿里，集上面的优点于一身</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"连接池使用\"><a class=\"markdownIt-Anchor\" href=\"#连接池使用\">#</a> 连接池使用</h3>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将c3p0提供的c3o0.config.xml拷贝到src目录下，该文件指定了数据库和连接池的相关参数</span></span><br><span class=\"line\"><span class=\"type\">ComboPooledDataSource</span> <span class=\"variable\">comboPooledDataSource</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ComboPooledDataSource</span>(<span class=\"string\">&quot;hsp_edu&quot;</span>);<span class=\"comment\">//填入数据源名称</span></span><br><span class=\"line\"><span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> comboPooledDataSource.getConnection();</span><br><span class=\"line\">connection.close();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1.加入Druid的jar包和配置文件druid.properties，将该文件拷贝到项目的src目录</span></span><br><span class=\"line\"><span class=\"comment\">//2.创建Properties对象，读取配置文件</span></span><br><span class=\"line\"><span class=\"type\">Properties</span> <span class=\"variable\">properties</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">properties.load(<span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;src\\\\druid.properties&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">//3.创建一个指定参数的数据库连接池</span></span><br><span class=\"line\"><span class=\"type\">DataSource</span> <span class=\"variable\">dataSource</span> <span class=\"operator\">=</span> DruidDataSourceFactory.createDataSource(properties);</span><br><span class=\"line\"><span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> dataSource.getConnection();</span><br><span class=\"line\">connection.close();</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"dbutils\"><a class=\"markdownIt-Anchor\" href=\"#dbutils\">#</a> DBUtils</h2>\n<p><strong>关闭 connection 后，resultSet 结果集无法使用，而且 resultSet 不利于数据的管理。</strong></p>\n<p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC 工具类库，它是对 JDBC 的封装，使用 dbutils 能极大简化 jdbc 编程的工作量。</p>\n<p>QueryRunner 类：封装了 SQL 的执行，是线程安全的。可以实现增、删、改、查、批处理。</p>\n<p>ResultSetHandler 接口：用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p>\n<p>一定要给 java 类一个无参构造器，可能反射会需要。</p>\n<p>int,double 等在 java 中都使用包装类，因为 mysql 中所有类型都可能是 null，而只有 java 是引用类型才有 null 值。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//DBUtils使用</span></span><br><span class=\"line\"><span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> JDBCUtilsByDruid.getConnection();</span><br><span class=\"line\"><span class=\"type\">QueryRunner</span> <span class=\"variable\">queryRunner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">QueryRunner</span>();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;select * from course where cid &gt;= ?&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//new BeanListHandler&lt;&gt;(Actor.class):将resultSet-&gt;Actor对象-&gt;封装到ArrayList，底层会使用反射机制</span></span><br><span class=\"line\"><span class=\"comment\">//参数1是填入到SQL中的问号</span></span><br><span class=\"line\"><span class=\"comment\">//底层得到的resultSet和PreparedStatement会在query方法中关闭</span></span><br><span class=\"line\"> List&lt;Actor&gt; list = queryRunner.query(connection, sql, <span class=\"keyword\">new</span> <span class=\"title class_\">BeanListHandler</span>&lt;&gt;(Actor.class), <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Actor actor : list) &#123;</span><br><span class=\"line\">    System.out.println(actor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">JDBCUtilsByDruid.close(<span class=\"literal\">null</span>,<span class=\"literal\">null</span>,connection);<span class=\"comment\">//释放资源</span></span><br></pre></td></tr></table></figure></div>\n<h3 id=\"常用函数-2\"><a class=\"markdownIt-Anchor\" href=\"#常用函数-2\">#</a> 常用函数</h3>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ArrayHandler</td>\n<td>将结果集中的第一行数据转成对象数组</td>\n</tr>\n<tr>\n<td>ArrayListHandler</td>\n<td>将结果集中的每一行数据都转成一个数组，再存放到 List 中</td>\n</tr>\n<tr>\n<td>BeanHandler</td>\n<td>将结果集中的第一行数据封装到一个对应的 javaBean 实例中</td>\n</tr>\n<tr>\n<td>BeanListHandler</td>\n<td>将结果集中的每一行都封装到一个对应的 javaBean 实例中，存放到 List 中</td>\n</tr>\n<tr>\n<td>ColumnListHandler</td>\n<td>将结果集中某一列的数据存放到 List 中</td>\n</tr>\n<tr>\n<td>KeyedHandler(name)</td>\n<td>将结果集中每行的数据都封装到 Map 里，再把这些 map 存到另一个 Map 里，其 key 为指定的 key</td>\n</tr>\n<tr>\n<td>MapHandler</td>\n<td>将结果集中第一行的数据都封装到 Map 里，key 是列名，value 是对应的值</td>\n</tr>\n<tr>\n<td>MapListHandler</td>\n<td>将结果集中每行的数据都封装到 Map 里，然后存放到 List</td>\n</tr>\n<tr>\n<td>ScalarHandler</td>\n<td>返回单行单列，一个 object 对象</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"第二十一章-正则表达式\"><a class=\"markdownIt-Anchor\" href=\"#第二十一章-正则表达式\">#</a> 第二十一章 正则表达式</h1>\n<p>** 在 java 的正则表达式中，两个 <code>\\\\</code>  代表其他语言中的一个 \\。** 而需要用到转义字符的有： <code>.*()$/\\?[]^&#123;&#125;</code> 。</p>\n<p><strong>正则表达式可以使用括号进行分组，group (0) 表示匹配到的字符串，group (n) 表示返回对应的分组。</strong></p>\n<p>java 匹配默认贪婪匹配，即尽可能多的匹配。</p>\n<p>分组的内容被捕获后，可以在这个括号后被使用，从而写出比较实用的匹配模式，这个被称作反向引用。这种引用可以在正则表达式内部，也可以是外部，内部反向引用使用 \\\\ 分组号，外部引用使用 $ 分组号。</p>\n<p>字符串配合正则表达式使用 replaceAll、matches 和 split 方法可以提高效率。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//先创建一个Pattern对象，模式对象，可以理解为就是一个正则表达式对象</span></span><br><span class=\"line\"><span class=\"type\">Pattern</span> <span class=\"variable\">pattern</span> <span class=\"operator\">=</span> Pattern.compile(<span class=\"string\">&quot;[a-zA-Z+]&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//创建一个匹配器对象</span></span><br><span class=\"line\"><span class=\"type\">Matcher</span> <span class=\"variable\">matcher</span> <span class=\"operator\">=</span> pattern.matcher(content);<span class=\"comment\">//content是需要匹配的文本</span></span><br><span class=\"line\"><span class=\"comment\">//开始循环匹配</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(matcher.find())&#123;</span><br><span class=\"line\">  <span class=\"comment\">//匹配内容和文本会放在matcher.group()</span></span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;找到&quot;</span> + matcher.group(<span class=\"number\">0</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//捕获命名分组，(?&lt;name&gt;pattern)</span></span><br><span class=\"line\"><span class=\"type\">Pattern</span> <span class=\"variable\">pattern</span> <span class=\"operator\">=</span> Pattern.compile(<span class=\"string\">&quot;?(&lt;name1&gt;\\\\d\\\\d)(?&lt;name2&gt;\\\\d\\\\d)&quot;</span>);</span><br><span class=\"line\">matcher.group(<span class=\"string\">&quot;name1&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//应用实例</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">regStr</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;^[\\u0391-\\uffe5]+$&quot;</span>;<span class=\"comment\">//匹配汉字</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">matches</span> <span class=\"operator\">=</span> Pattern.matches(regStr,content);<span class=\"comment\">//调用静态方法进行整体匹配，而不是其中一部分</span></span><br><span class=\"line\"><span class=\"comment\">//匹配五个连续相同的数字，相当于&quot;(//d)//1//1///1//1&quot;，意思是后面的元素与第一分组的内容相同</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">regStr</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;(\\\\d)\\\\1&#123;4&#125;&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//匹配四位长度的回文数字,意思是先与第2分组相同，再与第1分组相同</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">regStr</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;(\\\\d)(\\\\d)\\\\2\\\\1&quot;</span>;</span><br><span class=\"line\">content = matcher.replaceAll(<span class=\"string\">&quot;$1&quot;</span>);<span class=\"comment\">//反向引用使用第1分组的内容进行替换</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"字符串匹配符\"><a class=\"markdownIt-Anchor\" href=\"#字符串匹配符\">#</a> 字符串匹配符</h2>\n<p><a class=\"link\"   href=\"https://www.runoob.com/java/java-regular-expressions.html\" >菜鸟教程字符串匹配符 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>含义</th>\n<th>示例</th>\n<th>说明</th>\n<th>匹配输入</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.</td>\n<td>匹配处 \\n 以外的任意字符</td>\n<td>a…b</td>\n<td>以 a 开头，b 结尾，中间包括两个任意字符为 4 的字符串</td>\n<td>aaab,a35b</td>\n</tr>\n<tr>\n<td>[]</td>\n<td>可接收的字符列表，特殊符号将按照本身进行匹配</td>\n<td>[efg?.]</td>\n<td>e,f,g,? 和。中的任意一个字符</td>\n<td>.,?,e</td>\n</tr>\n<tr>\n<td>[^]</td>\n<td>不接收的字符列表</td>\n<td>[^efg]</td>\n<td>除 e,f,g 的任意一个字符</td>\n<td>a</td>\n</tr>\n<tr>\n<td>-</td>\n<td>连字符</td>\n<td>A-Z</td>\n<td>任意大写字母</td>\n<td>A</td>\n</tr>\n<tr>\n<td>|</td>\n<td>选择匹配符，匹配’|' 之前或之后的表达式</td>\n<td>ab|cd</td>\n<td>ab 或 cd</td>\n<td>ab</td>\n</tr>\n<tr>\n<td>*</td>\n<td>指定字符重复 0 次或 n 次</td>\n<td>(abc)*</td>\n<td>仅包含任意个 abc 的字符串，等效于 \\w*</td>\n<td>abcabc</td>\n</tr>\n<tr>\n<td>+</td>\n<td>指定字符重复 1 次或 n 次</td>\n<td>m+(abc)*</td>\n<td>以至少一个 m 开头，后接任意个 abc 的字符串</td>\n<td>m</td>\n</tr>\n<tr>\n<td>?</td>\n<td>指定字符重复 0 次或 1 次，当此字符紧随其他限定符 (*,+,?,{n},{n,},{n,m}) 之后，则表示采用非贪婪匹配</td>\n<td>m+abc？</td>\n<td>以至少一个 m 开头，后接 ab 或 abc 的字符串</td>\n<td>mab</td>\n</tr>\n<tr>\n<td>^</td>\n<td>指定起始字符</td>\n<td><sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>+[a-z]*</td>\n<td>以至少一个数字开头，后接任意个小写字母的字符串</td>\n<td>123dsd，而 a123dsd 就不能匹配</td>\n</tr>\n<tr>\n<td>$</td>\n<td>指定结束字符</td>\n<td><sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>\\-[a-z]+$</td>\n<td>以 1 个数字开头后接连字符‘-’，并以至少一个小写字母结尾的字符串</td>\n<td>1-a</td>\n</tr>\n<tr>\n<td n=\"\"></td>\n<td>接收 n 个字符</td>\n<td><span 3=\"\">abcd</span></td>\n<td>由 abcd 中字母组成的任意长度为 3 的字符串</td>\n<td>abc</td>\n</tr>\n<tr>\n<td n,=\"\"></td>\n<td>指定至少 n 个匹配</td>\n<td><span 3,=\"\">abcd</span></td>\n<td>由 abcd 中字母组成的任意长度不小于 3 的字符串</td>\n<td>abaaaaa</td>\n</tr>\n<tr>\n<td n,m=\"\"></td>\n<td>指定至少 n 个但不多于 m 个匹配</td>\n<td><span 3,5=\"\">abcd</span></td>\n<td>由 abcd 中字母组成的任意长度不小于 3，不大于 5 的字符串</td>\n<td>aaaa</td>\n</tr>\n<tr>\n<td>\\\\d</td>\n<td>匹配单个数字字符，相当于 [0-9]</td>\n<td>\\\\d{3}(\\\\d)?</td>\n<td>包含 3 个或 4 个数字的字符串</td>\n<td>123，7895</td>\n</tr>\n<tr>\n<td>\\\\D</td>\n<td>匹配单个非数字字符，相当于 [^0-9]</td>\n<td>\\\\D(\\\\d)*</td>\n<td>以单个非数字字符开头，后接任意个数字字符</td>\n<td>a，A345</td>\n</tr>\n<tr>\n<td>\\\\w</td>\n<td>匹配单个数字、大小写字母字符，相当于 [0-9a-zA-Z]</td>\n<td 4=\"\">\\\\d{3}\\\\w</td>\n<td>以 3 个数字字符开头的长度为 7 的数字字母字符串</td>\n<td>234abcd</td>\n</tr>\n<tr>\n<td>\\\\W</td>\n<td>匹配单个非数字、大小写字母字符，相当于 [^0-9a-zA-Z]</td>\n<td 2=\"\">\\\\W+\\\\d</td>\n<td>以至少一个非数字字母字符开头，2 个数字字符结尾的字符串</td>\n<td>#29</td>\n</tr>\n<tr>\n<td>\\\\s</td>\n<td>匹配任意空白字符 (空格、制表符等)</td>\n<td>\\\\s</td>\n<td>任意空白字符</td>\n<td>一个空格</td>\n</tr>\n<tr>\n<td>\\\\S</td>\n<td>匹配任意非空白字符</td>\n<td>\\\\S</td>\n<td>任意非空白字符</td>\n<td>A</td>\n</tr>\n<tr>\n<td>\\\\b</td>\n<td>匹配目标字符串的边界</td>\n<td>han\\\\b</td>\n<td>字符串的边界指的是子串之间有空格，或者是目标字符串的结束位置</td>\n<td>hanshun<strong>han</strong> nn <strong>han</strong></td>\n</tr>\n<tr>\n<td>\\\\B</td>\n<td>匹配目标字符串的非边界</td>\n<td>han\\\\B</td>\n<td>与 \\\\b 的含义相反，匹配北边界的 han</td>\n<td><strong>han</strong>shunhan nnhan</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"大小写区分\"><a class=\"markdownIt-Anchor\" href=\"#大小写区分\">#</a> 大小写区分</h3>\n<p>java 正则表达式默认区分字母大小写，如何实现不区分大小写。</p>\n<ul>\n<li>(?i) abc 表示都不区分大小写</li>\n<li>a (?i) abc 表示 bc 不区分大小写</li>\n<li>a ((?i) b) c 表示只有 b 不区分大小写</li>\n<li>Pattern pat = Pattern.compile(regEx,Pattern.CASE_INSENSITIVE);</li>\n</ul>\n<h2 id=\"非捕获分组\"><a class=\"markdownIt-Anchor\" href=\"#非捕获分组\">#</a> 非捕获分组</h2>\n<p>非捕获分组的意思是只是进行了匹配，并没有获取该分组子表达式的值，即不能通过 group (n) 等获取该分组的值。</p>\n<table>\n<thead>\n<tr>\n<th>构造形式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>(?:pattern)</td>\n<td>匹配 pattern 但不捕获该匹配式的子表达式，不存储供以后使用的匹配。该形式对于用 &quot;or&quot; 字符 (|) 组合模式部件的情况很有用，例如” 韩顺平 (?: 学习</td>\n</tr>\n<tr>\n<td>(?=pattern)</td>\n<td>&quot;Windows(?=95|98</td>\n</tr>\n<tr>\n<td>(?!pattern)</td>\n<td>和第二个模式取反，该模式不匹配括号内的字符。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"matcher类\"><a class=\"markdownIt-Anchor\" href=\"#matcher类\">#</a> Matcher 类</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>matches</td>\n<td>整体匹配，返回一个布尔值</td>\n</tr>\n<tr>\n<td>start</td>\n<td>返回匹配的开始索引</td>\n</tr>\n<tr>\n<td>end</td>\n<td>返回匹配的结束索引，对应位置的后一位</td>\n</tr>\n<tr>\n<td>replaceAll(oldStr)</td>\n<td>返回一个替换后的结果</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"常用正则表达式\"><a class=\"markdownIt-Anchor\" href=\"#常用正则表达式\">#</a> 常用正则表达式</h2>\n<h3 id=\"校验数字\"><a class=\"markdownIt-Anchor\" href=\"#校验数字\">#</a> 校验数字</h3>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> 数字：^[<span class=\"number\">0</span>-<span class=\"number\">9</span>]*$</span><br><span class=\"line\"><span class=\"number\">2</span> n位的数字：^\\d&#123;n&#125;$</span><br><span class=\"line\"><span class=\"number\">3</span> 至少n位的数字：^\\d&#123;n,&#125;$</span><br><span class=\"line\"><span class=\"number\">4</span> m-n位的数字：^\\d&#123;m,n&#125;$</span><br><span class=\"line\"><span class=\"number\">5</span> 零和非零开头的数字：^(<span class=\"number\">0</span>|[<span class=\"number\">1</span>-<span class=\"number\">9</span>][<span class=\"number\">0</span>-<span class=\"number\">9</span>]*)$</span><br><span class=\"line\"><span class=\"number\">6</span> 非零开头的最多带两位小数的数字：^([<span class=\"number\">1</span>-<span class=\"number\">9</span>][<span class=\"number\">0</span>-<span class=\"number\">9</span>]*)+(.[<span class=\"number\">0</span>-<span class=\"number\">9</span>]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;)?$</span><br><span class=\"line\"><span class=\"number\">7</span> 带<span class=\"number\">1</span>-<span class=\"number\">2</span>位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;)?$</span><br><span class=\"line\"><span class=\"number\">8</span> 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$</span><br><span class=\"line\"><span class=\"number\">9</span> 有两位小数的正实数：^[<span class=\"number\">0</span>-<span class=\"number\">9</span>]+(.[<span class=\"number\">0</span>-<span class=\"number\">9</span>]&#123;<span class=\"number\">2</span>&#125;)?$</span><br><span class=\"line\"><span class=\"number\">10</span> 有<span class=\"number\">1</span>~<span class=\"number\">3</span>位小数的正实数：^[<span class=\"number\">0</span>-<span class=\"number\">9</span>]+(.[<span class=\"number\">0</span>-<span class=\"number\">9</span>]&#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>&#125;)?$</span><br><span class=\"line\"><span class=\"number\">11</span> 非零的正整数：^[<span class=\"number\">1</span>-<span class=\"number\">9</span>]\\d*$ 或 ^([<span class=\"number\">1</span>-<span class=\"number\">9</span>][<span class=\"number\">0</span>-<span class=\"number\">9</span>]*)&#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>&#125;$ 或 ^\\+?[<span class=\"number\">1</span>-<span class=\"number\">9</span>][<span class=\"number\">0</span>-<span class=\"number\">9</span>]*$</span><br><span class=\"line\"><span class=\"number\">12</span> 非零的负整数：^\\-[<span class=\"number\">1</span>-<span class=\"number\">9</span>][]<span class=\"number\">0</span>-<span class=\"number\">9</span><span class=\"string\">&quot;*$ 或 ^-[1-9]\\d*$</span></span><br><span class=\"line\"><span class=\"string\">13 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$</span></span><br><span class=\"line\"><span class=\"string\">14 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$</span></span><br><span class=\"line\"><span class=\"string\">15 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$</span></span><br><span class=\"line\"><span class=\"string\">16 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$</span></span><br><span class=\"line\"><span class=\"string\">17 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$</span></span><br><span class=\"line\"><span class=\"string\">18 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</span></span><br><span class=\"line\"><span class=\"string\">19 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$</span></span><br></pre></td></tr></table></figure></div>\n<h3 id=\"校验字符\"><a class=\"markdownIt-Anchor\" href=\"#校验字符\">#</a> 校验字符</h3>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> 汉字：^[\\u4e00-\\u9fa5]&#123;<span class=\"number\">0</span>,&#125;$</span><br><span class=\"line\"><span class=\"number\">2</span> 英文和数字：^[A-Za-z0-<span class=\"number\">9</span>]+$ 或 ^[A-Za-z0-<span class=\"number\">9</span>]&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;$</span><br><span class=\"line\"><span class=\"number\">3</span> 长度为<span class=\"number\">3</span>-<span class=\"number\">20</span>的所有字符：^.&#123;<span class=\"number\">3</span>,<span class=\"number\">20</span>&#125;$</span><br><span class=\"line\"><span class=\"number\">4</span> 由<span class=\"number\">26</span>个英文字母组成的字符串：^[A-Za-z]+$</span><br><span class=\"line\"><span class=\"number\">5</span> 由<span class=\"number\">26</span>个大写英文字母组成的字符串：^[A-Z]+$</span><br><span class=\"line\"><span class=\"number\">6</span> 由<span class=\"number\">26</span>个小写英文字母组成的字符串：^[a-z]+$</span><br><span class=\"line\"><span class=\"number\">7</span> 由数字和<span class=\"number\">26</span>个英文字母组成的字符串：^[A-Za-z0-<span class=\"number\">9</span>]+$</span><br><span class=\"line\"><span class=\"number\">8</span> 由数字、<span class=\"number\">26</span>个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w&#123;<span class=\"number\">3</span>,<span class=\"number\">20</span>&#125;$</span><br><span class=\"line\"><span class=\"number\">9</span> 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$</span><br><span class=\"line\"><span class=\"number\">10</span> 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-<span class=\"number\">9</span>]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-<span class=\"number\">9</span>]&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;$</span><br><span class=\"line\"><span class=\"number\">11</span> 可以输入含有^%&amp;<span class=\"string\">&#x27;,;=?$\\&quot;等字符：[^%&amp;&#x27;</span>,;=?$\\x22]+</span><br><span class=\"line\"><span class=\"number\">12</span> 禁止输入含有~的字符：[^~\\x22]+</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"特殊需求\"><a class=\"markdownIt-Anchor\" href=\"#特殊需求\">#</a> 特殊需求</h3>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$</span><br><span class=\"line\"><span class=\"number\">2</span> 域名：[a-zA-Z0-<span class=\"number\">9</span>][-a-zA-Z0-<span class=\"number\">9</span>]&#123;<span class=\"number\">0</span>,<span class=\"number\">62</span>&#125;(/.[a-zA-Z0-<span class=\"number\">9</span>][-a-zA-Z0-<span class=\"number\">9</span>]&#123;<span class=\"number\">0</span>,<span class=\"number\">62</span>&#125;)+/.?</span><br><span class=\"line\"><span class=\"number\">3</span> InternetURL：[a-zA-z]+:<span class=\"comment\">//[^\\s]* 或 ^https://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$</span></span><br><span class=\"line\"><span class=\"number\">4</span> 手机号码：^(<span class=\"number\">13</span>[<span class=\"number\">0</span>-<span class=\"number\">9</span>]|<span class=\"number\">14</span>[<span class=\"number\">5</span>|<span class=\"number\">7</span>]|<span class=\"number\">15</span>[<span class=\"number\">0</span>|<span class=\"number\">1</span>|<span class=\"number\">2</span>|<span class=\"number\">3</span>|<span class=\"number\">5</span>|<span class=\"number\">6</span>|<span class=\"number\">7</span>|<span class=\"number\">8</span>|<span class=\"number\">9</span>]|<span class=\"number\">18</span>[<span class=\"number\">0</span>|<span class=\"number\">1</span>|<span class=\"number\">2</span>|<span class=\"number\">3</span>|<span class=\"number\">5</span>|<span class=\"number\">6</span>|<span class=\"number\">7</span>|<span class=\"number\">8</span>|<span class=\"number\">9</span>])\\d&#123;<span class=\"number\">8</span>&#125;$</span><br><span class=\"line\"><span class=\"number\">5</span> 电话号码(<span class=\"string\">&quot;XXX-XXXXXXX&quot;</span>、<span class=\"string\">&quot;XXXX-XXXXXXXX&quot;</span>、<span class=\"string\">&quot;XXX-XXXXXXX&quot;</span>、<span class=\"string\">&quot;XXX-XXXXXXXX&quot;</span>、<span class=\"string\">&quot;XXXXXXX&quot;</span>和<span class=\"string\">&quot;XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$ </span></span><br><span class=\"line\"><span class=\"string\">6 国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;</span></span><br><span class=\"line\"><span class=\"string\">7 身份证号：</span></span><br><span class=\"line\"><span class=\"string\">\t\t15或18位身份证：^\\d&#123;15&#125;|\\d&#123;18&#125;$</span></span><br><span class=\"line\"><span class=\"string\">\t\t15位身份证：^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$</span></span><br><span class=\"line\"><span class=\"string\">\t\t18位身份证：^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;4&#125;$</span></span><br><span class=\"line\"><span class=\"string\">8 短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$</span></span><br><span class=\"line\"><span class=\"string\">9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</span></span><br><span class=\"line\"><span class=\"string\">10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$</span></span><br><span class=\"line\"><span class=\"string\">11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ </span></span><br><span class=\"line\"><span class=\"string\">12 日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;</span></span><br><span class=\"line\"><span class=\"string\">13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</span></span><br><span class=\"line\"><span class=\"string\">14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ </span></span><br><span class=\"line\"><span class=\"string\">15 钱的输入格式：</span></span><br><span class=\"line\"><span class=\"string\">16 1.有四种钱的表示形式我们可以接受:&quot;</span><span class=\"number\">10000.00</span><span class=\"string\">&quot; 和 &quot;</span><span class=\"number\">10</span>,<span class=\"number\">000.00</span><span class=\"string\">&quot;, 和没有 &quot;</span>分<span class=\"string\">&quot; 的 &quot;</span><span class=\"number\">10000</span><span class=\"string\">&quot; 和 &quot;</span><span class=\"number\">10</span>,<span class=\"number\">000</span><span class=\"string\">&quot;：^[1-9][0-9]*$ </span></span><br><span class=\"line\"><span class=\"string\">17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;</span><span class=\"number\">0</span><span class=\"string\">&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ </span></span><br><span class=\"line\"><span class=\"string\">18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ </span></span><br><span class=\"line\"><span class=\"string\">19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ </span></span><br><span class=\"line\"><span class=\"string\">20 5.必须说明的是,小数点后面至少应该有1位数,所以&quot;</span><span class=\"number\">10.</span><span class=\"string\">&quot;是不通过的,但是 &quot;</span><span class=\"number\">10</span><span class=\"string\">&quot; 和 &quot;</span><span class=\"number\">10.2</span><span class=\"string\">&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$ </span></span><br><span class=\"line\"><span class=\"string\">21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ </span></span><br><span class=\"line\"><span class=\"string\">22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ </span></span><br><span class=\"line\"><span class=\"string\">23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ </span></span><br><span class=\"line\"><span class=\"string\">24 备注：这就是最终结果了,别忘了&quot;</span>+<span class=\"string\">&quot;可以用&quot;</span>*<span class=\"string\">&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</span></span><br><span class=\"line\"><span class=\"string\">25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$</span></span><br><span class=\"line\"><span class=\"string\">26 中文字符的正则表达式：[\\u4e00-\\u9fa5]</span></span><br><span class=\"line\"><span class=\"string\">27 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</span></span><br><span class=\"line\"><span class=\"string\">28 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)</span></span><br><span class=\"line\"><span class=\"string\">29 HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</span></span><br><span class=\"line\"><span class=\"string\">30 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</span></span><br><span class=\"line\"><span class=\"string\">31 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)</span></span><br><span class=\"line\"><span class=\"string\">32 中国邮政编码：[1-9]\\d&#123;5&#125;(?!\\d) (中国邮政编码为6位数字)</span></span><br><span class=\"line\"><span class=\"string\">33 IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)</span></span><br></pre></td></tr></table></figure></div><hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>0-9 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>0-9 <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
            "tags": [
                "java",
                "java基础",
                "java学习路线"
            ]
        },
        {
            "id": "http://example.com/2023/10/12/java/java8%E6%96%B0%E7%89%B9%E6%80%A7-%E5%B0%9A%E7%A1%85%E8%B0%B7-92/",
            "url": "http://example.com/2023/10/12/java/java8%E6%96%B0%E7%89%B9%E6%80%A7-%E5%B0%9A%E7%A1%85%E8%B0%B7-92/",
            "title": "java8新特性-尚硅谷-92",
            "date_published": "2023-10-12T10:49:32.881Z",
            "content_html": "<p><a class=\"link\"   href=\"https://www.bilibili.com/video/BV1Kb411W75N?p=666&amp;vd_source=636bdfc4ce8c201bed8740cf77c11dda\" >尚硅谷 Java 入门视频教程 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<h1 id=\"新特性简介\"><a class=\"markdownIt-Anchor\" href=\"#新特性简介\">#</a> 新特性简介</h1>\n<ul>\n<li>速度更快，便于并行</li>\n<li>代码更少，增加了新的语法：Lambda 表达式</li>\n<li>强大的 Stream API</li>\n<li>最大化的减少空指针异常：Optional</li>\n<li>Nashorn 引擎，允许在 JVM 上运行 JS 应用</li>\n</ul>\n<h1 id=\"lambda表达式\"><a class=\"markdownIt-Anchor\" href=\"#lambda表达式\">#</a> Lambda 表达式</h1>\n<p><strong>Lambda 表达式的本质：与其他语言的 lambda 表达式不同，java 中的 lambda 表达式不是匿名函数，而是作为函数式接口的实例。</strong></p>\n<p>以 <code>(o1,02) -&gt; Interger.compare(o1,o2)</code>  为例， <code>-&gt;</code>  是 Lambda 操作符或箭头操作符，左边是形参列表，其实就是接口中的抽象方法的形参列表，右边是 lambda 体，其实就是重写的抽象方法的方法体。</p>\n<p>以前使用匿名实现类表示的现在都可以用 lambda 表达式做。</p>\n<h2 id=\"语法格式\"><a class=\"markdownIt-Anchor\" href=\"#语法格式\">#</a> 语法格式</h2>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.无参，无返回值</span></span><br><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">r2</span> <span class=\"operator\">=</span> () -&gt; System.out.println(<span class=\"string\">&quot;hello,world&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//2.Lambda需要一个参数，但是没有返回值</span></span><br><span class=\"line\">Consumer&lt;String&gt; con = (String s) -&gt; &#123;System.out.println(s);&#125;;</span><br><span class=\"line\"><span class=\"comment\">//3.数据类型可以省略，因为可由编译器推断得出，称为“类型推断”,只有一个参数时可以省略小括号</span></span><br><span class=\"line\">Consumer&lt;String&gt; con = s -&gt; &#123;System.out.println(s);&#125;;</span><br><span class=\"line\"><span class=\"comment\">//4.表达式需要两个或以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class=\"line\">Comparator&lt;Integer&gt; com = (o1,o2) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;========&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o1.compareTo(o2);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//5.当lambda题只有一条语句时，return和大括号都可以省略</span></span><br><span class=\"line\">Comparator&lt;Integer&gt; com = (o1,o2) -&gt; o1.compareTo(o2);</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"函数式接口\"><a class=\"markdownIt-Anchor\" href=\"#函数式接口\">#</a> 函数式接口</h2>\n<p><strong>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。</strong></p>\n<p>我们可以在一个接口上使用 <code>@FunctionalInterface</code>  注解，这样可以检测它是否为函数式接口。</p>\n<p>在 java.util.function 包下定义了 java8 丰富的函数式接口。</p>\n<p>java 不仅可以支持 OOP (面向对象编程)，还可以支持 OOF (面向函数编程)。</p>\n<h2 id=\"核心函数式接口\"><a class=\"markdownIt-Anchor\" href=\"#核心函数式接口\">#</a> 核心函数式接口</h2>\n<table>\n<thead>\n<tr>\n<th>接口</th>\n<th>参数类型</th>\n<th>返回类型</th>\n<th>用途</th>\n<th>方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Consumer<T></td>\n<td>T</td>\n<td>void</td>\n<td>对类型为 T 的对象应用操作</td>\n<td>void accept(T t)</td>\n</tr>\n<tr>\n<td>Supplier<T></td>\n<td>无</td>\n<td>T</td>\n<td>返回类型为 T 的对象</td>\n<td>T get()</td>\n</tr>\n<tr>\n<td>Function&lt;T,R&gt;</td>\n<td>T</td>\n<td>R</td>\n<td>对类型为 T 的对象应用操作，并返回结果为 R 的对象</td>\n<td>R apply(T t)</td>\n</tr>\n<tr>\n<td>Predicate<T></td>\n<td>T</td>\n<td>boolean</td>\n<td>确定类型为 T 的对象是否满足某种约束，并返回 boolean 值</td>\n<td>boolean test(T t)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"方法引用和构造器引用\"><a class=\"markdownIt-Anchor\" href=\"#方法引用和构造器引用\">#</a> 方法引用和构造器引用</h2>\n<p>当要传递给 lambda 体的操作，已经有实现的方法了，可以使用方法引用。方法引用就是 lambda 表达式，通过方法的名字来指向一个方法，可以认为是 lambda 表达式的一个语法糖。</p>\n<p><strong>使用的要求是实现接口的抽象对象方法的参数列表和返回值类，必须与方法引用的方法的参数列表和返回值类型一致。</strong></p>\n<p>使用格式： <code>类或对象 :: 方法名</code> 。具体有三种情况，对象调用非静态方法，类调用静态方法，类调用非静态方法。</p>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Consumer中的void accept(T t)和PrintStream中的void println(T t)的参数列表和返回值类型一致</span></span><br><span class=\"line\">Consumer&lt;String&gt; con1 = s -&gt; System.out.println(s);</span><br><span class=\"line\">con1.accept(<span class=\"string\">&quot;hello,world&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//使用方法引用</span></span><br><span class=\"line\"><span class=\"type\">PrintStream</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> System.out;</span><br><span class=\"line\">Consumer&lt;String&gt; con2 = ps::println;</span><br><span class=\"line\">con2.accept(<span class=\"string\">&quot;hello,beijing&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//类::实例方法,Comparator中的int compare(T o1,T o2)和String中的int o1.compareTo(o2)</span></span><br><span class=\"line\"><span class=\"comment\">//前者比后者多一个参数，实际上是使用该参数调用实例方法，因为类是无法调用实例方法的</span></span><br><span class=\"line\">Comparator&lt;String&gt; com = (o1,o2) -&gt; o1.compareTo(o2);</span><br><span class=\"line\">Comparator&lt;String&gt; com2 = String :: compareTo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//构造器引用与方法引用类似</span></span><br><span class=\"line\">Supplier&lt;Employee&gt; sup = () -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>();</span><br><span class=\"line\">Supplier&lt;Employee&gt; sup1 = Employee::<span class=\"keyword\">new</span>;</span><br></pre></td></tr></table></figure></div>\n<h1 id=\"stream-api\"><a class=\"markdownIt-Anchor\" href=\"#stream-api\">#</a> Stream API</h1>\n<p>Stream API 把真正的函数式编程风格引入到 java 中。使用 Stream API 可以对集合数据进行操作，可以执行非常复杂的查找、过滤和映射数据等操作，这操作类似 SQL 执行的数据库查询。</p>\n<p>现在数据库源有 MongDB，Redis 等，而这些 NoSQL 的数据就需要 java 层面去处理。</p>\n<p><strong>Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</strong></p>\n<p><strong>Stream 自身不存储元素。Stream 不会改变源对象，相反，他们会返回一个持有结果的新 Stream。</strong></p>\n<p><strong>Stream 操作是延迟执行的，只有在执行终止操作，才执行中间操作链，并产生结果。执行终止操作后流不能再复用，若想继续操作需要重新创建新的 Stream。</strong></p>\n<p>Optional<T>类是一个容器类，可以保存类型 T 的值，代表这个值存在，或者仅仅保存 null，表示这个值不存在。是 java8 中用于解决空指针异常引入的类。</p>\n<h2 id=\"创建stream流\"><a class=\"markdownIt-Anchor\" href=\"#创建stream流\">#</a> 创建 Stream 流</h2>\n<ul>\n<li>集合可以通过 stream () 方法返回一个顺序流，通过 parallelStream () 方法返回一个并行流。</li>\n<li>数组可以通过 stream () 方法返回一个流。</li>\n<li>通过 Stream 的 of () 方法，在方法内填入多个参数形成容器。</li>\n<li>使用 iterate () 迭代方法和 generate () 生成方法创建无限流，主要用于生成数据。</li>\n</ul>\n<div class=\"highlight-container\" data-rel=\"Java\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Employee&gt; employees = EmployeeData.getEmployees();<span class=\"comment\">//获取一个集合</span></span><br><span class=\"line\"><span class=\"comment\">//default Stream&lt;E&gt; stream():返回一个顺序流</span></span><br><span class=\"line\">Stream&lt;Employee&gt; stream = employees.stream();</span><br><span class=\"line\">Stream.of(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>);<span class=\"comment\">//填入参数形成容器</span></span><br><span class=\"line\"><span class=\"comment\">//迭代方法，初始值为0，每次迭代加2，limit()限制输出个数，并在forEach()中指定输出位置</span></span><br><span class=\"line\">Stream.iterate(<span class=\"number\">0</span>,t -&gt; t+<span class=\"number\">2</span>).limit(<span class=\"number\">10</span>)forEach(System.out::println);</span><br><span class=\"line\">Stream.generate(Math::random).limit(<span class=\"number\">10</span>)forEach(System.out::println);<span class=\"comment\">//生成10个随机数</span></span><br></pre></td></tr></table></figure></div>\n<h2 id=\"中间操作\"><a class=\"markdownIt-Anchor\" href=\"#中间操作\">#</a> 中间操作</h2>\n<h3 id=\"筛选与切片\"><a class=\"markdownIt-Anchor\" href=\"#筛选与切片\">#</a> 筛选与切片</h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>fliter(Predicate p)</td>\n<td>接收 Lambda，从流中排除某些元素</td>\n</tr>\n<tr>\n<td>distinct()</td>\n<td>筛选，通过流所生成元素的 hashCode () 和 equals () 去除重复元素</td>\n</tr>\n<tr>\n<td>limit(long maxSize)</td>\n<td>截断流，使其元素不超过给定数量</td>\n</tr>\n<tr>\n<td>skip(long n)</td>\n<td>跳过元素，返回一个忽略前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"映射与排序\"><a class=\"markdownIt-Anchor\" href=\"#映射与排序\">#</a> 映射与排序</h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>map(Function f)</td>\n<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td>\n</tr>\n<tr>\n<td>mapToDouble(ToDoubleFunction f)</td>\n<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个 DoubleStream。</td>\n</tr>\n<tr>\n<td>mapToint(TointFunction f)</td>\n<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个 IntStream。</td>\n</tr>\n<tr>\n<td>mapToLong(ToLongFunction f)</td>\n<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个 LongStream。</td>\n</tr>\n<tr>\n<td>flatMap(Function f)</td>\n<td>接收一个函数作为参数，将流中的每个值都转换成一个流，然后把所有流连接成一个流。例如将字符串数组的每个元素拆成字符，再组合成一个字符数组。</td>\n</tr>\n<tr>\n<td>sorted(Comparator com)</td>\n<td>产生一个新流，如果没有传入比较器，则按自然顺序排序，否则按照比较器顺序排序。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"终止\"><a class=\"markdownIt-Anchor\" href=\"#终止\">#</a> 终止</h3>\n<p>map 和 reduce 的连接通常被称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。</p>\n<p>Collect 接口中方法的实现决定了如果对流执行收集的操作，如收集到 List，Set 和 Map。另外 Collects 实用类提供了很多静态方法，可以方便地创建常见收集器实例。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>allMatch(Predicate p)</td>\n<td>检查是否匹配所有元素</td>\n</tr>\n<tr>\n<td>anyMatch(Predicate p)</td>\n<td>检查是否至少匹配一个元素</td>\n</tr>\n<tr>\n<td>noneMatch(Predicate p)</td>\n<td>检查是否没有匹配所有元素</td>\n</tr>\n<tr>\n<td>findFirst()</td>\n<td>返回第一个元素</td>\n</tr>\n<tr>\n<td>findAny()</td>\n<td>返回当前流中所有元素</td>\n</tr>\n<tr>\n<td>count()</td>\n<td>返回流中元素的总个数</td>\n</tr>\n<tr>\n<td>max(Comparator c)</td>\n<td>返回流中元素的最大值</td>\n</tr>\n<tr>\n<td>min(Comparator c)</td>\n<td>返回流中的最小值</td>\n</tr>\n<tr>\n<td>forEach(Consumer c)</td>\n<td>内部迭代</td>\n</tr>\n<tr>\n<td>reduce(T iden,BinaryOperator b)</td>\n<td>可以将流中元素反复结合起来，得到一个值，返回 T。</td>\n</tr>\n<tr>\n<td>reduce(BinaryOperator b)</td>\n<td>可以将流中元素反复结合起来，得到一个值，返回 Optional<T></td>\n</tr>\n<tr>\n<td>collect(Collector c)</td>\n<td>将流转换为其他形式。接收一个 Collector 接口的实现，用于给 Stream 中元素做汇总的方法</td>\n</tr>\n</tbody>\n</table>\n",
            "tags": [
                "java",
                "java基础",
                "java学习路线"
            ]
        },
        {
            "id": "http://example.com/2023/10/12/java/HeadFirst%20Java-Kathy%20Sierra/",
            "url": "http://example.com/2023/10/12/java/HeadFirst%20Java-Kathy%20Sierra/",
            "title": "HeadFirst Java-Kathy Sierra-90",
            "date_published": "2023-10-12T10:49:32.879Z",
            "content_html": "<ol>\n<li>当某个对象被 java 虚拟机察觉不会被使用到，该对象就会被标记成可回收的。如果内存开始不足，垃圾收集器就会启动来清理垃圾、回收空间，让空间能够再次被利用。</li>\n<li>任何变量只要加上 public、static 和 final，基本上都会变成全局变量取用的常数。</li>\n<li><strong>事实上没有对象变量这样的东西存在，只要引用到对象的变量，对象引用变量保存的是存取对象的方式。</strong></li>\n<li>数组是个对象，不管里面放的是不是 primitive 主数据类型。</li>\n<li>java 是通过值传递的，也就是通过拷贝传递，方法无法改变调用方所传入的参数。</li>\n<li>在创建一个类之前我们需要写出下面三种东西：伪码、测试码、真实码。</li>\n<li>标准版的扩展都以 javax 作为包名称的开头。</li>\n<li>import 和 C 的 include 并不相同，运用 import 只是帮你省下每个类前面的包名称而已。程序不会英文用来 import 而变大或变慢。</li>\n<li>抽象类的产生源于有些类不应该被初始化，比如动物类应该是什么？</li>\n<li>任何从 <code>ArrayList&lt;Object&gt;</code>  取出的东西都会被当作 Object 类型的引用而不管它原来是什么。而且编译器是根据引用类型来判断哪些方法可以调用，而不是根据 Object 实际的类型。</li>\n<li>多重继承会产生 “致命方块 &quot; 问题，即两个及以上的直接父类拥有相同的方法，子类不知道应该调用哪个方法。</li>\n<li><strong>接口解决致命方块的方法很简单：把全部方法设为抽象的，如此一来，子类就得实现这个此方法，因此 java 虚拟机在执行期间就不会搞不清楚要用哪一个继承版本。</strong></li>\n<li><strong>在 java 中，程序员会在乎内存中的两个区域：对象的生存空间堆 (heap) 和方法调用及变量的生存空间 (stack)。</strong></li>\n<li><strong>不管对象是否声明或创建，如果局部变量是个对该对象的引用，只有变量本身会放在栈上，对象本身只会存在于堆上。</strong></li>\n<li>实例变量声明在类中方法之外的地方，局部变量声明在方法或方法的参数上。</li>\n<li>构造函数在执行的时候，第一件事是去执行它的父类的构造函数，这会连锁反应到 Object 这个类为止。因为如果我们没有调用 super ()，编译器会帮我们加上 super () 的调用。</li>\n<li><strong>基本数据类型有默认值，而包装类则没有默认值。</strong></li>\n<li>编译器不会注意 RuntimeException 类型的异常，它所关心的是称为检查异常的异常。</li>\n<li>内部类可以使用外部所有的方法和变量，就算是私有的也一样可以使用。</li>\n<li>如果某实例变量不能或不应该被实例化的，因为有些变量要在执行期当场创建才有意义。这个时候需要把它标记为 transient (瞬时) 的，transient 的引用变量会以 null 返回，而不管存储当时它的值是什么。恢复时会被赋值为 null 的对象引用或基本数据类型的默认值。</li>\n<li><strong>一个不可序列化的父类，其子类可以是可序列化的。</strong></li>\n<li>解序列化时新的对象会被配置到堆上，但构造函数不会执行，不然会抹去对象的状态。</li>\n<li><strong>静态变量不会被序列化，因为所有对象都是共享同一份静态变量值。当对象还原时，静态变量会恢复成类中原本的样子，而不是存储时的样子。</strong></li>\n<li>将 FileWriter 链接到 BufferedWriter 可以提升效率，因为 BufferedWriter 可以暂存一堆数据，然后到满的时候再实际写入键盘，这样可以减少对磁盘的操作。</li>\n<li>File 对象代表文件的路径，而不是文件本身。</li>\n<li>对象的状态并非只能用序列化来存储，也可以使用 transient 修饰存储。</li>\n<li>java 的好处就在于大部分的输入 / 输出工作并不在乎链接串流的上游实际是什么。也就是说可以使用 BufferedReader 而不管是来自串流来自文件或 socket。</li>\n<li>调度器在不同的 java 虚拟机上有不同的做法，就算是同一个程序在同一台机器上运行也会有不同的遭遇。</li>\n<li>对泛型来说，extends 这个关键词代表 &quot;是一个…&quot;，且适用于类和接口。</li>\n<li>hashcode 是用来缩小寻找成本的，但最后还是要用 equals () 才能认定是否真的找到了相同的项目。如果两个对象有相同的 hashcode 值，它们不一定是相等的。但若两个对象相等，则 hashcode 值一定要相等。</li>\n<li><strong>数组的类型是运行时检查的，但集合的类型检查只会发生在编译期间。</strong></li>\n<li>JAR 就是 JavaARchive，这种文件是个 pkzip 格式的文件，它能让你的一组类文件包装起来，所以交付时只需一个 JAR 文件。</li>\n<li>JWS (Java Web Start) 程序由两个部分组成：可执行的 JAR 文件和.jnlp 文件。.jhlp 文件是用来描述 JWS 应用程序的 XML 文件，它有 target 指定 JAR 的名称和位置，以及带有 main () 的类名称。</li>\n</ol>\n",
            "tags": [
                "书籍",
                "java",
                "java基础",
                "java学习路线"
            ]
        }
    ]
}