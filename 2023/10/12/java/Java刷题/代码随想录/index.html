<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="xiqin">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2023/10/12/java/java刷题/代码随想录/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="# 第一章 数组 # 704. 二分查找  关键词：二分法、双指针、边界处理 思路是使用二分查找方法，用左右指针不断进行二分来缩小范围，以这个为主要的思路，处理一些小的细节：  java 中的除法是去尾除法。 设定退出条件，退出条件与 mid 给两个指针的赋值相关。在这里是采取的加减 1 的方法，所以判断条件是大于等于。如果采用 left-1  而 right 不处理的话，则可以去掉等于号。 ja">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2023/10/12/java/Java%E5%88%B7%E9%A2%98/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="# 第一章 数组 # 704. 二分查找  关键词：二分法、双指针、边界处理 思路是使用二分查找方法，用左右指针不断进行二分来缩小范围，以这个为主要的思路，处理一些小的细节：  java 中的除法是去尾除法。 设定退出条件，退出条件与 mid 给两个指针的赋值相关。在这里是采取的加减 1 的方法，所以判断条件是大于等于。如果采用 left-1  而 right 不处理的话，则可以去掉等于号。 ja">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/10/12/java/Java%E5%88%B7%E9%A2%98/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/32de457907344ab2d3d26756890d38f1.png">
<meta property="og:image" content="http://example.com/2023/10/12/java/Java%E5%88%B7%E9%A2%98/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/1b87dee143e0e43e987f8da999b2a2aa.png">
<meta property="article:published_time" content="2023-10-12T10:49:32.892Z">
<meta property="article:modified_time" content="2023-04-05T11:45:14.000Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/10/12/java/Java%E5%88%B7%E9%A2%98/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/32de457907344ab2d3d26756890d38f1.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-favicon.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.svg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/redefine-favicon.svg">
    <!--- Page Info-->
    
    <title>
        
        西芹的小站
    </title>
    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">

    <!--- Font Part-->
    
    
    
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    window.config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"西芹的小站","subtitle":{"text":["没有调查，没有发言权","花开如火，也如寂寞"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"links":{"github":"https://github.com/xiqin-huang","instagram":null,"zhihu":"https://www.zhihu.com/people/xiqin-huang","twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.5.0","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"}},"search":{"enable":true,"preload":true},"categories":{"分类":{"icon":"fa-solid fa-folder","path":"/categories/"}},"tags":{"标签":{"icon":"fa-solid fa-tags","path":"/tags/"}}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"links":null},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/6/17 11:45:14"};
    window.lang_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="swup-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                西芹的小站
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        首页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer w-full absolute top-0 left-0 bg-background-color">
        <ul class="drawer-navbar-list flex flex-col justify-start items-center">
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group " 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                首页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container">
    <div class="article-content-container">

        <div class="article-title">
            
                <h1 class="article-title-regular"></h1>
            
            </div>
            
                    
        
        
            <div class="article-header flex flex-row gap-2 items-center">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/images/redefine-avatar.svg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">xiqin</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv5</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-10-12 18:49:32</span>
        <span class="mobile">2023-10-12 18:49:32</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-04-05 19:45:14</span>
            <span class="mobile">2023-04-05 19:45:14</span>
            <span class="hover-info">更新</span>
        </span>
    

    
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>38k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>169 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body">
            <h1 id="第一章-数组"><a class="markdownIt-Anchor" href="#第一章-数组">#</a> 第一章 数组</h1>
<h2 id="704二分查找"><a class="markdownIt-Anchor" href="#704二分查找">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/" >704. 二分查找 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二分法、双指针、边界处理</strong></p>
<p>思路是使用二分查找方法，用左右指针不断进行二分来缩小范围，以这个为主要的思路，处理一些小的细节：</p>
<ol>
<li>java 中的除法是去尾除法。</li>
<li>设定退出条件，退出条件与 mid 给两个指针的赋值相关。在这里是采取的加减 1 的方法，所以判断条件是大于等于。如果采用 <code>left-1</code>  而 right 不处理的话，则可以去掉等于号。</li>
<li>java 中数组的声明为 <code>int nums = &#123;1,2,3&#125;;</code> ，是大括号而不是中括号。</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length - <span class="number">1</span>,mid;<span class="comment">//length方法获取数组的长度</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="27移除元素"><a class="markdownIt-Anchor" href="#27移除元素">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/" >27. 移除元素 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：双指针、边界处理</strong></p>
<p>由于题目不要求元素的相对位置不变，所以我们可以使用双指针的方式前面搜索是否有等于 val 的元素，遇到则在后面找不等于 val 的元素进行替换。细节的处理：</p>
<ol>
<li>注意对边界进行处理，当 left 遇到 right 就应当停止，同理 right 遇到 left 后也应当停止，防止越界的情况出现。</li>
<li>对与 right 遇到 left 这种情况需要进行处理，因为这意味着后面已经找不到元素进行与 left 处的元素进行替换了，所以此时的 left 不需要往前进行移动，而是直接返回当前的 left 值即可。</li>
<li>可以省略将 left 处的值赋到 right 处的步骤，因为后面已经被截断，不影响结果。</li>
<li>可以不用一步到位，应该逐步来，这样会减少很多的额外情况处理。</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] == val) &#123;</span><br><span class="line">              <span class="comment">//可以不一步到位，而是采用下面的方面</span></span><br><span class="line">                <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == val) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                    <span class="keyword">return</span> left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//不需将left处的值赋到right处，因为后面已经被截断</span></span><br><span class="line">                    nums[left] = nums[right];</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他题解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] == val) &#123;</span><br><span class="line">                nums[left] = nums[right - <span class="number">1</span>];<span class="comment">//此处没有向左遍历，而是用左侧的新的元素替换</span></span><br><span class="line">                right--;<span class="comment">//只移动right的值，left值不变，因为此时left处可能仍是val值</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="209长度最小的子数组"><a class="markdownIt-Anchor" href="#209长度最小的子数组">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/" >209. 长度最小的子数组 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：双指针、滑动窗口</strong></p>
<p>使用滑动窗口来解决该问题，使用 count 记录目前窗口中的子数组和。</p>
<ol>
<li>右指针 i 不断向右移动，如果遇到子数组和满足条件则对窗口进行收缩，这里的收缩就是重点，我的想法是收缩至子数组小于目标值，然后再回退一步，此时得到的值就是目前刚好可以满足条件的最小数组。</li>
<li>值得注意的是结果的初值应该设置为比数组长度更大，以便判断最后是否有结果。</li>
<li>可以使用 <code>Math.min()</code>  来取最小值，用 <code>Integer.MAX_VALUE</code>  来表示最大值。</li>
<li>在窗口缩小的时候，可以在缩小前先记录结果，这样就不需要再进行恢复操作了。</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>,ans=length+<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//滑动窗口的左指针是j，右指针是i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            count+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(count&gt;target)&#123;<span class="comment">//如果此时已经大于目标，收缩窗口</span></span><br><span class="line">                <span class="keyword">while</span>(count&gt;=target)&#123;</span><br><span class="line">                    count-=nums[j];</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                j--;<span class="comment">//回退一步恢复成符合条件</span></span><br><span class="line">                count+=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;=target &amp;&amp; ans&gt;i-j+<span class="number">1</span>)&#123;<span class="comment">//如果大于目标值且长度最小则记录新的值</span></span><br><span class="line">                ans=i-j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ans==length+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他题解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                result = Math.min(result, right - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="59螺旋矩阵-ii"><a class="markdownIt-Anchor" href="#59螺旋矩阵-ii">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/" >59. 螺旋矩阵 II <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：指针、数学</strong></p>
<p>这题并没有什么算法思想，考验的就是对于指针的使用，如何变化才是最好的方式。这个解法给我的启示是不要想着一个阶段完成所有情况，可以单独处理麻烦的特殊情况，例如奇数的情况下，中间的赋值就不符合四个循环的赋值，与其硬是添加进去也是可以的，但是就使得程序变复杂了。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> [][] array = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> startx=<span class="number">0</span>,starty=<span class="number">0</span>,loop=n/<span class="number">2</span>,mid = n/<span class="number">2</span>,count=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> offset=<span class="number">1</span>,i,j;</span><br><span class="line">        <span class="keyword">while</span>(loop &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            i=startx;<span class="comment">//设置每次循环的起始点</span></span><br><span class="line">            j=starty;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(j=starty;j&lt;starty+n-offset;j++)&#123;</span><br><span class="line">                array[startx][j]=count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i=startx;i&lt;startx+n-offset;i++)&#123;</span><br><span class="line">                array[i][j]=count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;j&gt;starty;j--)&#123;</span><br><span class="line">                array[i][j]=count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;i&gt;startx;i--)&#123;</span><br><span class="line">                array[i][j]=count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset+=<span class="number">2</span>;<span class="comment">//限制每次循环的步长</span></span><br><span class="line">            loop--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;<span class="comment">//对奇数时的中间结点单独处理</span></span><br><span class="line">            array[mid][mid]=count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="第二章-链表"><a class="markdownIt-Anchor" href="#第二章-链表">#</a> 第二章 链表</h1>
<h2 id="203移除链表元素"><a class="markdownIt-Anchor" href="#203移除链表元素">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/" >203. 移除链表元素 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：链表格式、指针、虚拟头结点</strong></p>
<p>太久没用 java 了，用了 C 语言操作指针的格式，一直报错。这题可以使用虚拟头结点来解决 head 指针为空的特殊情况，将处理步骤归一化，当然使用单独处理的方法也是可以的。然后本题的一个易错点是结果返回 head 的值，当链表本来非空，但是经过删除后为空的情况就会出现问题，因此我们应该返回虚拟头结点的 next 的指针。由于我们的 temp 指针是一直移动的，因此需要新建一个结点来存储虚拟头结点的值。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">answer</span> <span class="operator">=</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.val==val)&#123;</span><br><span class="line">                temp.next=temp.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="707设计链表"><a class="markdownIt-Anchor" href="#707设计链表">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/" >707. 设计链表 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：虚拟头结点、边界判断</strong></p>
<p>这题并没有什么算法实现，考察的是细心程度和对题目的理解。通过这道题目，加深了我对链表各项基本操作的理解。本题遇到的最大问题是在 AddAtIndex 函数上，size+1 的位置放错了，由于调用了其他的函数，里面就已经加一了，因此会导致 size 比真实值大。还有就是在 AddAtTail 函数中曾经出现的断链问题，应该要想好了再编写代码，而不是写完再慢慢纠错。</p>
<p>题解中也有将 AddAtTail 和 AddAthead 使用 AddAtIndex 函数来解决，也是一种思路。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode head;</span><br><span class="line">    ListNode tail;</span><br><span class="line">    ListNode temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=size || index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=index;i++)&#123;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        size+=<span class="number">1</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val,head.next);</span><br><span class="line">        head.next=num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        temp=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode num=<span class="keyword">new</span> <span class="title class_">ListNode</span>(val,temp.next);</span><br><span class="line">        temp.next=num;</span><br><span class="line">        size+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;size)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index==size)&#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            addAtHead(val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp=head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode num=<span class="keyword">new</span> <span class="title class_">ListNode</span>(val,temp.next);</span><br><span class="line">            temp.next=num;</span><br><span class="line">            size+=<span class="number">1</span>; </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>&lt;=index &amp;&amp; index&lt;size)&#123;</span><br><span class="line">            temp=head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.next=temp.next.next;</span><br><span class="line">            size-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="206反转链表"><a class="markdownIt-Anchor" href="#206反转链表">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/submissions/" >206. 反转链表 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：虚拟头结点、双指针、头插法</strong></p>
<p>反转链表是头插法的经典应用，我们只需新建一个虚拟头结点，然后依次将链表中的结点使用头插法插入到虚拟头结点后即可。或者也可以使用双指针，从头结点开始依次将其方向反转，最后返回原最后一个结点即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ins</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">top</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(head.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            ins=head.next;</span><br><span class="line">            head.next=head.next.next;</span><br><span class="line">            ins.next=top;</span><br><span class="line">            ans.next=ins;</span><br><span class="line">            top=ins;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依次反转结点方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="19删除链表的倒数第-n-个结点"><a class="markdownIt-Anchor" href="#19删除链表的倒数第-n-个结点">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" >19. 删除链表的倒数第 N 个结点 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：快慢指针、双指针，虚拟头结点</strong></p>
<p>这道题常规的思路应该是先计算链表的长度，然后算出倒数第 n 个元素的正数位置，然后结点移动到要删除的节点的前面，删除即可。进阶的要求是一遍扫描，此时我们就可以用到快慢指针法，先让快指针移动 n 位，然后让快慢指针一起移动，等到快指针移动到最后的位置时，慢指针此时就到达链表的倒数第 n 个节点的前一个结点，最后删除结点即可满足要求。细节就是使用虚拟头结点来解决删除元素后链表为空的特殊情况。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode fast=ans;</span><br><span class="line">        ListNode slow=ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next=slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> ans.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="14环形链表-ii"><a class="markdownIt-Anchor" href="#14环形链表-ii">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/" >14. 环形链表 II <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：无法解决、快慢指针、数学、哈希表</strong></p>
<p>本来是想着套用上一题环形链表的方法，逐个结点检测，然后得到答案。但是遇到了一个问题，那就是只要是成环，那么快慢指针一定会相遇。最后还是看了题解才解决了问题，要利用<a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/" >数学的方法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>推导出分别从相遇点和起始点出发，两种相遇的地方即为入口。也可以使用哈希表的特性检测出第一个结点。</p>
<p>数学分析：当 fast=slow 时，两指针在环中第一次相遇。下面分析此时 fast 与 slow 走过的步数关系：设链表共有 a 十 b 个节点，其中链表头部到链表入口有 a 个节点（不计链表入口节点)，链表环有 b 个节点。设两指针分别走了 f，s 步，则有： 1.fast 走的步数是 slow 步数的 2 倍，即 f=2s。2.fast 比 slow 多走了 n 个环的长度，即 f=s+nb;（解析：双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走环的长度整数倍)；以上两式相减得：f=2nb,s=nb。即 fast 和 slow 指针分别走了 2n,n 个环的周长。如果让指针从链表头部一直向前走并统计步数 k, 那么所有走到链表入口节点时的步数是：k=a+nb (先走 a 步到入口节点，之后每绕 1 圈环 (b 步) 都会再次到入口节点). 而目前， slow 指针走过的步数为 nb 步。因此，我们只要想办法让 s1ow 再走 a 步停下来，就可以到环的入口。但是我们不知道 a 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和 slow 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头部 head。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">                <span class="keyword">while</span>(head!=slow)&#123;</span><br><span class="line">                    head=head.next;</span><br><span class="line">                    slow=slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pos</span> <span class="operator">=</span> head;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(pos)) &#123;<span class="comment">//检测是否属于哈希表内</span></span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                visited.add(pos);</span><br><span class="line">            &#125;</span><br><span class="line">            pos = pos.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="第三章-哈希表"><a class="markdownIt-Anchor" href="#第三章-哈希表">#</a> 第三章 哈希表</h1>
<h2 id="242有效的字母异位词"><a class="markdownIt-Anchor" href="#242有效的字母异位词">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/" >242. 有效的字母异位词 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：哈希表、String 函数使用、数组</strong></p>
<p>使用哈希表的知识很容易解决该题，由于字符串全部由小写字母组成，因此我们只需要维护一个 26 位的数组即可。将 s 字符串每个位置的字符与小写 a 相减，在对应的位置上加一。同理对 t 字符串进行处理，在对应位置上减一。然后遍历数组，如果有非零位，则返回 false，否则返回 true。细节就在于 String 函数的使用，java 不支持 <code>s[i]</code>  的方法获取对应位置的字符，需要使用 charAt () 函数获取。另一种思路是将字符串进行排序，然后直接对比是否相同。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            count[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.length();i++)&#123;</span><br><span class="line">            count[t.charAt(i)-<span class="string">&#x27;a&#x27;</span>]-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] str2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(str1);</span><br><span class="line">        Arrays.sort(str2);</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(str1, str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="349两个数组的交集"><a class="markdownIt-Anchor" href="#349两个数组的交集">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/" >349. 两个数组的交集 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：哈希表、数组、lambda 表达式、数组长度获取，集合与数组之间的转换</strong></p>
<p>这题的思路还是很简单的，问题是很多都没有现成的函数来实现，例如集合与数组之间的转换就很麻烦，需要从数组中逐个取出后再放入集合内，集合转数组也是同理。细节就是数组获取长度是 <code>nums1.length</code> ，集合是 <code>set2.size()</code> ，注意有没有括号。另一种思路是先将两个数组排序，然后使用双指针逐步比较来构造新的数组。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums1)&#123;</span><br><span class="line">            set1.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set1.contains(num))&#123;</span><br><span class="line">                set2.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[set2.size()];</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:set2)&#123;</span><br><span class="line">            arr[j++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序+双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span>[] intersection = <span class="keyword">new</span> <span class="title class_">int</span>[length1 + length2];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>, index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> nums1[index1], num2 = nums2[index2];</span><br><span class="line">            <span class="keyword">if</span> (num1 == num2) &#123;</span><br><span class="line">                <span class="comment">// 保证加入元素的唯一性</span></span><br><span class="line">                <span class="keyword">if</span> (index == <span class="number">0</span> || num1 != intersection[index - <span class="number">1</span>]) &#123;</span><br><span class="line">                    intersection[index++] = num1;</span><br><span class="line">                &#125;</span><br><span class="line">                index1++;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">                index1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(intersection, <span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="1两数之和"><a class="markdownIt-Anchor" href="#1两数之和">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/" >1. 两数之和 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：哈希表、字典 HashMap、数组下标返回</strong></p>
<p>这题以前我是使用暴力破解的方法解决的，即使用双指针来遍历数组。这道的题的难点在于数组是无序的且返回的不是整数，而是它们的数组下标，否则可以使用数组排序加首尾指针的方式解决该问题。改用哈希表来解决的话，我们可以遍历数组，把 <code>target-nums[i]</code>  的值存储到哈希表内，然后如果出现数组中的值等于哈希表内的值则说明两数的和等于 target。由于要记录数组下标，因此不能使用集合 Set，而是使用字典 Map，key 记录值，value 记录数组下标。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> i; </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans.containsKey(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.put(target-nums[i],i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, ans.get(nums[i])&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="454四数相加-ii"><a class="markdownIt-Anchor" href="#454四数相加-ii">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/" >454. 四数相加 II <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：哈希表、字典 HashMap</strong></p>
<p>这题与上一题有类似的地方，这次虽然数组多了，但是思想还是类似，我们只要将两两集合一起，实际上又回到了两数之和的思路。只不过这次我们 Map 的 value 记录的不是数组下标，而是每个 key 出现的次数。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="type">int</span> fin=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num1:nums1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> num2:nums2)&#123;</span><br><span class="line">                temp=num1+num2;</span><br><span class="line">                <span class="keyword">if</span>(ans.containsKey(temp))&#123;</span><br><span class="line">                    ans.put(temp,ans.get(temp)+<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans.put(temp,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num3:nums3)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> num4:nums4)&#123;</span><br><span class="line">                temp=-num3-num4;</span><br><span class="line">                <span class="keyword">if</span>(ans.containsKey(temp))&#123;</span><br><span class="line">                    fin+=ans.get(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="15三数之和"><a class="markdownIt-Anchor" href="#15三数之和">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/" >15. 三数之和 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：双指针、可变二维数组、数组长度、边界判断、排序、去重</strong></p>
<p>三数之和在某种意义上比两数之和还要简单，因为此时不要求数组下标，我们只需求出不重复的三元组。因此我们只需将一个元素固定，然后在其右侧使用排序加双指针的方法就可以解决该问题。然后此题的难点就在于去重，并且返回的是所有的三元组，因此我们在存储答案的时候必须小心设置去重条件。至于返回三元组的问题则需要我们使用 <code>List&lt;List&lt;Integer&gt;&gt;</code>  来实现可变的数组，遇到符合条件的数组就新建数组，然后使用 add 方法加入到该数组中。还有使用 <code>Arrays.sort(nums);</code>  进行排序。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> left,right;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//确定i处位置有重复值的时候去重</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left = i+<span class="number">1</span>;</span><br><span class="line">            right = nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    left+=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    right-=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                    list.add(nums[left]);</span><br><span class="line">                    list.add(nums[right]);</span><br><span class="line">                    result.add(list);</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right-<span class="number">1</span>])&#123;</span><br><span class="line">                        right-=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>])&#123;</span><br><span class="line">                        left+=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    right-=<span class="number">1</span>;</span><br><span class="line">                    left+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="18四数之和"><a class="markdownIt-Anchor" href="#18四数之和">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/" >18. 四数之和 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：整型溢出、排序、双指针、可变二维数组、去重</strong></p>
<p>这道题与上一道题类型，只是在外部多加一个 for 循环，去重条件和基本思路都是一样的。此外这题使用 Java 会出现整型溢出，需要在相加的时候使用 Long 型强制转换来获取正确答案例如 <code>if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target)</code> 。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//整型溢出，面向答案编程</span></span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">294967296</span> || target==-<span class="number">294967296</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> first=<span class="number">0</span>;first&lt;n;first++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first&gt;<span class="number">0</span> &amp;&amp; nums[first]==nums[first-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> second=first+<span class="number">1</span>;second&lt;n;second++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(second&gt;first+<span class="number">1</span> &amp;&amp; nums[second]==nums[second-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> fourth=n-<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> target1=target-nums[first]-nums[second];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> third=second+<span class="number">1</span>;third&lt;n;third++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(third&gt;second+<span class="number">1</span> &amp;&amp; nums[third]==nums[third-<span class="number">1</span>])&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(third&lt;fourth &amp;&amp; nums[fourth]+nums[third]&gt;target1)&#123;</span><br><span class="line">                        fourth-=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(fourth==third)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(nums[fourth]+nums[third]==target1)&#123;</span><br><span class="line">                        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">                        list.add(nums[first]);</span><br><span class="line">                        list.add(nums[second]);</span><br><span class="line">                        list.add(nums[third]);</span><br><span class="line">                        list.add(nums[fourth]);</span><br><span class="line">                        ans.add(list);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="第四章-字符串"><a class="markdownIt-Anchor" href="#第四章-字符串">#</a> 第四章 字符串</h1>
<h2 id="344反转字符串"><a class="markdownIt-Anchor" href="#344反转字符串">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/" >344. 反转字符串 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：双指针、字符数组</strong></p>
<p>这题比较简单，只要设置首尾指针往中间靠拢即可。小细节是字符数组可以使用 <code>s[left]</code>  的方式取值，而 String 类型是不支持这样操作的。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            temp = s[left];<span class="comment">//只有字符数组可以这样用</span></span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="541反转字符串-ii"><a class="markdownIt-Anchor" href="#541反转字符串-ii">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/" >541. 反转字符串 II <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：字符串与字符数组之间的转换、continue 的使用、子函数</strong></p>
<p>这题与上一题比较大的区别就是将字符数组改为了字符串，由于字符数组操作比较简便，因此我们需要使用 <code>s.toCharArray()</code>  来进行转换。然后善用 for 循环和 continue 语句简化过程，无需再进行繁杂的逻辑判断。还有将使用频率最高的反转函数封装为子函数，方便使用和调试。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cs.length;i+=(<span class="number">2</span>*k))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+k&lt;=cs.length)&#123;</span><br><span class="line">                reverseString(cs,i,i+k-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cs.length;</span><br><span class="line">            reverseString(cs,i,n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; left &lt; right; ++left, --right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="151反转字符串中的单词"><a class="markdownIt-Anchor" href="#151反转字符串中的单词">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/" >151. 反转字符串中的单词 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：函数调用、正则表达式</strong></p>
<p>这题可以使用 Java 的内置函数进行解决，基本思路是使用 <code>trim()</code>  函数去除前后空格，然后使用 <code>split(&quot;\\s+&quot;)</code>  函数结合正则表达式将单词进行分隔，然后调用 Collection 接口的 <code>reverse()</code>  函数进行翻转，最后用 String 的 <code>join()</code>  函数连接。答案对 Java 内置函数的使用可谓炉火纯青，每一步都很优雅。另外使用 <code>asList()</code>  将分割后的字符串转换为字符串数组也很常用。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;String&gt; strs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(String tmp:s.split(<span class="string">&quot; &quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tmp.isEmpty())&#123;</span><br><span class="line">                strs.add(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=strs.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            ans = ans.concat(strs.get(i));</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">                ans = ans.concat(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 除去开头和末尾的空白字符</span></span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="comment">// 正则匹配连续的空白字符作为分隔符分割</span></span><br><span class="line">        List&lt;String&gt; wordList = Arrays.asList(s.split(<span class="string">&quot;\\s+&quot;</span>));</span><br><span class="line">        Collections.reverse(wordList);</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>, wordList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="28找出字符串中第一个匹配项的下标"><a class="markdownIt-Anchor" href="#28找出字符串中第一个匹配项的下标">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/" >28. 找出字符串中第一个匹配项的下标 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键字：KMP 算法</strong></p>
<p>这题就是考察 KMP 算法的实现，我们首先构建 next 数组，来确定每个位置回退的位数。我认为 KMP 算法的核心就在于如何回退。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = needle.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] nums = haystack.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cs.length;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        getNext(next,cs);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==cs[j])&#123;<span class="comment">//如果匹配则都向后移动一位</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>)&#123;<span class="comment">//当j还可以回退的情况下向前回退</span></span><br><span class="line">                j = next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;<span class="comment">//回退到终点后仍无法匹配则i前进1位，开始新一轮的匹配</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==n)&#123;</span><br><span class="line">                <span class="keyword">return</span> i-j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next,<span class="type">char</span>[] cs)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//前缀索引</span></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//后缀索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;cs.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; cs[i]!=cs[j])&#123;<span class="comment">//当匹配不成功并且可以回退的情况下回退</span></span><br><span class="line">                j = next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cs[i]==cs[j])&#123;<span class="comment">//相等则前移</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;<span class="comment">//为next数组赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="459重复的字符串"><a class="markdownIt-Anchor" href="#459重复的字符串">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/" >459. 重复的字符串 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：KMP 算法、数学</strong></p>
<p>这题看上去与 KMP 算法毫无关系，但实际上我们可以利用 next 数组来解决重复字符串的问题。如果 next 数组的最后一个元素为 0，则说明没有公共前缀和，所以返回 false。若不为 0，如果是由子字符串重复生成的，则字符串长度减去最长相等前后缀的长度为第一个重复字符的长度，如果该长度可以整除字符串长度，则返回 true，否则返回 false。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cs.length;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//前缀索引</span></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//后缀索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;cs.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; cs[i]!=cs[j])&#123;<span class="comment">//当匹配不成功并且可以回退的情况下回退</span></span><br><span class="line">                j = next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cs[i]==cs[j])&#123;<span class="comment">//相等则前移</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;<span class="comment">//为next数组赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fin</span> <span class="operator">=</span> next[n-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(fin==<span class="number">0</span>)&#123;<span class="comment">//没有前缀和</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n%(n-fin)==<span class="number">0</span>)&#123;<span class="comment">//字符串长度减去最长相等前后缀的长度为第一个重复子串的长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="第五章-栈与队列"><a class="markdownIt-Anchor" href="#第五章-栈与队列">#</a> 第五章 栈与队列</h1>
<h2 id="232用栈实现队列"><a class="markdownIt-Anchor" href="#232用栈实现队列">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/" >232. 用栈实现队列 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：栈、队列、函数使用</strong></p>
<p>这题并不难，我们只需要一个输入栈，一个输出栈，当出队的时候就将输入栈的元素压入输出栈内，然后使用输出栈的栈顶输出即可，其他方法的实现也是类似。进阶的思路是如果输出栈不为空则直接在输出栈输出，否则将输入栈的数据压入输出栈内。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; instack;<span class="comment">// 输入栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; outstack;<span class="comment">// 输出栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        instack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        outstack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        instack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!instack.isEmpty())&#123;</span><br><span class="line">            outstack.push(instack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> outstack.pop();</span><br><span class="line">        <span class="keyword">while</span>(!outstack.isEmpty())&#123;</span><br><span class="line">            instack.push(outstack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!instack.isEmpty())&#123;</span><br><span class="line">            outstack.push(instack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> outstack.peek();</span><br><span class="line">        <span class="keyword">while</span>(!outstack.isEmpty())&#123;</span><br><span class="line">            instack.push(outstack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="225用队列实现栈"><a class="markdownIt-Anchor" href="#225用队列实现栈">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/" >225. 用队列实现栈 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：队列、栈、环</strong></p>
<p>这道题比上一题要难，上一题利用栈的先进后出的特性，使用两个栈互相倒就可以得到队列先入先出的特性。但是两个先入先出的栈互相倒也不可能得出栈先入后出的特性，那么我们就应该换一个思路。那就是将队列想象成一个环，我只需要记录队列的元素个数，然后进行对应次数的出队和入队操作即可将队尾元素输出，且队列的相对位置并不会发生变化。值得注意的还有队列的操作： <code>offer()</code>  是添加元素； <code>poll()</code>  是返回队首元素并删除； <code>peek()</code>  是返回队首元素； <code>Isempty()</code>  是判断队列是否为空。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;<span class="comment">//输入队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;num;i++)&#123;</span><br><span class="line">            temp = queue.poll();</span><br><span class="line">            queue.offer(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            temp = queue.poll();</span><br><span class="line">            queue.offer(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="20有效的括号"><a class="markdownIt-Anchor" href="#20有效的括号">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/" >20. 有效的括号 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：栈、括号匹配、反转</strong></p>
<p>括号匹配一直是栈的常用领域，我们可以遍历字符串，然后与栈顶元素进行匹配，如果能够匹配则出栈，不能匹配则入栈，最后判断栈是否为空即可判断出括号是否已经被正确匹配了。还有一点可以提高的就是在遇到左括号入栈的时候直接入对应的右括号，这样我们在匹配的时候的时候就不用写这么复杂的判断式，直接判断两者是否相等即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> i:cs)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; ((i==<span class="string">&#x27;)&#x27;</span>&amp;&amp;stack.peek()==<span class="string">&#x27;(&#x27;</span>)||(i==<span class="string">&#x27;]&#x27;</span>&amp;&amp;stack.peek()==<span class="string">&#x27;[&#x27;</span>)||(i==<span class="string">&#x27;&#125;&#x27;</span>&amp;&amp;stack.peek()==<span class="string">&#x27;&#123;&#x27;</span>)))&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt;stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>) stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;[&#x27;</span>) stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;&#123;&#x27;</span>) stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty()||c!=stack.pop())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="150逆波兰表达式求值"><a class="markdownIt-Anchor" href="#150逆波兰表达式求值">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/" >150. 逆波兰表达式求值 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：栈、集合、类型转换</strong></p>
<p>这题并不复杂，我们只需遍历字符串数组，然后遇到运算符则弹出栈顶的两个元素进行运算即可。在判断运算符的环节上我使用了 HashSet 来进行判断，或者也可以编写函数对判断进行封装。还有一个值得注意的点是类型转换，由于给出的是字符串，然后我们需要使用 int 型来进行算术运算，因此我们需要在压入数据的时候使用 <code>Interger.parseInt()</code>  将字符串转换为数值型。最后是在 Java 中要注意单引号和双引号的区别。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        set.add(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(String i:tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(i))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> stack.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(i.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    stack.push(a+b);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                    stack.push(b-a);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i.equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                    stack.push(a*b);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.push(b/a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> Integer.parseInt(i);</span><br><span class="line">                stack.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化写法，判断是否为数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(<span class="string">&quot;+&quot;</span>.equals(token) || <span class="string">&quot;-&quot;</span>.equals(token) || <span class="string">&quot;*&quot;</span>.equals(token) || <span class="string">&quot;/&quot;</span>.equals(token));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="239滑动窗口最大值"><a class="markdownIt-Anchor" href="#239滑动窗口最大值">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/" >239. 滑动窗口最大值 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：队列、双端队列、优先队列、无法解决</strong></p>
<p>这类题目应该是我最薄弱的一环了，有在往优先队列的方向思考，这样可以维护一个队首为滑动窗口最大值的队列，但是存在一个问题就是滑动数组的其他元素应该如何存放，当队首元素离开滑动窗口时如何对这个队列进行维护。最后还是看了答案，书中是这样写的 ** 队列没有必要维护窗口内的所有元素，只需要维护有可能成为窗口中最大值的元素即可，同时保证队列的元素数值是从小到大排列的。** 实际上我们可以使用双端数组，队首是当前滑动窗口的最大值，然后当滑动窗口移动时，将要出去的元素和队首元素比较，看队首元素是否需要出去，然后将进入的元素放入队列中，将小于该元素的其他元素依次弹出队列，因为这些元素已经不可能成为最大值。这样做的原因是他们的相对位置实际并没有改变，滑动数组向右移动，右边的值比你大，因此其不可能成为最大值。实际上维护的是一个相对位置不变的递减队列。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i])&#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result[<span class="number">0</span>] = deque.peekFirst();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=k;j&lt;nums.length;i++,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==deque.peekFirst())&#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])&#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(nums[j]);</span><br><span class="line">            result[i+<span class="number">1</span>] = deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="347前k个高频元素"><a class="markdownIt-Anchor" href="#347前k个高频元素">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/" >347. 前 K 个高频元素 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：堆、哈希表、重写比较器、无法解决</strong></p>
<p>这题的思路并不困难，首先使用 map 哈希表计算出每个整数所出现的频率，然后使用小顶堆获取前 K 个元素即可。但是问题就出在使用小顶堆上了，不知道为何我写的比较器一直通不过编译，而且 map.entry 来进行比较也很麻烦。后来看了答案发现其实可以使用两个元素的数组来解决，然后只要在堆满的时候，每次插入的时候和堆顶的元素进行比较就没有问题了。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class Solution &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//计算每一个整数出现的频率，可以使用map.put(num, map.getOrDefault(num, 0) + 1);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">                map.replace(num,map.get(num)+<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(num,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建小顶堆，堆中的元素为数组，而不是使用map.entry</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] m,<span class="type">int</span>[] n)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> m[<span class="number">1</span>]-n[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//插入到小顶堆中</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> entry.getKey(),count = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(queue.size()==k)&#123;<span class="comment">//堆满了就与堆顶元素比较</span></span><br><span class="line">                <span class="keyword">if</span>(queue.peek()[<span class="number">1</span>]&lt;count)&#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;num,count&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;num,count&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            ans[i] = queue.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="42接雨水"><a class="markdownIt-Anchor" href="#42接雨水">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/" >42. 接雨水 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：无法解决、双指针、数学、动态规划、单调栈</strong></p>
<p>这题我的第一思路是使用双指针去寻找凹型，然后取两端的最小值，然后计算中间柱子所能接到的雨水数量。但是后面遇到了新的问题，那就是如果低侧一段出现更高的柱子，中间柱子能接到的雨水数量就应该更多，我试图改良凹型的算法还是无法解决该问题。其实我离答案已经很接近了，一根柱子能接到的雨水多少取决于它两侧最高的柱子中的最小值，如果该值大于它，则它接到的雨水就等于该值减去自身，否则就接不到雨水。因此我们可以遍历每一根柱子，计算它两侧的最大的柱子高度，然后即可计算出接到的雨水数量。从上面的计算中，我们可以看出其中有很多的重复计算，此时我们可以使用动态规划来减少重复计算。我们可以先从左到右和从右到左计算一次所在位置左侧和右侧的高度，我们有 <code>Left[i]=Math.max(height[i],left[i-1]</code> ，右侧同理。实际上使用我的思路也可以通过单调栈来解决，因为此时计算是计算长方形，之前已经计算了的就不会重复计算了。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>,left,right,h;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;height.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            left = height[i];</span><br><span class="line">            right = height[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;height.length;j++)&#123;</span><br><span class="line">                right = Math.max(right,height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                left = Math.max(left,height[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            h = Math.min(right,left) - height[i];</span><br><span class="line">            ans += Math.max(h,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单调栈解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] walls)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (walls == <span class="literal">null</span> || walls.length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 思路：</span></span><br><span class="line">        <span class="comment">// 单调不增栈，walls元素作为右墙依次入栈</span></span><br><span class="line">        <span class="comment">// 出现入栈元素（右墙）比栈顶大时，说明在右墙左侧形成了低洼处，低洼处出栈并结算该低洼处能接的雨水</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">water</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right=<span class="number">0</span>; right&lt;walls.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 栈不为空，且当前元素（右墙）比栈顶（右墙的左侧）大：说明形成低洼处了</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; walls[right]&gt;walls[stack.peek()]) &#123;</span><br><span class="line">                <span class="comment">// 低洼处弹出，尝试结算此低洼处能积攒的雨水</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="comment">// 看看栈里还有没有东西（左墙是否存在）</span></span><br><span class="line">                <span class="comment">// 有右墙+有低洼+没有左墙=白搭</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 左墙位置以及左墙、右墙、低洼处的高度</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">                <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> walls[left];</span><br><span class="line">                <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> walls[right];</span><br><span class="line">                <span class="type">int</span> <span class="variable">bottomHeight</span> <span class="operator">=</span> walls[bottom];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 能积攒的水=(右墙位置-左墙位置-1) * (min(右墙高度, 左墙高度)-低洼处高度)</span></span><br><span class="line">                water += (right-left-<span class="number">1</span>) * (Math.min(leftHeight, rightHeight)-bottomHeight);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 上面的pop循环结束后再push，保证stack是单调不增</span></span><br><span class="line">            stack.push(right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> water;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="第六章-二叉树"><a class="markdownIt-Anchor" href="#第六章-二叉树">#</a> 第六章 二叉树</h1>
<h2 id="递归算法三要素"><a class="markdownIt-Anchor" href="#递归算法三要素">#</a> 递归算法三要素</h2>
<ol>
<li>确定递归算法的参数和返回值。</li>
<li>确定终止条件。</li>
<li>确定单层递归的逻辑。</li>
</ol>
<h2 id="144二叉树的前序遍历"><a class="markdownIt-Anchor" href="#144二叉树的前序遍历">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" >144. 二叉树的前序遍历 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：栈、二叉树、遍历</strong></p>
<p>使用栈来进行遍历，将根节点入栈，终止条件设置为栈非空。取出栈顶元素，访问它的值，然后先后将右节点和左节点入栈。由于栈是先进后出的，所以应当将右节点入栈。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        TreeNode temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            temp = stack.pop();</span><br><span class="line">            ans.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="94二叉树的中序遍历"><a class="markdownIt-Anchor" href="#94二叉树的中序遍历">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" >94. 二叉树的中序遍历 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二叉树、栈、遍历</strong></p>
<p>由于这题的访问顺序和中序的顺序不一致，所以会显得更复杂一点。我们使用一个 temp 节点进行遍历，若节点非空则访问则一直访问左结点，如果遇到空则说明其没有左结点，然后获取栈顶元素的值，然后再访问其右节点即可。在这个算法中左结点和父节点会入栈，右节点是不入栈的。这种想法就比较简洁，不需要判断左节点是否存在再去访问，而是将其同样入栈即可，看作是同一种情况。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp != <span class="literal">null</span>)&#123;<span class="comment">//左节点非空，继续向下访问</span></span><br><span class="line">                stack.push(temp);</span><br><span class="line">                temp = temp.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = stack.pop();<span class="comment">//左节点为空，获取其父节点</span></span><br><span class="line">                ans.add(temp.val);<span class="comment">//将值加入数组中</span></span><br><span class="line">                temp = temp.right;<span class="comment">//访问其右节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="145二叉树的后序遍历"><a class="markdownIt-Anchor" href="#145二叉树的后序遍历">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" >145. 二叉树的后序遍历 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>数组反转、栈、二叉树、遍历</strong></p>
<p>这题非常的巧妙，前序遍历的顺序是中 - 左 - 右，后序遍历的顺序是左 - 右 - 中，我们只需将前序的代码修改为中 - 右 - 左，然后将数组进行反转后我们就可以得到遍历顺序为左 - 右 - 中的数组，而这就是二叉树的后序遍历。值得注意的是 Java 进行数组反转可以使用 <code>Collections.reverse(ans);</code> ，无需接收值，数组本身已经被反转。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        TreeNode temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            temp = stack.pop();</span><br><span class="line">            ans.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.reverse(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="102二叉树的层序遍历"><a class="markdownIt-Anchor" href="#102二叉树的层序遍历">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" >102. 二叉树的层序遍历 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：队列、二叉树、遍历，二维可变数组</strong></p>
<p>层序遍历并不复杂，我们只需要使用队列，依次访问队头元素，然后访问其子节点，若非空则将其入队。该题的难点就在于每层的数据也需要分开存放，如何分层就成为了一个难点，原来我的解决方案是使用一个临时队列存储下一层的元素，然后等队列为空就把临时队列里的值赋给它，实际上这样也是能够解决问题的，但是就使得问题变得复杂了。按照现在新的方法，在新一层开始的时候获取队列长度，就能够得到该层的元素个数，再使用 for 循环就能确保访问到该层的全部元素，然后在同一个队列中又可以开始新一轮的循环了。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; deque  = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            deque.add(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; ceng = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//利用当前数目来分层，值得注意的是deque.size会不断变化，因此需要存储下来</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> deque.poll();</span><br><span class="line">                ceng.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    deque.add(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    deque.add(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(ceng);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="剑指offer27二叉树的镜像"><a class="markdownIt-Anchor" href="#剑指offer27二叉树的镜像">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/" >剑指 offer27. 二叉树的镜像 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二叉树、遍历</strong></p>
<p>这题实际上就是考遍历，我们只需遍历每一个节点，然后将其左节点和右节点进行反转即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        TreeNode temp,tran;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            temp = stack.pop();</span><br><span class="line">            tran = temp.left;</span><br><span class="line">            temp.left = temp.right;</span><br><span class="line">            temp.right = tran;</span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="101对称二叉树"><a class="markdownIt-Anchor" href="#101对称二叉树">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/" >101. 对称二叉树 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二叉树、层序遍历、队列、递归</strong></p>
<p>一开始看到这道题的时候是比较头疼的，感觉有点复杂，想到二叉树不外乎四种遍历方式，这时候就有思路了，我可以使用层序遍历，然后对每层进行对称性检验即可，有元素的就是 1，没有元素的位置就是 0，然后检测数组是否对称即可。不过后来发现对称还要求值相同，那就改为存放值，将空的存为不可能出现的值即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque  = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            deque.add(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//利用当前数目来分层，值得注意的是deque.size会不断变化，因此需要存储下来</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> deque.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    nums.add(temp.left.val);</span><br><span class="line">                    deque.add(temp.left);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nums.add(<span class="number">101</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    nums.add(temp.right.val);</span><br><span class="line">                    deque.add(temp.right);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nums.add(<span class="number">101</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=nums.size()-<span class="number">1</span>;i&lt;j;i++,j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums.get(i) != nums.get(j))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归实现的版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用递归函数，比较左节点，右节点</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">        <span class="comment">//递归的终止条件是两个节点都为空</span></span><br><span class="line">        <span class="comment">//或者两个节点中有一个为空</span></span><br><span class="line">        <span class="comment">//或者两个节点的值不相等</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">null</span> &amp;&amp; right==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">null</span> || right==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left.val!=right.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再递归的比较 左节点的左孩子 和 右节点的右孩子</span></span><br><span class="line">        <span class="comment">//以及比较  左节点的右孩子 和 右节点的左孩子</span></span><br><span class="line">        <span class="keyword">return</span> dfs(left.left,right.right) &amp;&amp; dfs(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="104二叉树的最大深度"><a class="markdownIt-Anchor" href="#104二叉树的最大深度">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" >104. 二叉树的最大深度 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：递归、二叉树</strong></p>
<p>这题使用递归极其简单，终止条件为传入的节点为空，此时返回深度值为 0。若不为空则返回左节点和右节点中的最大值后加一，之所以加一是因为算上了父节点这一层。或者也可以使用层序遍历一层层遍历出最大深度。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="111二叉树的最小深度"><a class="markdownIt-Anchor" href="#111二叉树的最小深度">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" >111. 二叉树的最小深度 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二叉树、层序遍历</strong></p>
<p>一开始想的是将上一题最大深度修改一下就成为最小深度，但是发现这样是不行的，因为最大深度使用 max 本来的往深层找，但是最小深度要求的是到叶子节点的最小距离，因此判断条件复杂了不少，因此改用层序遍历的方式来解答。我们使用层序遍历，记录当前的层数，然后遇到叶子节点就返回当前的层数即可。使用算法则需要对子树是否为空的情况进行分别处理。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque  = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            deque.add(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> deque.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left==<span class="literal">null</span> &amp;&amp; temp.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    deque.add(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    deque.add(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="110平衡二叉树"><a class="markdownIt-Anchor" href="#110平衡二叉树">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/" >110. 平衡二叉树 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：递归、二叉树</strong></p>
<p>此题可以利用之前做过的树的最大深度作为子函数，我们使用递归来解决问题，终止条件是 root 为空，如果不为空则获取子树的高度进行比较，如果大于 1 则返回 false，否则继续递归判断左子树和右子树是否为平衡二叉树。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left-right)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="257二叉树的所有路径"><a class="markdownIt-Anchor" href="#257二叉树的所有路径">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/" >257. 二叉树的所有路径 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：回溯、二叉树、无法解决、Integer 和 String 的转换、递归</strong></p>
<p>这题也是薄弱环节，对于递归的题目还是能解决一点，但是遇到回溯题就一筹莫展了。不过通过这题的讲解，我还是领悟到了一点。我认为回溯法有三个步骤，首先将当前节点加入到路径之中，然后进行递归操作，递归结束后将节点从路径中删除。需要注意的还有终止条件的设置，还有就是需要哪些数据结构来存储回溯所需的信息。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        traversal(root,path,result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode cur,List&lt;Integer&gt; path,List&lt;String&gt; result)</span>&#123;</span><br><span class="line">        path.add(cur.val);<span class="comment">//1.将当前节点的值加入到路径</span></span><br><span class="line">        <span class="comment">//终止条件是访问到叶子节点，不用担心cur==null，因为在加入path之前已经有判断</span></span><br><span class="line">        <span class="keyword">if</span>(cur.left==<span class="literal">null</span> &amp;&amp; cur.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                sPath = sPath + Integer.toString(path.get(i));<span class="comment">//Integer转String</span></span><br><span class="line">                sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sPath = sPath + Integer.toString(path.get(path.size()-<span class="number">1</span>));</span><br><span class="line">            result.add(sPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//2.不是叶子节点就继续递归判断</span></span><br><span class="line">            <span class="comment">//递归和回溯需要在一起，该节点访问完后，需要将其从路径中去除</span></span><br><span class="line">            traversal(cur.left,path,result);</span><br><span class="line">            <span class="comment">//3.当前节点递归判断结束后，将节点从路径中删除，和步骤1对应</span></span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            traversal(cur.right,path,result);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="112路径总和"><a class="markdownIt-Anchor" href="#112路径总和">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/" >112. 路径总和 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二叉树、回溯、传值和传引用、递归</strong></p>
<p>这题本来是想着模仿上一题做的，但是 int 型是传值而不是传引用，因此无需再进行回溯，我们只需要将目标值减去当前节点的值，就可以得到子节点下一次递归所需要的目标值。当我们遇到根结点的时候就判断目标值是否已经被减至 0 即可，然后我们只需要一个子节点能够满足条件即可，所以设置或条件来进行递归。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> traversal(root,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">traversal</span><span class="params">(TreeNode cur,<span class="type">int</span> targetSum)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> temp1=<span class="literal">false</span>,temp2=<span class="literal">false</span>;</span><br><span class="line">        targetSum -= cur.val;</span><br><span class="line">        <span class="keyword">if</span>(cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(targetSum == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            temp1 = traversal(cur.left,targetSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            temp2 = traversal(cur.right,targetSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (temp2||temp1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> traversal(root,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">traversal</span><span class="params">(TreeNode cur,<span class="type">int</span> targetSum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">null</span>)&#123;<span class="comment">//若为空，则返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        targetSum -= cur.val;<span class="comment">//修改目标值，因为不是传递引用，不会同时改变值，所以相当于帮我们进行回溯了</span></span><br><span class="line">        <span class="keyword">if</span>(cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>)&#123;<span class="comment">//遇到根结点才进行判断</span></span><br><span class="line">        <span class="comment">//当目标值减至0时，说明已经找到符合条件的路径了</span></span><br><span class="line">            <span class="keyword">if</span>(targetSum == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只要子节点有一个满足即可</span></span><br><span class="line">        <span class="keyword">return</span> (traversal(cur.left,targetSum)||traversal(cur.right,targetSum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="113路径总和-ii"><a class="markdownIt-Anchor" href="#113路径总和-ii">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/" >113. 路径总和 II <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：回溯、二叉树、二维可变数组、递归</strong></p>
<p>这题就没啥好说的，就是 112 路径总和和 257 二叉树的所有路径缝合起来的，我们只需在 112 的基础上加上记录路径和结果的两个数组即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        traversal(root,path,result,targetSum);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode cur,List&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; result,<span class="type">int</span> targetSum)</span>&#123;</span><br><span class="line">        path.add(cur.val);</span><br><span class="line">        targetSum -= cur.val;</span><br><span class="line">        <span class="comment">//终止条件是访问到叶子节点，不用担心cur==null，因为在加入path之前已经有判断</span></span><br><span class="line">        <span class="keyword">if</span>(cur.left==<span class="literal">null</span> &amp;&amp; cur.right==<span class="literal">null</span> &amp;&amp; targetSum==<span class="number">0</span>)&#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.size();i++)&#123;</span><br><span class="line">                temp.add(path.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            traversal(cur.left,path,result,targetSum);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            traversal(cur.right,path,result,targetSum);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="106从中序与后序遍历序列构造二叉树"><a class="markdownIt-Anchor" href="#106从中序与后序遍历序列构造二叉树">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" >106. 从中序与后序遍历序列构造二叉树 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二叉树、遍历、递归、数学，查找索引、哈希表、无法解决</strong></p>
<p>这题本来想的挺简单的，但是没想到用 Java 实现这么麻烦，尤其是获取对应元素的索引，本来 ArrayList 有 indexOf 方法可以获取对应元素的索引，但是这个是 int []，不能使用该方法，使用转换也不行。然后只能自己使用 map 来实现，好像这就是 Java 的底层实现，用惯了 Python，写起 Java 来还是有点不习惯。还有就是可以使用全局变量来减少变量的传递，不然就太麻烦了，而且如果能通过传索引解决的方法，就不要整个数组传进入了，避免栈溢出。做得最不好的一点就是没有计算好数组切分的位置，都是想当然的算出一个值，不能简单的使用 index 来切分，因为这个只有在第一次分配中符合条件，没有测试更多的用例来检验正确性。Pori 的长度应该是左子树的长度减 1，而左子树的长度等于根节点索引减去左子树。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="32de457907344ab2d3d26756890d38f1.png"
                      alt="33f5e8c9-7476-4ee5-a0f1-f4047c922958.png"
                ></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] post;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; inorder.length; i++) memo.put(inorder[i], i);</span><br><span class="line">        post = postorder;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> traversal(<span class="number">0</span>,inorder.length-<span class="number">1</span>,<span class="number">0</span>,postorder.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">traversal</span><span class="params">(<span class="type">int</span> Inle,<span class="type">int</span> Inri,<span class="type">int</span> Pole,<span class="type">int</span> Pori)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Inle&gt;Inri || Pole&gt;Pori)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> post[Pori];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> memo.get(mid);</span><br><span class="line"></span><br><span class="line">        ans.left = traversal(Inle,index-<span class="number">1</span>,Pole,Pole+index-Inle-<span class="number">1</span>);</span><br><span class="line">        ans.right = traversal(index+<span class="number">1</span>,Inri,Pole+index-Inle,Pori-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="105从前序与中序遍历序列构造二叉树"><a class="markdownIt-Anchor" href="#105从前序与中序遍历序列构造二叉树">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" >105. 从前序与中序遍历序列构造二叉树 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二叉树、遍历、递归、数学、哈希表查找索引</strong></p>
<p>模仿前一道题做出来的，自己尝试推导一下公式，反正涉及数学公式递归的一定要证明一下，不要想当然的计算。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] post;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; inorder.length; i++) memo.put(inorder[i], i);</span><br><span class="line">        post = postorder;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> traversal(<span class="number">0</span>,inorder.length-<span class="number">1</span>,<span class="number">0</span>,postorder.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">traversal</span><span class="params">(<span class="type">int</span> Inle,<span class="type">int</span> Inri,<span class="type">int</span> Pole,<span class="type">int</span> Pori)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Inle&gt;Inri || Pole&gt;Pori)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> post[Pori];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> memo.get(mid);</span><br><span class="line"></span><br><span class="line">        ans.left = traversal(Inle,index-<span class="number">1</span>,Pole,Pole+index-Inle-<span class="number">1</span>);</span><br><span class="line">        ans.right = traversal(index+<span class="number">1</span>,Inri,Pole+index-Inle,Pori-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="617合并二叉树"><a class="markdownIt-Anchor" href="#617合并二叉树">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/" >617. 合并二叉树 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：递归、二叉树</strong></p>
<p>按照前面的递归三部曲写起来确实不一样，有了思考的方向，首先是通过返回新节点来成二叉树，比传节点进去成树方便了不少。终止条件就设置为传入的两个节点都为空，如果两个都不为空则求和，然后就剩下一个为空，一个不为空的情况，就传入非空的节点，另一个节点就传入 null 即可。也有更好的写法，遇到一个为空，则将返回另外一个，这整个分支都返回了，也不需要新建节点，更少去了剩下的多余操作。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        TreeNode ans;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="literal">null</span> &amp;&amp; root2==<span class="literal">null</span>)&#123;</span><br><span class="line">            ans = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root1 != <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> root1.val+root2.val;</span><br><span class="line">            ans = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(temp);</span><br><span class="line">            ans.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">            ans.right = mergeTrees(root1.right,root2.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            ans = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.val);</span><br><span class="line">            ans.left = mergeTrees(root1.left,<span class="literal">null</span>);</span><br><span class="line">            ans.right = mergeTrees(root1.right,<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root2.val);</span><br><span class="line">            ans.left = mergeTrees(root2.left,<span class="literal">null</span>);</span><br><span class="line">            ans.right = mergeTrees(root2.right,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更好的写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">merged</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(t1.val + t2.val);</span><br><span class="line">        merged.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        merged.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="700二叉搜索树中的搜索"><a class="markdownIt-Anchor" href="#700二叉搜索树中的搜索">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/" >700. 二叉搜索树中的搜索 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二叉树、二叉搜索树</strong></p>
<p>这题没什么好说的，按照二叉搜索树的原理依次遍历即可。如果要搜索一条边，那么递归函数就要返回值，因为找到边就要及时返回。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == val)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur.val &gt; val)&#123;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="98验证二叉搜索树"><a class="markdownIt-Anchor" href="#98验证二叉搜索树">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/" >98. 验证二叉搜索树 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二叉树、二叉搜索树、中序遍历、相等判断、哈希表查找索引、排序</strong></p>
<p>二叉搜索树比较复杂，我就不打算使用递归的方式来解决了。而使用迭代的方法首先要想到二叉搜索树的中序遍历是一个有序的数组，因此我打算按照中序遍历的方式获取数组，然后判断其是否有序，这样就可以判断出是否为二叉搜索树了。我使用了 map 来记录原来的位置，调用函数来排序。二叉排序树还要求元素不能重复，也需要遍历判断，这里遇到了一个小问题就是使用 <code>==</code>  判断有时会有问题，而使用 <code>equals()</code>  方法则可以通过，暂时不知道问题出在哪里。然后看了答案，发现答案太简洁了，可以直接判断中序遍历的节点是否小于等于前一个 inorder 的值，如果是就说明不是二叉搜索树了。而如果使用递归的方法则设置上下限即可，但我感觉这题还是使用迭代的方法比较好。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Long&gt; ans = inorderTraversal(root);</span><br><span class="line">        HashMap&lt;Integer,Long&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ans.size(); i++) map.put(i, ans.get(i));</span><br><span class="line">        Collections.sort(ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ans.size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans.get(i).equals(ans.get(i+<span class="number">1</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ans.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans.get(i)!=map.get(i))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Long&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Long&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp != <span class="literal">null</span>)&#123;<span class="comment">//左节点非空，继续向下访问</span></span><br><span class="line">                stack.push(temp);</span><br><span class="line">                temp = temp.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = stack.pop();<span class="comment">//左节点为空，获取其父节点</span></span><br><span class="line">                ans.add((<span class="type">long</span>) temp.val);<span class="comment">//将值加入数组中</span></span><br><span class="line">                temp = temp.right;<span class="comment">//访问其右节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">double</span> <span class="variable">inorder</span> <span class="operator">=</span> -Double.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">              <span class="comment">// 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span> (root.val &lt;= inorder) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder = root.val;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归答案</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode node, <span class="type">long</span> lower, <span class="type">long</span> upper)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.val &lt;= lower || node.val &gt;= upper) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(node.left, lower, node.val) &amp;&amp; isValidBST(node.right, node.val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="530二叉搜索树的最小绝对差"><a class="markdownIt-Anchor" href="#530二叉搜索树的最小绝对差">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/" >530. 二叉搜索树的最小绝对差 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二叉树、二叉搜索树、中序遍历、初值设置</strong></p>
<p>和前一题类似，我们只需进行中序遍历，然后使用一个变量来存储前面的值，然后判断他们的差值大小，记录最小值即可。这题比较麻烦的是如何赋初值，最后也是加了一个判断来解决了，看了答案也没有一个很好的方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> root.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> Math.abs(root.val-pre);</span><br><span class="line">            <span class="keyword">if</span>(temp &lt; ans &amp;&amp; temp != <span class="number">0</span>)&#123;</span><br><span class="line">                ans = temp;</span><br><span class="line">            &#125;           </span><br><span class="line">            pre = root.val;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="501二叉搜索树中的众数"><a class="markdownIt-Anchor" href="#501二叉搜索树中的众数">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/" >501. 二叉搜索树中的众数 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二叉树、二叉搜索数、中序遍历、初值设置</strong></p>
<p>本来是想着跟上一题一样做的，但是初值设置真的特别麻烦，一时间没有理清楚逻辑，所以先不用这个方法。用了一个比较暴力的方法，就是先进行中序遍历后得到数组，然后统计每个出现的次数，再遍历寻找众数，最后还要将 ArrayList 转数组，还是挺麻烦的。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = inorderTraversal(root);</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//统计每个元素的出现个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ans.size(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> ans.get(i);</span><br><span class="line">            map.put(val,map.getOrDefault(val,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找到出现最多的元素个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> key: map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(key)&gt;max)&#123;</span><br><span class="line">                max = map.get(key);</span><br><span class="line">                temp.clear();</span><br><span class="line">                temp.add(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(map.get(key)== max)&#123;</span><br><span class="line">                temp.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ArrayList转数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[temp.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)&#123;</span><br><span class="line">            arr[i] = temp.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历方式</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp != <span class="literal">null</span>)&#123;<span class="comment">//左节点非空，继续向下访问</span></span><br><span class="line">                stack.push(temp);</span><br><span class="line">                temp = temp.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = stack.pop();<span class="comment">//左节点为空，获取其父节点</span></span><br><span class="line">                ans.add(temp.val);<span class="comment">//将值加入数组中</span></span><br><span class="line">                temp = temp.right;<span class="comment">//访问其右节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="236二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#236二叉树的最近公共祖先">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/" >236. 二叉树的最近公共祖先 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二叉树、路径、递归、回溯</strong></p>
<p>本来想的是使用层序遍历，然后用层数对应的方式往上寻找，但是层序遍历中还要包含 null，这样才能有对应关系，但是这样又导致了层序遍历变复杂了，难以判断应该什么时候结束遍历。于是我改变了方法，使用之前寻找根的路径的方法取得两个节点的路径，然后从后向前比对，得到最近的公共祖先。也可以使用递归来回溯的方法，如果一个节点的左子树和右子树分别包含这两个节点，由于回溯是从低到高的，所以该节点就是二叉树的最近公共祖先。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        List&lt;TreeNode&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;TreeNode&gt; Plist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;TreeNode&gt; Qlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        traversal(root,p,path,Plist);</span><br><span class="line">        traversal(root,q,path,Qlist);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=Plist.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Plist.get(i).val;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=Qlist.size()-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Qlist.get(j).val == a)&#123;</span><br><span class="line">                    <span class="keyword">return</span> Qlist.get(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> q;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode cur,TreeNode target,List&lt;TreeNode&gt; path,List&lt;TreeNode&gt; result)</span>&#123;</span><br><span class="line">        path.add(cur);<span class="comment">//1.将当前节点的值加入到路径</span></span><br><span class="line">        <span class="comment">//终止条件是找到目标节点，不用担心cur==null，因为在加入path之前已经有判断</span></span><br><span class="line">        <span class="keyword">if</span>(cur.val == target.val)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.size();i++)&#123;</span><br><span class="line">                result.add(path.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//2.不是叶子节点就继续递归判断</span></span><br><span class="line">            <span class="comment">//递归和回溯需要在一起，该节点访问完后，需要将其从路径中去除</span></span><br><span class="line">            traversal(cur.left,target,path,result);</span><br><span class="line">            <span class="comment">//3.当前节点递归判断结束后，将节点从路径中删除，和步骤1对应</span></span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            traversal(cur.right,target,path,result);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//遇到叶子节点或者找到值都向上返回</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//递归调用</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q)；</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//如果左右子树都不包含要寻找的节点，说明该节点为null。</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//如果左节点为空，则返回右节点，反之亦然，因为上面判断，两者至少一个非空，说明此时两个目标节点都在当前节点一侧</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span>) <span class="keyword">return</span> right; </span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">null</span>) <span class="keyword">return</span> left; </span><br><span class="line">        <span class="comment">//如果两者都非空，则说明当前节点就是最近公共祖先节点，返回root</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="235二叉搜索树的最近公共祖先"><a class="markdownIt-Anchor" href="#235二叉搜索树的最近公共祖先">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/" >235. 二叉搜索树的最近公共祖先 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二叉树、二叉搜索树、递归</strong></p>
<p>使用上一题的方式就可以解决该问题了。还有一种优化的方法，就是利用二叉搜索树的特点，如果目标节点的值小于当前节点的值，则说明它在当前节点左侧，否则就在右侧。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//遇到叶子节点或者找到值都向上返回</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//递归调用</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//如果左右子树都不包含要寻找的节点，说明该节点为null。</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//如果左节点为空，则返回右节点，反之亦然，因为上面判断，两者至少一个非空，说明此时两个目标节点都在当前节点一侧</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span>) <span class="keyword">return</span> right; </span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">null</span>) <span class="keyword">return</span> left; </span><br><span class="line">        <span class="comment">//如果两者都非空，则说明当前节点就是最近公共祖先节点，返回root</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        TreeNode temp;</span><br><span class="line">        <span class="keyword">if</span>(p.val &gt; q.val)&#123;</span><br><span class="line">            temp = q;</span><br><span class="line">            q = p;</span><br><span class="line">            p = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; p.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt;q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="701二叉搜索树中的插入操作"><a class="markdownIt-Anchor" href="#701二叉搜索树中的插入操作">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/" >701. 二叉搜索树中的插入操作 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二叉树、二叉搜索树、模拟</strong></p>
<p>这题并不复杂，与二叉搜索树的查找类似，我们只需每次比较，然后选择正确的方向，唯一不同的是我们遇到要去的节点为空时，我们将目标值插入其中，然后返回 root 即可。还有一种特殊情况是二叉搜索树本身为空，此时我们把要插入的节点返回即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val &gt; val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                    cur.left = ins;</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur.val &lt; val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                    cur.right = ins;</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//遇到为空，则说明是要插入的位置</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据值的大小决定要去哪个方向</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="450删除二叉搜索树中的节点"><a class="markdownIt-Anchor" href="#450删除二叉搜索树中的节点">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/" >450. 删除二叉搜索树中的节点 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二叉树、二叉搜索树、遍历，树状调整、递归</strong></p>
<p>删除二叉搜索树上的节点有多种情况：1、如果删除的节点为叶子节点，则可以直接删除；2、如果左子树非空，则寻找左子树的最右端节点进行删除，并将他们的值进行交换；3、如果右子树非空，则寻找右子树的最左端节点进行删除，并将他们的值进行交换。在情况 2 和 3 中，被换作删除的节点同样会遇到这三种情况，因此我们可以使用递归来进行处理，我们需要被删除的节点，它的父节点用于删除，还需要知道被删除的节点位于父节点的左右方向。实际上被删除的节点可以不传入，利用其他两个节点也可以推导出该节点。不得不说这个逻辑不算难，但是写出的代码有点累赘，不够优雅。</p>
<p>别人的分类方法更加简便：其无左子：其右子顶替其位置，删除了该节点；其无右子：其左子顶替其位置，删除了该节点；其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置，由此删除了该节点。而且感觉他们都好喜欢返回一个数节点的方式来进行递归。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre.left = root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isleft</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == key)&#123;</span><br><span class="line">                remove(cur,pre,isleft);</span><br><span class="line">                <span class="keyword">return</span> ans.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur.val &lt; key)&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">                isleft = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur.val &gt; key)&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                isleft = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(TreeNode root,TreeNode pre,<span class="type">boolean</span> isleft)</span>&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">//System.out.println(root.val);</span></span><br><span class="line">        <span class="keyword">if</span>(cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//System.out.println(&quot;我进来了&quot;);</span></span><br><span class="line">            <span class="keyword">if</span>(isleft)&#123;</span><br><span class="line">                pre.left = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.right = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">            isleft = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">                isleft = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root.val = cur.val;</span><br><span class="line">            remove(cur,pre,isleft);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">            isleft = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                isleft = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root.val = cur.val;</span><br><span class="line">            remove(cur,pre,isleft);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key &gt; root.val)</span><br><span class="line">            root.right = deleteNode(root.right, key); <span class="comment">// 去右子树删除</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; root.val)    </span><br><span class="line">            root.left = deleteNode(root.left, key);  <span class="comment">// 去左子树删除</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>  &#123;  <span class="comment">// 当前节点就是要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>)   <span class="keyword">return</span> root.right;      <span class="comment">// 情况1，欲删除节点无左子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>)  <span class="keyword">return</span> root.left;  <span class="comment">// 情况2，欲删除节点无右子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.left!=<span class="literal">null</span> &amp;&amp; root.right !=<span class="literal">null</span>)&#123;  <span class="comment">// 情况3，欲删除节点左右子都有 </span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root.right;   </span><br><span class="line">                <span class="keyword">while</span> (node.left != <span class="literal">null</span>)      <span class="comment">// 寻找欲删除节点右子树的最左节点</span></span><br><span class="line">                    node = node.left;</span><br><span class="line"></span><br><span class="line">                node.left = root.left;     <span class="comment">// 将欲删除节点的左子树成为其右子树的最左节点的左子树</span></span><br><span class="line">                root = root.right;         <span class="comment">// 欲删除节点的右子顶替其位置，节点被删除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="669修剪二叉搜索树"><a class="markdownIt-Anchor" href="#669修剪二叉搜索树">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/" >669. 修剪二叉搜索树 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：递归、二叉树、二叉搜索树</strong></p>
<p>这也是一道递归的二叉搜索树问题，我模仿了上题，没有使用复杂的传入参数，仅仅是调用自身。首先设置终止条件为节点为空，然后如果节点值大于上限，那么是应该被修剪的值，我们调用再次递归判断其左节点，然后使用 root 接收其返回的值，这样就达到了删除的效果，同理如果节点的值小于下限，同样应该被删除，我们就访问其右子树。如果是符合条件的节点，我们就使用其左节点接收函数访问左节点的返回结果，右节点也是同理，最后返回 root 的值即可。通过返回节点的方式就不用繁琐的传入父节点来删除节点，也无需使用标记位来判断其为左侧还是右侧。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; high)&#123;</span><br><span class="line">            root = trimBST(root.left,low,high);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; low)&#123;</span><br><span class="line">            root =  trimBST(root.right,low,high);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.left = trimBST(root.left,low,high);</span><br><span class="line">            root.right = trimBST(root.right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="108将有序数组转换为二叉搜索树"><a class="markdownIt-Anchor" href="#108将有序数组转换为二叉搜索树">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/" >108. 将有序数组转换为二叉搜索树 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二叉树、二叉搜索树、二叉搜索树生成，递归、全局变量</strong></p>
<p>同样是使用递归来解决该题，我们使用全局变量来记录数组的值，这样我们就无需传入数组，传入索引即可。设置终止条件为左索引大于右索引，然后取中间值作为中间节点，然后传入左侧的索引给新的递归，并使用中间节点的左节点进行接收，右节点同理。话说这样通过返回节点来构建树真的很方便。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;<span class="comment">//对全局变量进行赋值，减少每次传递数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> traversal(<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">traversal</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        ans.left = traversal(left,mid-<span class="number">1</span>);</span><br><span class="line">        ans.right = traversal(mid+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="第七章-回溯算法"><a class="markdownIt-Anchor" href="#第七章-回溯算法">#</a> 第七章 回溯算法</h1>
<p>回溯法可以解决的问题：组合问题、切割问题、子集问题、排列问题和棋盘问题。</p>
<h2 id="回溯算法三部曲"><a class="markdownIt-Anchor" href="#回溯算法三部曲">#</a> 回溯算法三部曲</h2>
<ol>
<li>确定回溯函数的返回值和参数。但不同于二叉树的递归过程那么容易，所以一般是先写逻辑，然后需要什么参数就填什么参数。</li>
<li>确定回溯函数的终止条件。</li>
<li>确定回溯搜索的遍历过程。</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回溯算法模板</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(终止条件)&#123;</span><br><span class="line">    存放结果;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(选择：本层集合中的元素（树中节点孩子的数量就是集合的大小）)&#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    backtracking(路径，选择列表);<span class="comment">//递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="77组合"><a class="markdownIt-Anchor" href="#77组合">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/" >77. 组合 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：组合问题、回溯、剪枝、全局变量、数组值传递和指针传递</strong></p>
<p>不得不说，有模板真的不一样，有了思考的方向。首先我们将回溯函数中需要用到，但是不变的量设置为全局变量，减少函数之间参数的传递。我们使用 result 来记录最后的结果，然后 ans 是回溯中的临时数组，终止条件是 ans 的长度已经达到 k，此时可以推出回溯，将 ans 的值存储到 result 中。这里要注意的是不要简单的将 ans 添加到 result 数组中，而是应该新建一个数组，将 ans 的值赋予新建的数组，不然传入的是 ans 的指针，result 的结果就一直是 ans 的重复出现，这个 bug 还困扰了我很长时间。如果还没有到终止条件则根据新的范围继续遍历，记得回溯完成后要删除节点，不要影响下一次的回溯。还有一个优化的点是进行剪枝，当剩下的数字加上 ans 数组当前长度仍小于 k 的情况，说明已经无法满足了，就应该及时停止。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//使用全局变量减少参数传递</span></span><br><span class="line">    <span class="type">int</span> k,n;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(ans,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(List&lt;Integer&gt; ans,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans.size() == k)&#123;</span><br><span class="line">            <span class="comment">//传入的应该是一个新的list，不然会传递引用会一起改变</span></span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(ans));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ans.size()+n-start+<span class="number">1</span>&lt;k)&#123;<span class="comment">//这里可以直接写在for循环的终止条件处</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=n;i++)&#123;</span><br><span class="line">            ans.add(i);</span><br><span class="line">            backtracking(ans,i+<span class="number">1</span>);</span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="216组合总和-iii"><a class="markdownIt-Anchor" href="#216组合总和-iii">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/" >216. 组合总和 III <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：全局变量、回溯、组合问题、前缀和</strong></p>
<p>和上一题的思考方向类似，将终止条件设置为前缀和等于 n 且元素个数等于 k。由于已经将不变量设置为全局变量，因此我们只需传入开始的数字和前缀和，因为前缀和可以减少很多不必要的计算，加快运算速度。另外在回溯函数传入参数的时候对 Integer 型元素进行值修改可以省去回溯一步，因为当函数返回的时候值没有变化。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> k,n;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        backtracking(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> count)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == n &amp;&amp; ans.size() == k)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(ans));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            ans.add(i);</span><br><span class="line">            backtracking(i+<span class="number">1</span>,count+i);</span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="17电话号码的字母组合"><a class="markdownIt-Anchor" href="#17电话号码的字母组合">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/" >17. 电话号码的字母组合 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：哈希表、回溯、全局变量、初始化 List、组合问题</strong></p>
<p>这题相对上面的题目，多了一层的映射关系，我们需要一个哈希表来建立数字和字符数组之间的关系，其余和常规的组合问题没什么区别。我们设置终止条件为遍历完所有的数字，此时将生成字符串并加入到结果数组中。否则一层层的遍历数字字符串，进行回溯生成。另外一个小知识是使用 <code>Arrays.asList()</code>  快速的初始化 list，不用一个个的进行赋值。</p>
<p>在哈希表的部分可以自己使用数组和索引的对应关系也可以，还有可以值不使用字符数组，而是使用字符串，然后使用字符串函数同样可以达到这个效果。Java9 里面可以使用 <code>Map.of()</code>  进行哈希表的初始化。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    String digits;</span><br><span class="line">    HashMap&lt;Character,List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.digits = digits;</span><br><span class="line">        map.put(<span class="string">&#x27;2&#x27;</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>));</span><br><span class="line">        map.put(<span class="string">&#x27;3&#x27;</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(Arrays.asList(<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>)));</span><br><span class="line">        map.put(<span class="string">&#x27;4&#x27;</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(Arrays.asList(<span class="string">&quot;g&quot;</span>,<span class="string">&quot;h&quot;</span>,<span class="string">&quot;i&quot;</span>)));</span><br><span class="line">        map.put(<span class="string">&#x27;5&#x27;</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(Arrays.asList(<span class="string">&quot;j&quot;</span>,<span class="string">&quot;k&quot;</span>,<span class="string">&quot;l&quot;</span>)));</span><br><span class="line">        map.put(<span class="string">&#x27;6&#x27;</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(Arrays.asList(<span class="string">&quot;m&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;o&quot;</span>)));</span><br><span class="line">        map.put(<span class="string">&#x27;7&#x27;</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(Arrays.asList(<span class="string">&quot;p&quot;</span>,<span class="string">&quot;q&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="string">&quot;s&quot;</span>)));</span><br><span class="line">        map.put(<span class="string">&#x27;8&#x27;</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(Arrays.asList(<span class="string">&quot;t&quot;</span>,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;v&quot;</span>)));</span><br><span class="line">        map.put(<span class="string">&#x27;9&#x27;</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(Arrays.asList(<span class="string">&quot;w&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;z&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        backtracking(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == digits.length())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ans.size();i++)&#123;</span><br><span class="line">                temp = temp + ans.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(temp);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> <span class="variable">num</span> <span class="operator">=</span> digits.charAt(index);</span><br><span class="line">        List&lt;String&gt; nums = map.get(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            ans.add(nums.get(i));</span><br><span class="line">            backtracking(index+<span class="number">1</span>);</span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化map的方法</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Character, String&gt; map = Map.of(</span><br><span class="line">        <span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure></div>
<h2 id="39组合总和"><a class="markdownIt-Anchor" href="#39组合总和">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/" >39. 组合总和 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：组合问题、前缀和、回溯、全局变量、递归、剪枝</strong></p>
<p>这题和上面 216 题相当类似，只是这次允许元素重复使用，因此我们递归的的时候传入的索引应该是 index，而不是 index+1，而且回溯不能回头计算，因为这样会导致重复的查找。终止调整则是前缀和大于或等于 target 的时候就应该停止了，如果等于的话，就将将当前结果添加到 result 数组中。优化的话可以对数组进行排序，然后在 for 循环内进行剪枝判断。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> target;</span><br><span class="line">    <span class="type">int</span>[] candidates;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.candidates = candidates;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        backtracking(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> count)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == target)&#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(ans));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            ans.add(candidates[i]);</span><br><span class="line">            backtracking(i,count+candidates[i]);</span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="40组合总和-ii"><a class="markdownIt-Anchor" href="#40组合总和-ii">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/" >40. 组合总和 II <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：回溯、组合问题、剪枝、无法解决、前缀和、全局变量、去重</strong></p>
<p>本题的难点在于有重复的元素，但要求返回的结果中不包含重复的组会，这就要求我们进行去重。原本我的想法是使用集合存储结果来进行去重，但是存在超时的问题。然后我又尝试在回溯的过程中进行剪枝，但是结果都不太理想，要不就是想要去重的地方没有正确去重，要不就是把正确的结果也给去掉。正如书上所说：“使用过” 在树形结构中是有两个维度的，一个维度是同一树枝上使用过，另一个维度是在同一个树层使用过。在题目的要求中，元素在同一个组合内是可以重复的，但两个组合不能相同。因此我们要去重的事同一树层上使用过的元素，同一树枝上的元素是一个组合里的，不用去重。本书提出了一个更好理解的思路，就是使用 used 数组，如果 <code>candidates[i]==candidates[i-1]&amp;&amp;used[i-1]==false</code> ，则说明前一个树枝使用了 <code>candidates[i-1]</code> ，也就是说同一树层已经使用过 <code>candidates[i-1]</code> ，此时就不应该继续递归，使用 continue 返回。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> target;</span><br><span class="line">    <span class="type">int</span>[] candidates;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.candidates = candidates;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        <span class="comment">//排序后可以达到去重的效果</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtracking(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> count)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == target)&#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(ans));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;candidates.length &amp;&amp; count+candidates[i]&lt;=target;i++)&#123;</span><br><span class="line">            <span class="comment">//关键的剪枝操作，对结果进行去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; index &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans.add(candidates[i]);</span><br><span class="line">            backtracking(i+<span class="number">1</span>,count+candidates[i]);</span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="131切割回文串"><a class="markdownIt-Anchor" href="#131切割回文串">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/" >131. 切割回文串 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：回文、回溯、切割问题、递归，字符串函数使用</strong></p>
<p>由于回文串判断经常要被使用到，因此将其独立为一个函数。这道题目是切割问题，我们可以这样进行遍历，从当前位置开始，新切割出的子串的位置逐渐后移，并判断新切割出的字符是否是回文串，如果是则继续递归，不是则进行剪枝操作。由于在递归前已经进行剪枝操作，因此 ans 数组中存储的一定都是回文串，我们只需将终止条件设置为当前位置已经到达字符串末尾即可。在这些操作中我们都是通过索引，而不是传入子串进行处理，这样能够提高运行速度。而对字符串进行切割可以使用 <code>substring(start,end)</code>  函数，注意是左闭右开的区间，因此右边索引的位置要加一。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    String s;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">        backtracking(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件为切割到字符串结尾</span></span><br><span class="line">        <span class="keyword">if</span>(index == s.length())&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(ans));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index+<span class="number">1</span>;i&lt;=s.length();i++)&#123;</span><br><span class="line">            <span class="comment">//剪枝操作，只有在当前切割出的字符串为回文串才继续进行递归操作</span></span><br><span class="line">            <span class="keyword">if</span>(!isHui(index,i))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左闭右开区间，调用函数对字符串进行切割</span></span><br><span class="line">            ans.add(s.substring(index,i));</span><br><span class="line">            backtracking(i);</span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左闭右开，回文串判断比较频繁，因此独立为一个函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHui</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        end = end-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(start)!=s.charAt(end))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="93复原ip地址"><a class="markdownIt-Anchor" href="#93复原ip地址">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/" >93. 复原 IP 地址 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：回溯、全局变量、字符串比较、字符串和 int 转换、剪枝、切割问题</strong></p>
<p>由于判断子串是否合法的操作比较繁琐，因此将其独立处理，首先判断元素首位是否为 0，此时使用 String 的函数 <code>compareTo()</code> ，注意返回的是 int 型，而不是 boolean 型。如果为 0，则继续判断是首位 0，还是单一 0。解决了子串是否合法的问题后就可以正式进入回溯函数的编写，同样是利用索引来进行切割，由于整数大小最大为 3 为，因此切割的大小最大为 3，所以在 for 循环中添加限制。然后进行剪枝操作，遇到 ans 已满、新切割的子串不符合要求和不能切割全部字符串这三种情况进行剪枝。因为已经进行了剪枝，所以我们的终止条件只需要要求索引以切割到字符串末尾和切割出的整数数目为 4 即可。</p>
<p>或者遇到 0 也有其他的处理方法，因为不能有前导 0，因此当我们遇到 0 的时候只能将 0 作为一部分，而不再需要和后面的数字进行结合，这样判断起来就方便了很多，实际上就是对遇到 0 这种情况单独处理。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    String s;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">        backtracking(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == s.length() &amp;&amp; ans.size()==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">                sPath = sPath + ans.get(i) + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sPath = sPath + ans.get(<span class="number">3</span>);</span><br><span class="line">            result.add(sPath);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为子串大小最大为3，因此添加限制</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index+<span class="number">1</span>;i&lt;=s.length() &amp;&amp; i&lt;=index+<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//剪枝操作，遇到ans已满、新切割的子串不符合要求和剩下仍不能切割全部字符串这三种情况进行剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(ans.size()&gt;=<span class="number">4</span> || !isTrue(index,i) || i+(<span class="number">4</span>-ans.size())*<span class="number">3</span>&lt;s.length())&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;          </span><br><span class="line">            </span><br><span class="line">            ans.add(s.substring(index,i));</span><br><span class="line">            backtracking(i);</span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTrue</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> s.substring(start,end);</span><br><span class="line">        <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> s.substring(start,start+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//判断首位元素是否为0，如果为0则判断是单一0，还是首位0</span></span><br><span class="line">        <span class="keyword">if</span>(first.compareTo(<span class="string">&quot;0&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(end-start&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转为int型比较好判断</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(temp);</span><br><span class="line">        <span class="keyword">if</span>(num&gt;<span class="number">0</span> &amp;&amp; num&lt;<span class="number">256</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="73子集"><a class="markdownIt-Anchor" href="#73子集">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/" >73. 子集 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：集合问题、回溯、全局变量</strong></p>
<p>这题也是典型的回溯问题，我么也是使用索引来限制它的访问范围，这题比较特殊的是没有终止条件，我们只需将数组加入的结果数组，进行暴力回溯即可，也无需剪枝。有人可能会觉得没有终止条件，递归要怎么停止呢？因为 for 循环里面已经包含有终止条件了，当 index 大于等于数组长度的时候就不会进入 for 循环内，因此不会启动下一次的递归，递归也就能正常结束了。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        backtracking(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(ans));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;nums.length;i++)&#123;</span><br><span class="line">            ans.add(nums[i]);</span><br><span class="line">            backtracking(i+<span class="number">1</span>);</span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="90子集-ii"><a class="markdownIt-Anchor" href="#90子集-ii">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/" >90. 子集 II <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：回溯、去重、集合问题、递归</strong></p>
<p>这题总体上参考 73 题子集，然后使用 40 题的去重操作结合起来就得到了答案。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtracking(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(ans));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//剪枝操作，去重</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;index &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(nums[i]);</span><br><span class="line">            backtracking(i+<span class="number">1</span>);</span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用used数组标记的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backtracking(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(ans));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>] &amp;&amp; used[i-<span class="number">1</span>]==<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            backtracking(i+<span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="491递增子序列"><a class="markdownIt-Anchor" href="#491递增子序列">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-decreasing-subsequences/" >491. 递增子序列 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：回溯、去重、哈希表、全局变量</strong></p>
<p>这题也是需要去重，但是不能使用上一题的方法进行去重，因为上一题是先进行排序过后的，因此相同的元素是相邻的，而这一题不同，它要求保持原有的顺序，因此不能使用排序的方法。既然上一题的方法不能实现，我们就采用最容易想到的集合去重法，将结果加入到集合中，最后再将集合内的元素赋给列表。这题的终止条件也是在 for 循环内，只要 ans 列表的大小大于 2，我们就可以将其加入到列表内。然后剪枝操作是当前元素和 ans 列表的最后一个元素比较，注意在比较之前要保证 ans 列表非空。</p>
<p>优化版本是使用哈希表记录已经用过的元素，在这一层就不能再使用了。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Set&lt;List&lt;Integer&gt;&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        backtracking(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; i:set)&#123;</span><br><span class="line">            result.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans.size()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            set.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(ans));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans.size()&gt;<span class="number">0</span> &amp;&amp; ans.get(ans.size()-<span class="number">1</span>)&gt;nums[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(nums[i]);</span><br><span class="line">            backtracking(i+<span class="number">1</span>);</span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//结果集合</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//路径集合</span></span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        getSubsequences(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getSubsequences</span><span class="params">( <span class="type">int</span>[] nums, <span class="type">int</span> start )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()&gt;<span class="number">1</span> )&#123;</span><br><span class="line">            res.add( <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path) );</span><br><span class="line">            <span class="comment">// 注意这里不要加return，要取树上的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由于HashMap是局部变量，因此不用回溯</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start ;i &lt; nums.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!path.isEmpty() &amp;&amp; nums[i]&lt; path.getLast())&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 本层是否已经使用过了当前数字</span></span><br><span class="line">            <span class="keyword">if</span> ( map.getOrDefault( nums[i],<span class="number">0</span> ) &gt;=<span class="number">1</span> )&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对本层的已用数字进行计数</span></span><br><span class="line">            map.put(nums[i],map.getOrDefault(nums[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            getSubsequences( nums,i+<span class="number">1</span> );</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="46全排列"><a class="markdownIt-Anchor" href="#46全排列">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/" >46. 全排列 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：回溯、排列问题、访问标志</strong></p>
<p>这题虽然大框架上和上面的题目一样，但是不同的时，上面的都是通过索引来进行切割，进行下一次的递归操作，而这题显然不可以，因为这题是排列问题，顺序不同也是不同。因此我们改用访问数组 used，每次都将 nums 遍历一遍，遇到已经访问过的元素就退出本次访问，转而访问其他的元素。回溯的时候也除了需要将 ans 数组的元素弹出，还需要将访问数组的对应位置设置为 false。终止条件就是 ans 的长度等于 nums 的长度，此时已经访问完全部的元素。此外就是 boolean 数组初始化默认都是 false。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backtracking();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans.size()==nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(ans));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            ans.add(nums[i]);</span><br><span class="line">            backtracking();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="47全排列-ii"><a class="markdownIt-Anchor" href="#47全排列-ii">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/" >47. 全排列 II <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：回溯、去重、哈希表、局部变量与全局变量</strong></p>
<p>这题的总体框架是 46 题的全排列，然后去重操作是是 491 题递增子序列的哈希表去重方式。这题与 47 题最大的不同就在于有重复的元素，要求我们进行去重。一旦涉及到去重，我们首先要搞明白的是对树枝去重，还是对树层去重，此题是对树层进行去重。树层去重有三个方法，一个是使用集合无脑去重，有超时的风险；一个是通过排序 + 标记的方式，如果前一个元素与自己相等，且该元素此时没有被访问，说明是同层元素，则进行去重；一个是使用哈希表记录本层当前数值已经被使用的次数，如果大于 1，则说明同层已经有重复元素了，要进行去重。通过分析问题，我们最终采用了第三种方式。实际上第二种方法可能效率更好一点。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backtracking();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans.size()==nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(ans));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于HashMap是局部变量，因此不用回溯</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 本层是否已经使用过了当前数字</span></span><br><span class="line">            <span class="keyword">if</span> ( map.getOrDefault( nums[i],<span class="number">0</span> ) &gt;=<span class="number">1</span> )&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对本层的已用数字进行计数</span></span><br><span class="line">            map.put(nums[i],map.getOrDefault(nums[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            ans.add(nums[i]);</span><br><span class="line">            backtracking();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="51n皇后"><a class="markdownIt-Anchor" href="#51n皇后">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/" >51.N 皇后 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：回溯、子函数、递归、字符串拼接、数组赋初值</strong></p>
<p>这是我解决的第一道回溯的困难题，也是一题很经典的回溯算法。没有想象中的困难，按照模板的思路和画出递归的树形结构，问题变得简单了不少。我的思路是从第一行到最后一行进行递归，这样就能保证每行只有一个元素。终止条件是到达最后一行，此时将结果存储到 result 数组中。否则进行横向的遍历，如果出现了同列或者同一斜线的元素就结束，进行下一次循环。否则就进入下一层的递归。由于同一斜线的判断太麻烦，就独立为一个函数，专门检验新的点是否符合条件。遇到困难题不用慌，还是按照模板来进行思考就好。另外使用 <code>Arrays.fill(chessboard,-1);</code>  可以为数组赋初值。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//used[i]表示第i列已经被访问</span></span><br><span class="line">    <span class="type">boolean</span> used[][];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">boolean</span> tip;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        backtracking(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans.size() == n)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(ans));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由于是按行继续递归的，因此不用担心行中有重复元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(index,i))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//拼接出对应的字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                sPath += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sPath += <span class="string">&quot;Q&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                sPath += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//进行递归和回溯操作</span></span><br><span class="line">            ans.add(sPath);</span><br><span class="line">            used[index][i] = <span class="literal">true</span>;</span><br><span class="line">            backtracking(index+<span class="number">1</span>);</span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">            used[index][i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测该点是否符合是否能够加入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="comment">//检测同列是否已有元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i][y])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检测斜线上是否有元素</span></span><br><span class="line">        <span class="comment">//左上角</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=x,j=y;i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i][j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右下角</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=x,j=y;i&lt;n &amp;&amp; j&lt;n;i++,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i][j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左下角</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=x,j=y;i&lt;n &amp;&amp; j&gt;=<span class="number">0</span>;i++,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i][j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右上角</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=x,j=y;i&gt;=<span class="number">0</span> &amp;&amp; j&lt;n;i--,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i][j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另外的写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] chessboard;<span class="comment">//存储第i行皇后在第几列</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        chessboard=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(chessboard,-<span class="number">1</span>);</span><br><span class="line">        dfs(<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//判断目前棋盘是否满足要求</span></span><br><span class="line">        <span class="comment">//现在要放入第row行的皇后，所以判断第row-1行皇后是否满足要求</span></span><br><span class="line">        <span class="keyword">if</span>(!isValid(row-<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(row==n)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//做选择</span></span><br><span class="line">            StringBuilder str=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                str.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            str.append(<span class="string">&#x27;Q&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                str.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(str.toString());</span><br><span class="line">            chessboard[row]=i;</span><br><span class="line">            <span class="comment">//进入下一层决策</span></span><br><span class="line">            dfs(row+<span class="number">1</span>,n);</span><br><span class="line">            <span class="comment">//恢复现场</span></span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            chessboard[row]=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> col=chessboard[row];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="comment">//同一列有皇后</span></span><br><span class="line">            <span class="keyword">if</span>(chessboard[i]==col)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// “/”方向有皇后</span></span><br><span class="line">            <span class="keyword">if</span>(chessboard[i]+i==row+col)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// “\”方向有皇后</span></span><br><span class="line">            <span class="keyword">if</span>(chessboard[i]-i==col-row)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="37解数独"><a class="markdownIt-Anchor" href="#37解数独">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/sudoku-solver/" >37. 解数独 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：无法解决、二维递归、数学、返回值</strong></p>
<p>这题总体思想上和上面的题目是一样的，但是在细节上就有很多差异了。首先这题不好设置终止条件，因为它原本的位置上有数，很难确定什么时候才把数独填满。至于二维递归方面我也想到了，因为一维肯定无法解决该问题，但是就卡在如何设置终止条件进行返回呢？实际上这个技巧在二叉树上被广泛应用，就是通过返回布尔值来获取符合条件的树枝。然后判断是否在小区域的方法也很巧妙，先除以 3，再乘以 3，这样就可以获取小区域的左上角的坐标了。本来以为回溯已经学的不错了，但是题外有题，还是要虚心学习才是正确的，而且模板虽好，但还是要保持一个开放的头脑，将各个模块的知识融会贯通。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">char</span>[][] board;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.board = board;</span><br><span class="line">        backtracking();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//x是插入位置的横坐标，y是插入位置的纵坐标，num是要插入的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;<span class="number">9</span>;x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;<span class="number">9</span>;y++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[x][y] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> num=<span class="string">&#x27;1&#x27;</span>;num&lt;=<span class="string">&#x27;9&#x27;</span>;num++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isValid(x,y,num))&#123;</span><br><span class="line">                        board[x][y] = num;</span><br><span class="line">                        <span class="keyword">if</span>(backtracking())&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        board[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    &#125;                 </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">char</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[x][i] == num || board[i][y] == num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过先除以3，再乘以3的操作回去小区域内的开始位置号巧妙</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">startRow</span> <span class="operator">=</span> (x/<span class="number">3</span>)*<span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startCol</span> <span class="operator">=</span> (y/<span class="number">3</span>)*<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=startRow;i&lt;startRow+<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=startCol;j&lt;startCol+<span class="number">3</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == num)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="第八章-贪心算法"><a class="markdownIt-Anchor" href="#第八章-贪心算法">#</a> 第八章 贪心算法</h1>
<p>在学习贪心算法的过程中，手动模拟解题过程之后，如果感觉可以通过局部最优解推出全局最优，而且想不到反例，那么就试一下贪心算法。</p>
<h2 id="455分发饼干"><a class="markdownIt-Anchor" href="#455分发饼干">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/" >455. 分发饼干 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：贪心算法、双指针、排序</strong></p>
<p>这题的贪心策略是依次将小的饼干优先给胃口最小的小朋友，因为我们需要先见两个数组进行排序，然后用双指针分别指示当前等待派发的小朋友和饼干，如果饼干满足小朋友要求则同时移动到下一个，计数器加一，如果不满足要求，则小朋友继续等待，换一个更大的饼干。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,count=<span class="number">0</span>;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;g.length &amp;&amp; j&lt;s.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i]&lt;=s[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="376摆动序列"><a class="markdownIt-Anchor" href="#376摆动序列">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/" >376. 摆动序列 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：无法解决、贪心算法、数学、边界处理、动态规划</strong></p>
<p>这题的贪心策略可以转化为求取峰值的数目，然后注意平坡的情况，在遇到峰值的时候才进行 pre 的变换。或者我们可以通过动态规划的转移来推导出贪心算法，由于至于前一个状态相关，因此只需保存一个值即可。本来我已经想到这个方向了，但是推导了一下感觉有不可行，总觉得会有中间节点影响，不能简单的判断相邻的元素，但是也找不到反例，早知道这样算了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="1b87dee143e0e43e987f8da999b2a2aa.png"
                      alt="image.png.png"
                ></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">1</span>,pre=<span class="number">0</span>,cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            cur = nums[i] - nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//遇到峰值</span></span><br><span class="line">            <span class="keyword">if</span>((cur&gt;<span class="number">0</span> &amp;&amp; pre&lt;=<span class="number">0</span>) || (cur&lt;<span class="number">0</span> &amp;&amp; pre&gt;=<span class="number">0</span>))&#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                pre = cur;<span class="comment">//为什么不放在if外</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更好理解的版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">down</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up = down + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                down = up + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up, down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="53最大子数组和"><a class="markdownIt-Anchor" href="#53最大子数组和">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/" >53. 最大子数组和 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：贪心算法、状态转移</strong></p>
<p>这题的贪心就在于将当前遍历的值和之前形成的子数组和加上当前遍历的值的和相比，哪个大就取哪个。然后使用 ans 来记录出现过的最大子数组和。这个贪心策略就在于状态的转移，如果之前的子数组和是正向的，就将他和当前值相加，因为子数组要求是连续的，如果是负担，那么就直接取当前值作为起点，重启子数组的求和。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> count + nums[i];</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;nums[i])&#123;</span><br><span class="line">                count = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;ans)&#123;</span><br><span class="line">                ans = count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="122买卖股票的最佳时机-ii"><a class="markdownIt-Anchor" href="#122买卖股票的最佳时机-ii">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/" >122. 买卖股票的最佳时机 II <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：贪心算法</strong></p>
<p>这题的贪心策略是比较相邻两日的价格差距，如果差距大于 0 则昨日买入今天卖出，然后将利润加到 ans 中，遍历一遍后即可获得最大利润。这题的关键就在于利润的分解，我们不需要将股票等到股价的极大值点处卖出，只要每天执行都买卖一次即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(temp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                ans+=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="55跳跃游戏"><a class="markdownIt-Anchor" href="#55跳跃游戏">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/" >55. 跳跃游戏 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：贪心算法</strong></p>
<p>我们对数组进行进行遍历，但是加上一个现在条件，就是不能越过 max 值，max 值又当前能跳到的最大距离决定，每次遍历都会进行比较，记录最大能跳到的距离，如果 max 到达最后一个坐标就返回 true，如果遍历完仍未到达则返回 false。这题的关键点在于不用管怎么跳的，只要覆盖范围大于最后一个数组下标就一定能到达。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length &amp;&amp; i&lt;=max;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i+nums[i];</span><br><span class="line">            <span class="keyword">if</span>(index&gt;max)&#123;</span><br><span class="line">                max = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="45跳跃游戏-ii"><a class="markdownIt-Anchor" href="#45跳跃游戏-ii">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/" >45. 跳跃游戏 II <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：贪心算法、动态规划</strong></p>
<p>这题要求的是求取最小长度，我们无法简单的使用贪心算法进行解决，因为可能局部最优的选择未必能够达到终点。因此我加上了一个数组来记录跳到该位置的最少次数，然后进行遍历，用当前值去更新它所能够跳到的节点的最小次数的值，最后返回结果即可。</p>
<p>另一种贪心思路是记录当前覆盖的范围和下一步能最大覆盖的范围，然后如果下一步能够到达终点就直接计数加一后返回，否则遍历完当前覆盖的范围后，计数器加一，如果将下一步能覆盖的最大范围赋值到当前覆盖的范围，开启下一轮的寻找。这题的关键仍然是覆盖，不要纠结是哪一步走的，我们只需要知道每一步能够覆盖到的最大范围。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> nums[i]+i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=step &amp;&amp; j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    count[j] = count[i]+<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count[i]+<span class="number">1</span>&lt;count[j])&#123;</span><br><span class="line">                        count[j]=count[i]+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> count[nums.length-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种思路</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span> || nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录跳跃的次数</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前的覆盖最大区域</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//最大的覆盖区域</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//在可覆盖区域内更新最大的覆盖区域</span></span><br><span class="line">            maxDistance = Math.max(maxDistance,i+nums[i]);</span><br><span class="line">            <span class="comment">//说明当前一步，再跳一步就到达了末尾</span></span><br><span class="line">            <span class="keyword">if</span> (maxDistance&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//走到当前覆盖的最大区域时，更新下一步可达的最大区域</span></span><br><span class="line">            <span class="keyword">if</span> (i==curDistance)&#123;</span><br><span class="line">                curDistance = maxDistance;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="134加油站"><a class="markdownIt-Anchor" href="#134加油站">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/" >134. 加油站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：贪心算法、数学</strong></p>
<p>首先我们可以知道如果 gas 的总和大于等于 cost 的话，那么一定存在一个起点使得车能够绕环路一周。题目指定如果有解，则解唯一，而解有什么特征呢，他肯定是 gas [i] 大于等于 cost [i]，其实因为唯一，所以应该不会是等于。然后从该点开始计算，它不会出现剩余油量小于 0 的情况，以此为依据，我们进行贪心算法，遍历 gas 和 cost 数组，每次遇到第一个 gas [i]-cost [i] 大于等于 0 的情况，就开始计算 part 部分，遇到 part 小于 0 则终止，等待开启下一次查找。</p>
<p>优化写法则是遇到部分油量小于 0，则从前一位继续开始查找，最后满足条件的就是结果。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>,rest=<span class="number">0</span>,part=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> tip=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)&#123;</span><br><span class="line">            rest = gas[i] - cost[i];</span><br><span class="line">            sum += rest;</span><br><span class="line">            <span class="keyword">if</span>(tip)&#123;</span><br><span class="line">                part += rest;</span><br><span class="line">                <span class="keyword">if</span>(part&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    tip = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rest&gt;=<span class="number">0</span> &amp;&amp; !tip)&#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                tip = <span class="literal">true</span>;</span><br><span class="line">                part = rest;<span class="comment">//开启计数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>,run=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)&#123;</span><br><span class="line">            run += (gas[i]-cost[i]);</span><br><span class="line">            sum += (gas[i]-cost[i]);</span><br><span class="line">            <span class="keyword">if</span>(run&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                ans = i+<span class="number">1</span>;</span><br><span class="line">                run = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="135分发糖果"><a class="markdownIt-Anchor" href="#135分发糖果">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/" >135. 分发糖果 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：贪心算法、数组初始化</strong></p>
<p>不要被困难题给吓到，此题的贪心策略并不复杂，我们使用一个数组来记录每个孩子分配到的糖果，由于每个孩子都至少分配到 1 个糖果，因此我们将数组的值初始化为 1。然后我们从左到右进行遍历，如果右侧的孩子评分比左侧孩子评分更高，我们就将右侧孩子的糖果数设置为左侧孩子的糖果数加一。那么就保证了每个孩子右侧能够符合条件。然后同理，我再从右侧向左侧遍历，但是这时要增加一个条件保证左侧孩子的糖果数不会减少。通过两侧的遍历，我们就保证了相邻两个孩子评分更高的孩子会获得更多的糖果，最后对数组求和即可。这题比较特殊就是通过两次的贪心策略来解决问题，如果在考虑局部最优的时候想要两边兼顾，就会顾此失彼。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        Arrays.fill(ans,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;ratings.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                ans[i] = ans[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=ratings.length-<span class="number">2</span>;i&gt;-<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i+<span class="number">1</span>] &amp;&amp; ans[i]&lt;=ans[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//ans的判断是为了保证左边孩子的糖果数不会减少</span></span><br><span class="line">                ans[i] = ans[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(ans).sum()</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="860柠檬水找零"><a class="markdownIt-Anchor" href="#860柠檬水找零">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/lemonade-change/" >860. 柠檬水找零 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：贪心算法、条件判断</strong></p>
<p>这题的贪心策略比较显然，我们只要优先给大额的钞票即可，因为 5 比 10 能够应对的情况更多。由于情况比较少，只有 3 种情况，我们使用两个变量分别存储当前拥有的 5 元和 10 元的数目。我们就对三种情况进行分析，顾客给 5 元则不用找零，5 元账户加一；顾客给 10 元，我们只能找零 5 元并收入 10 元；顾客给 20 元，此时就需要贪心，如果有 10 元就给 10 元，没有就给 5 元。每次结算完都判断一下两个变量是否小于 0，小于则说明无法找零了，返回 false，否则返回 true。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;</span><br><span class="line">        <span class="type">int</span> num5=<span class="number">0</span>,num10=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : bills)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">5</span>)&#123;</span><br><span class="line">                num5 += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">10</span>)&#123;</span><br><span class="line">                num5 -= <span class="number">1</span>;</span><br><span class="line">                num10 += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(num10 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    num5 -= <span class="number">1</span>;</span><br><span class="line">                    num10 -= <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    num5 -= <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(num5&lt;<span class="number">0</span> || num10&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="452用最少数量的箭引爆气球"><a class="markdownIt-Anchor" href="#452用最少数量的箭引爆气球">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/" >452. 用最少数量的箭引爆气球 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：贪心算法、溢出、重写比较器</strong></p>
<p>这题的贪心策略是首先按终止位置将各个气球的位置进行排序，然后在以此比较，看是否有范围重复的气球。我们记录当前气球匹配的最后位置，如果此时气球的起始位置小于等于该终止位置，则说明可以同时引爆，此时终止位置不用更新，因为可能下一个气球也可以同时加入。如果终止位置已经小于当前气球的开始位置，则说明已经没用了，则将终止位置更新为当前气球的终止位置。注意一个小细节，在进行比较器重写时，如果使用 <code>a[i]-b[i]</code>  会溢出，要使用 <code>Integer.compare(a[1],b[1])</code>  才没有问题。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="comment">//使用Integer.compare(int,int)，否则会溢出</span></span><br><span class="line">        asArrays.sort(points,(a,b)-&gt;Integer.compare(a[<span class="number">1</span>],b[<span class="number">1</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> points.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &lt;= end)&#123;</span><br><span class="line">                ans -= <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="26合并区间"><a class="markdownIt-Anchor" href="#26合并区间">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/" >26. 合并区间 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：贪心算法、边界处理、重写比较器</strong></p>
<p>这题和上一题比较类似，只是遇到覆盖范围的处理方式不一样。我们首先按照开始位置从小到大进行排序，然后开始判断覆盖区间是否重复，如果下一个的开始位置小于等于当前结束位置，我们就选择其终止位置和当前终止位置，注意不要直接更新终止位置，因为会有 <code>[[1,4],[2,3]]</code>  这种情况。否则则说明当前区间已经和前面的区间不再重叠，此时存储前面区间的值，并开启下一轮重叠区间的寻找，记得最后还要存储最后一个区间，因为在 for 循环内并没有处理最后一个区间。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals,(a,b)-&gt;Integer.compare(a[<span class="number">0</span>],b[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span> start=intervals[<span class="number">0</span>][<span class="number">0</span>],end=intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">Nstart</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>],Nend = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(Nstart &lt;= end)&#123;</span><br><span class="line">                end = Math.max(Nend,end);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(start,end)));</span><br><span class="line">                start = Nstart;</span><br><span class="line">                end = Nend;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(start,end)));</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] temp = <span class="keyword">new</span> <span class="title class_">int</span>[ans.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ans.size();i++)&#123;</span><br><span class="line">            temp[i][<span class="number">0</span>] = ans.get(i).get(<span class="number">0</span>);</span><br><span class="line">            temp[i][<span class="number">1</span>] = ans.get(i).get(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="738单调递增的数字"><a class="markdownIt-Anchor" href="#738单调递增的数字">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/" >738. 单调递增的数字 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：贪心算法、数学、字符串转换、无法解决、字符相减</strong></p>
<p>贪心算法的策略是从右向左扫描，如果遇到左边的数字大于右边的数组，则将左边的数字减一，然后将右侧的数组全部变成 9 即可。实际上思路并不算难，但是很巧妙，而且实现也不那么容易，这个使用字符直接实现就简便很多，我还将其转换为数字，还新建了一个数组来存储数据，就是这里卡住了，实际上直接使用原来的数组即可，只有更改对应位置就好，还少去了很多情况的处理。而且我的思路是从左到右扫描的，这样会导致要改变已经填写的答案，因此应该从右到左，这样就不会修改已经确定的结果，所以说细节决定成败，思路是想到了，但是没有能够实现出来。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">10</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">        <span class="type">char</span>[] arr = num.toCharArray(</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]-<span class="string">&#x27;0&#x27;</span> &gt; arr[i+<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                arr[i] = (<span class="type">char</span>) (arr[i]-<span class="string">&#x27;1&#x27;</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                    arr[j] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="第九章-动态规划"><a class="markdownIt-Anchor" href="#第九章-动态规划">#</a> 第九章 动态规划</h1>
<h2 id="动态规划五部曲"><a class="markdownIt-Anchor" href="#动态规划五部曲">#</a> 动态规划五部曲</h2>
<ol>
<li>确定 dp 数组及下标的含义。</li>
<li>确定递推公式。</li>
<li>初始化 dp 数组。</li>
<li>确定遍历顺序。</li>
<li>举例推导 dp 数组。</li>
</ol>
<h2 id="509斐波那契数"><a class="markdownIt-Anchor" href="#509斐波那契数">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/" >509. 斐波那契数 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、边界处理</strong></p>
<p>我们只要遍历 n 然后生成数即可，由于下一个值只与前两位的值有关，所以我们可以省略 dp 数组，直接使用两个变量存储值即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>,temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123; <span class="keyword">return</span> n;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            temp = a+b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="70爬楼梯"><a class="markdownIt-Anchor" href="#70爬楼梯">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/" >70. 爬楼梯 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、边界处理</strong></p>
<p>这题实际上也是斐波那契数的变种，第 n 阶楼梯是由第 n-1 阶楼梯走 1 步和第 n-2 阶楼梯走 2 步得到的。我们只需修改上一题的初值即可解决该题。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>,temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123; <span class="keyword">return</span> n;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            temp = a+b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="746使用最小花费爬楼梯"><a class="markdownIt-Anchor" href="#746使用最小花费爬楼梯">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/" >746. 使用最小花费爬楼梯 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、边界处理</strong></p>
<p>和上一题一样，第 n 阶楼梯是由第 n-1 阶楼梯走 1 步和第 n-2 阶楼梯走 2 步得到的，只是这题增加了花费的概念。我们使用 dp 数组来记录每一步的花费，可以推导出这样递归公式 <code>dp[n+2] = Math.min(dp.get(i)+cost[i],dp.get(i+1)+cost[i+1])</code> ，确定好递归公式后，我们就需要为 dp 数组设定初值，由于可以选择在 0 或 1 的台阶开始，因此他们的初值为 0，根据递归公式我么也可以知道应该从左到右进行遍历。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; dp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        dp.add(<span class="number">0</span>);</span><br><span class="line">        dp.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cost.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp.add(Math.min(dp.get(i)+cost[i],dp.get(i+<span class="number">1</span>)+cost[i+<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.get(dp.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="62不同路径"><a class="markdownIt-Anchor" href="#62不同路径">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/" >62. 不同路径 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、二维 dp 数组、边界处理、数学</strong></p>
<p>由于机器人每次只能向下移动或者向右移动一步，那么 <code>dp[i][j]</code>  的值就是左边的路线和加上上面的路线和，递推公式为 <code>dp[i][j] = dp[i][j-1]+dp[i-1][j];</code> 。显然最上面和最左边的会产生越界错误，我们需要为其赋初值，由于限制条件，因此初值为 1。最后只需返回右下角的值即为不同路径的总数。或者使用高中数学的数论基础知识解决，机器人一定会走 m+n-2 步，即从 m+n-2 中挑出 m-1 步向下走不就行了吗？即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">C^{m-1}_{m+n-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1789em;vertical-align:-0.3246em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8542em;"><span style="top:-2.4337em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3246em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="63不同路径-ii"><a class="markdownIt-Anchor" href="#63不同路径-ii">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/" >63. 不同路径 II <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、二维 dp 数组、边界处理</strong></p>
<p>这题和上一题的基本思路一样，只是多了障碍物，我们只需要在上一题的基础上增加对障碍物的处理即可。首先障碍物会影响我们对最上面和最左边的初始化，我们一旦遇到障碍物，就停止为后面的位置赋值为 1，因为唯一的路径都已经被障碍物堵住了。还有在动态规划的过程中对障碍物进行处理，遇到障碍物则将该处的路径值设置为 0，其余内容与上一题一样。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遇到障碍物则后面的值都为0了</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;n &amp;&amp; obstacleGrid[<span class="number">0</span>][i]==<span class="number">0</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m &amp;&amp; obstacleGrid[i][<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">0</span>) dp[i][j] = dp[i][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="343整数拆分"><a class="markdownIt-Anchor" href="#343整数拆分">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/" >343. 整数拆分 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、边界处理、数学</strong></p>
<p>动态规划的 dp 数组记录拆分的乘积的最大值，我们可以遍历 n 的每个拆分，每次拆分都是拆成两个数。我们可以这样思考，例如 3，可以拆分为 1 和 2，也可以拆分为 1 和对 2 进行进行拆分，这样我们就推导出递推公式为 <code>temp = Math.max(j*(i-j),j*dp[i-j]);</code> 。由于这种拆分是遍历的，并从中选取最大值，因此 dp [i] 会比较递归中产生的值，选取其中最大的。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> Math.max(j*(i-j),j*dp[i-j]);</span><br><span class="line">                dp[i] = Math.max(temp,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="96不同的二叉搜索树"><a class="markdownIt-Anchor" href="#96不同的二叉搜索树">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/" >96. 不同的二叉搜索树 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、数学、二叉树</strong></p>
<p>我们可以这样分解问题，将二叉树分为两边，左边可能出现的二叉树种类 * 右边可能出现二叉树的种类相乘可以得到当前这棵二叉树可能的种类。以 3 个节点的情况为例子，因为要留一个节点作为根结点，左右总共可分配的节点数为 2，我们可以左 0 右 2、左 1 右 1、左 2 右 0 三种情况，我们只要将其求和即可得到 3 个节点时候的不同二叉树的数目。因此我们可以使用 dp 数组记录每个节点数目下，不同的二叉树数目有多少种，然后遍历即可得到答案。初始化的话就是将节点为 0 时值为 1，节点为 1 时值也为 1。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                count += (dp[j]*dp[i-j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="一维滚动数组"><a class="markdownIt-Anchor" href="#一维滚动数组">#</a> 一维滚动数组</h2>
<p>对于 0-1 背包问题，dp 数组的状态是可以压缩的。在使用二维数组的时候，递推公式为 <code>dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i]</code> 。如果把 <code>dp[i-1]</code>  的那层数据复制到 <code>dp[i]</code>  上，那么递推公式可以是 <code>dp[i][j] = max(dp[i][j],dp[i-1][j-weight[i]]+value[i]</code> 。与其复制数值，不如只使用 <code>dp[i]</code> 。这就是滚动数组的由来，需要满足的条件是上一层的数据可以重复利用，可以直接复制到当前层。</p>
<p>二维 dp 数组中遍历背包的时候，背包容量是从小到大遍历的，而一维 dp 数组遍历背包的时候，背包容量是从大到到小的遍历。倒序遍历是保证物品 i 只被放入一次背包，如果使用正序遍历，那么物品 0 就会被重复加入多次。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维dp数组的遍历顺序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;weight.length;i++)&#123;<span class="comment">//遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=bagWeight;j&gt;=weight[i];j--)<span class="comment">//遍历背包容量，从大到小</span></span><br><span class="line">        dp[j] = Math.max(dp[j],dp[j-weight[i]]+value[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="416分割等和子集"><a class="markdownIt-Anchor" href="#416分割等和子集">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/" >416. 分割等和子集 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：01 背包问题、动态规划、数学</strong></p>
<p>首先一个数组如果能够分隔成两个和相同的子集，它数组的和应该为偶数，不然不可能分隔成两个相等的子集。如果是偶数，那么和的一半应该就是单个子集的和，而且我们可以知道如果我们能够找到一个子集的和为单个子集和，另一个子集就是剩下的元素。因此我们的任务就是在数组和为偶数的情况下，找到一个子集的和等于数组和的一半。我们使用以后数组记录子集和是否存在，遍历所有的元素，看是否能生成新的子集和，如果能生成我们想要的子集和，那么就返回 true，如果没有的话就返回 false。不知为啥我感觉这题不像是动态规划，更像是前面做过的覆盖范围问题，不断的进行覆盖，看是否能覆盖到最后的值。如果要想改成动态规划只需将循环内的代码换成 <code>dp[j] = max(dp[i].dp[j-nums[i]]+nums[i]</code> ，这里对 dp 数组的思路不同，动态规划的 dp [i] 表示容量为 j 的背包所能凑到的最大和，当然不会超过它，只要最后的最大和是相等的就找到该子集的和为目标所求。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> sum/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] bag = <span class="keyword">new</span> <span class="title class_">int</span>[size+<span class="number">1</span>];</span><br><span class="line">        bag[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=size;j&gt;=num;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bag[j-num]==<span class="number">1</span>)&#123;</span><br><span class="line">                    bag[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(bag[size]==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="494目标和"><a class="markdownIt-Anchor" href="#494目标和">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/" >494. 目标和 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：无法解决、数学、动态规划、边界处理</strong></p>
<p>这题和以外的背包问题的差异就在于出现了负数子集，不再是只是正价值的，每次处理数都有两种可能。递推公式并不复杂，为 <code>dp[i][j] = dp[i-1][j+nums[i]]+dp[i-1][j-nums[i]];</code> ，由前后两个来决定。这样虽然比较容易想到，但是处理起来却很复杂，各种边界情况都要仔细处理，最终由于畏难情绪，没有能够解决该问题，还是很可惜的。另外一种就实现起来比较简单，但是推导需要比较巧妙的思路。我们可以把取正的作为一个子集，子集和为 pos，取负的作为一个子集，和为 neg，数组总和为 sum，我们可以推导出两个公式：neg+pos=sum 和 pos-neg=target。综合两个式子可以得到 pos=(target+sum)/2，这样我们就将问题转换为装满容量为 pos 的背包有几种方法。递推公式为 <code>dp[j]+=dp[j-nums[i]]</code> ，这个公式在组合类问题中经常使用，需要记住。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(target) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length][sum*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][sum+nums[<span class="number">0</span>]] += <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>][sum-nums[<span class="number">0</span>]] += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -sum;j&lt;=sum;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j+nums[i]) &gt; sum)&#123;</span><br><span class="line">                    dp[i][j+sum] = dp[i-<span class="number">1</span>][j-nums[i]+sum];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>((j-nums[i]) &lt; -sum)&#123;</span><br><span class="line">                    dp[i][j+sum] = dp[i-<span class="number">1</span>][j+nums[i]+sum];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j+sum] = dp[i-<span class="number">1</span>][j+nums[i]+sum]+dp[i-<span class="number">1</span>][j-nums[i]+sum];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>][sum+target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> sum - target;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span> || diff % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">neg</span> <span class="operator">=</span> diff / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[neg + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> neg; j &gt;= num; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="474一和零"><a class="markdownIt-Anchor" href="#474一和零">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/" >474. 一和零 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、数学、二维 dp 数、01 背包问题</strong></p>
<p>由于该题有两个限制条件，因此我们需要使用二维的滚动数组，否则我们就需要使用一个三维数组。 <code>dp[i][j]</code>  表示在 i 个 0 和 j 个 1 的限制条件下最多的子集数目。递推公式也比较明显，只有两种情况，一种是维持现状不变，另一种是将该元素加入子集，因此递推公式为 <code>dp[i][j] = Math.max(dp[i-Zero][j-One]+1,dp[i][j]);</code> 。由于滚动数组的特性，我们需要从右下角开始遍历。这题实质上是有两个维度的 01 背包问题</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;strs.length;k++)&#123;</span><br><span class="line">            <span class="comment">//获取0和1的次数</span></span><br><span class="line">            <span class="type">char</span>[] s = strs[k].toCharArray();</span><br><span class="line">            <span class="type">int</span> Zero=<span class="number">0</span>,One=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> temp:s)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    Zero+=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    One+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=Zero;i--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;=One;j--)&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-Zero][j-One]+<span class="number">1</span>,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="完全背包问题"><a class="markdownIt-Anchor" href="#完全背包问题">#</a> 完全背包问题</h2>
<p>完全背包问题和 01 背包问题在题目描述上唯一不同的地方就是每种物品有无数个。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先遍历物品，在遍历物品</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;weight.length;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=weight[i];j&lt;=bagWeight;j++)&#123;</span><br><span class="line">    dp[j] = max(dp[j],dp[j-weight[i]]+value[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="518零钱兑换-ii"><a class="markdownIt-Anchor" href="#518零钱兑换-ii">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/" >518. 零钱兑换 II <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、完全背包问题</strong></p>
<p>这题是标准的完全背包问题，由于是统计可能的次数，因此我们的递推公式为 <code>dp[j] += dp[j-coins[i]];</code> ，每次遍历都检验是否能够增加可能的次数。由于 0 元的情况只有一种，我们将其设置为 1。</p>
<p>遍历顺序对求取也是有影响的，如果求组合数，就是外循环为物品，内循环为背包；如果求排列数，就是外循环为背包，内循环为物品。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">                dp[j] += dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="377组合总和-iv"><a class="markdownIt-Anchor" href="#377组合总和-iv">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/" >377. 组合总和 Ⅳ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：排列、动态规划</strong></p>
<p>这题和上一题唯一的区别就在于上一题求的是组合数，该题求的是排列数。在本题中递推公式和数组初始化都是一样的，我们只需修改遍历的顺序，从原来的外循环是物品，内循环是背包改为外循环是背包，内循环是物品，因为先为循环是物品，则物品的相对次序不会改变，得到的就是组合，只有在内循环中遍历物品才会出现不一样的排列。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-nums[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] += dp[j-nums[i]];</span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="322零钱兑换"><a class="markdownIt-Anchor" href="#322零钱兑换">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/" >322. 零钱兑换 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、边界处理、数组初始化</strong></p>
<p>与其他的题目不同，这次我们要求的是最小的次数，我们设置 dp 数组为每个金额对应的最少的硬币个数。易得递推公式为 <code>dp[j] = Math.min(dp[j],dp[j-coins[i]]+1);</code> ，本题最难的是设置 dp 数组的初始值，因为是求最小值，所以不能和原来一样都设置为 0，而是要设置为最大的值，这样才能够进行更新。但是 dp [0] 需要设置为 0，作为动态规划的起点，否则数据无法进行更新。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp,Integer.MAX_VALUE-<span class="number">2</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">                dp[j] = Math.min(dp[j],dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[amount]==(Integer.MAX_VALUE-<span class="number">2</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[amount];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="279完全平方数"><a class="markdownIt-Anchor" href="#279完全平方数">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/" >279. 完全平方数 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、数学、数组初始化、边界处理</strong></p>
<p>我们使用 dp 数组记录每个值所需的完全平方数的最小数量，递推公式也很好推导， <code>dp[i] = Math.min(dp[i],dp[i-j]+dp[j]);</code> ，我们只要遍历可能的两个和的组合即可。如果检测出数本身就是完全平方数，那么我们直接赋值为 1 即可，就不用进行遍历了。这题也可以通过数学推导使用更容易的方法解决。更好的递推公式为 <code>dp[j]=Math.min(dp[j-i*i),dp[j])</code> 。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        ArrayList&lt;Integer&gt; ping = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>, <span class="number">121</span>, <span class="number">144</span>, <span class="number">169</span>, <span class="number">196</span>, <span class="number">225</span>, <span class="number">256</span>, <span class="number">289</span>, <span class="number">324</span>, <span class="number">361</span>, <span class="number">400</span>, <span class="number">441</span>,<span class="number">484</span>, <span class="number">529</span>, <span class="number">576</span>, <span class="number">625</span>, <span class="number">676</span>, <span class="number">729</span>, <span class="number">784</span>, <span class="number">841</span>, <span class="number">900</span>, <span class="number">961</span>, <span class="number">1024</span>, <span class="number">1089</span>, <span class="number">1156</span>, <span class="number">1225</span>, <span class="number">1296</span>, <span class="number">1369</span>, <span class="number">1444</span>, <span class="number">1521</span>, <span class="number">1600</span>,<span class="number">1681</span>, <span class="number">1764</span>, <span class="number">1849</span>, <span class="number">1936</span>, <span class="number">2025</span>, <span class="number">2116</span>, <span class="number">2209</span>, <span class="number">2304</span>, <span class="number">2401</span>, <span class="number">2500</span>, <span class="number">2601</span>, <span class="number">2704</span>, <span class="number">2809</span>, <span class="number">2916</span>, <span class="number">3025</span>, <span class="number">3136</span>, <span class="number">3249</span>,<span class="number">3364</span>, <span class="number">3481</span>, <span class="number">3600</span>, <span class="number">3721</span>, <span class="number">3844</span>, <span class="number">3969</span>, <span class="number">4096</span>, <span class="number">4225</span>, <span class="number">4356</span>, <span class="number">4489</span>, <span class="number">4624</span>, <span class="number">4761</span>, <span class="number">4900</span>, <span class="number">5041</span>, <span class="number">5184</span>, <span class="number">5329</span>, <span class="number">5476</span>,<span class="number">5625</span>, <span class="number">5776</span>, <span class="number">5929</span>, <span class="number">6084</span>, <span class="number">6241</span>, <span class="number">6400</span>, <span class="number">6561</span>, <span class="number">6724</span>, <span class="number">6889</span>, <span class="number">7056</span>, <span class="number">7225</span>, <span class="number">7396</span>, <span class="number">7569</span>, <span class="number">7744</span>, <span class="number">7921</span>, <span class="number">8100</span>, <span class="number">8281</span>,<span class="number">8464</span>, <span class="number">8649</span>, <span class="number">8836</span>, <span class="number">9025</span>, <span class="number">9216</span>, <span class="number">9409</span>, <span class="number">9604</span>, <span class="number">9801</span>));</span><br><span class="line"></span><br><span class="line">        Arrays.fill(dp,<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ping.contains(i))&#123;</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                dp[i] = Math.min(dp[i],dp[i-j]+dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数学</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPerfectSquare(n)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkAnswer4(n)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - i * i;</span><br><span class="line">            <span class="keyword">if</span> (isPerfectSquare(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为完全平方数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) Math.sqrt(x);</span><br><span class="line">        <span class="keyword">return</span> y * y == x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否能表示为 4^k*(8m+7)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkAnswer4</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (x % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            x /= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x % <span class="number">8</span> == <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="139单词拆分"><a class="markdownIt-Anchor" href="#139单词拆分">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/" >139. 单词拆分 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：覆盖问题、动态规划、字符串切分、字符串比较</strong></p>
<p>我的思路是记录从 0 到 i 是否已经连接，因为是需要拼接出字符串，因此我将字符匹配到的末尾位置设置为 1，同时需要匹配到的开头与旧有的拼接字符串相连才能够设置为 1。我这个想法，与其说是动态规划，其实更像是记忆化搜索。dp [i] 意味着 s 从 0 到 i 的所形成的字符串能够使用当前的 wordDict 进行拼接而成。动态规划的思想应该是 [0, i - 1] 的字符串可被拆分，当前仅当任一子串 [0, j - 1] 及 [j, i - 1] 可被拆分，很巧妙的想法，将大问题拆分成两个子问题。因此如果确定 dp [j] 为 true，且 [j,i] 这个区间的子字符串出现在字典中，那么 dp [i] 一定是 true。本来这题我看到就想放弃，但是后面还解决处理，虽然没有答案这么巧妙，但是好歹也算是解决了。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)&#123;<span class="comment">//i表示背包当前的大小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;wordDict.size();j++)&#123;<span class="comment">//遍历物品</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> wordDict.get(j);</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> word.length();</span><br><span class="line">                <span class="comment">//进行字符串匹配</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k+len&lt;=i;k++)&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> s.substring(k,k+len);</span><br><span class="line">                    <span class="keyword">if</span>(temp.compareTo(word)==<span class="number">0</span> &amp;&amp; dp[k]==<span class="number">1</span>)&#123;</span><br><span class="line">                        dp[k+len] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[s.length()]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 可以类比于背包问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// memo[i] 表示 s 中索引为 [0,  i - 1] 范围的字符串是否可被 wordDict 拆分</span></span><br><span class="line">        <span class="type">boolean</span>[] memo = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        memo[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">// [0, i - 1] 的字符串可被拆分，当前仅当任一子串 [0, j - 1] 及 [j, i - 1] 可被拆分</span></span><br><span class="line">                <span class="keyword">if</span> (memo[j] &amp;&amp; wordDict.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    memo[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="121买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#121买卖股票的最佳时机">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/" >121. 买卖股票的最佳时机 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：贪心算法、动态规划</strong></p>
<p>由于这题只允许一次交易，我们只需使用 min 记录目前遇到的最小值，然后使用 ans 记录当前的最大利润。然后遍历数组即可得到最大利润。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> min=prices[<span class="number">0</span>],ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:prices)&#123;</span><br><span class="line">            ans = Math.max(ans,num-min);</span><br><span class="line">            min = Math.min(min,num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="122买卖股票的最佳时机-ii-2"><a class="markdownIt-Anchor" href="#122买卖股票的最佳时机-ii-2">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/" >122. 买卖股票的最佳时机 II <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、二维 dp 数组</strong></p>
<p>使用二维 dp 数组来分别记录每天持有和不持有股票的状态， <code>dp[i][0]</code>  表示第 i 天持有股票所得的现金， <code>dp[i][1]</code>  表示第 i 天不持有股票所得的最多现金。每次遍历都有两种选择，一种是维持现状，一种是选择卖出股票或买入股票。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="comment">//dp[i][0]表示第i天持有股票所得的现金</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]);<span class="comment">//买入所以减</span></span><br><span class="line">            <span class="comment">//dp[i][1]表示第i天不持有股票所得的最多现金</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);<span class="comment">//卖出所以加</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="123买卖股票的最佳时机-iii"><a class="markdownIt-Anchor" href="#123买卖股票的最佳时机-iii">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/" >123. 买卖股票的最佳时机 III <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、二维 dp 数组、贪心算法</strong></p>
<p>这题最大的改变就是限制了两次售出，因此通过四个元素来表示第一次购买，第一次售出，第二次购买，第二次售出，最后输出第二次售出的利润即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">4</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">3</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="188买卖股票的最佳时机-iv"><a class="markdownIt-Anchor" href="#188买卖股票的最佳时机-iv">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/" >188. 买卖股票的最佳时机 IV <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、二维 dp 数组</strong></p>
<p>这题和上一题一样的思想，只是状态变多了。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>*k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;<span class="number">2</span>*k;j+=<span class="number">2</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*k-<span class="number">1</span>;j+=<span class="number">2</span>)&#123;</span><br><span class="line">                dp[i][j+<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][j+<span class="number">1</span>],dp[i-<span class="number">1</span>][j]-prices[i]);</span><br><span class="line">                dp[i][j+<span class="number">2</span>] = Math.max(dp[i-<span class="number">1</span>][j+<span class="number">2</span>],dp[i-<span class="number">1</span>][j+<span class="number">1</span>]+prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">2</span>*k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="309最佳买卖股票时机含冷冻期"><a class="markdownIt-Anchor" href="#309最佳买卖股票时机含冷冻期">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/" >309. 最佳买卖股票时机含冷冻期 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划</strong></p>
<p>和上面的题目一样，记录持有和不持有两种状态，由于这题增加了冷冻期的概念，因此我们多添加一个状态用于记录售卖前的值。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:prices)&#123;</span><br><span class="line">            dp[<span class="number">0</span>] = Math.max(dp[<span class="number">0</span>],dp[<span class="number">1</span>]-num);</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">2</span>] = Math.max(dp[<span class="number">2</span>],dp[<span class="number">0</span>]+num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="417买卖股票的最佳时机含手续费"><a class="markdownIt-Anchor" href="#417买卖股票的最佳时机含手续费">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" >417. 买卖股票的最佳时机含手续费 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划</strong></p>
<p>只需在 122 买卖股票的基础上，在卖出股票时减去手续费即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="comment">//dp[i][0]表示第i天持有股票所得的现金</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]);<span class="comment">//买入所以减</span></span><br><span class="line">            <span class="comment">//dp[i][1]表示第i天不持有股票所得的最多现金</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]-fee);<span class="comment">//卖出所以加</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="300最长递增子序列"><a class="markdownIt-Anchor" href="#300最长递增子序列">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/" >300. 最长递增子序列 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、子序列、贪心算法、二分查找</strong></p>
<p>我想着是从左到右来寻找这个最长的递增子序列，我的想法是将每个元素依次拼在前面的子序列上，然后记录最大的长度。由于是要拼接上去，因此 <code>dp[i]</code>  表示以第 i 个元素结尾能够形成的最长子序列。遇到当前元素大于前面的元素的时候，就检验是否能够形成一个更长的子序列。由于每个元素自己一定能够形成一个长度为一的子序列，因此我为 dp 数组初始化为 1。还有一种非常巧妙的方法就是贪心 + 二分查找，我们可以维护这样一个数列，遍历数组，如果当前元素大于数列的最后一个元素，就在数列后面加上该元素；否则在数列中进行二分查找，找到第一个比当前元素小的数，然后将该元素的后一个元素替换为当前元素。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                    ans = Math.max(ans,dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贪心+二分查找</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        d[len] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; d[len]) &#123;</span><br><span class="line">                d[++len] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r = len, pos = <span class="number">0</span>; <span class="comment">// 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="674最长连续递增序列"><a class="markdownIt-Anchor" href="#674最长连续递增序列">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/" >674. 最长连续递增序列 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、贪心算法</strong></p>
<p>由于这题要求的是连续递增的序列，因此思路就比较简单了，我们只需使用一个值记录，遍历整个数组，如果比前一个元素大，值加一，否则重新开始计数，将值设置为 1。然后每次记录遍历到的最大值即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>,max=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//System.out.println(ans);</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                ans+=<span class="number">1</span>;</span><br><span class="line">                max = Math.max(max,ans);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="718最长重复子数组"><a class="markdownIt-Anchor" href="#718最长重复子数组">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/" >718. 最长重复子数组 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二维 dp 数组、边界处理、动态规划</strong></p>
<p>这题可以看做是 300 题的升级版，我们需要同时记录两个数组之间的信息，因此我们需要的是一个二维的 dp 数组， <code>dp[i][j]</code>  记录 nums1 以 i-1 为结尾和 nums2 以 j-1 为结尾的公共的最长的子数组长度，-1 是因为左侧和上方都需要设置边界方便计算。然后如果 <code>nums1[i]=nums2[j]</code> ，那么我们就将 <code>dp[i][j] = dp[i-1][j-1]+1;</code> ，相当于是往后拼接上一个元素。如果不相等则为 0，因为 dp 数组的初始值即为 0，因此不用处理。由于右下角的元素不一定是最长的重复子数组，因此我们还需要在遍历的过程中记录遍历到的最大值，以此作为答案。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length+<span class="number">1</span>][nums2.length+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=nums2.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    ans = Math.max(ans,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="1143最长公共子序列"><a class="markdownIt-Anchor" href="#1143最长公共子序列">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/" >1143. 最长公共子序列 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二维 dp 数组、动态规划、子序列问题</strong></p>
<p>这题与后面 397 题的思路一模一样，我们只需把后面判断长度改为在遍历中记录最大值即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] st = text1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] tt = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[st.length+<span class="number">1</span>][tt.length+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=st.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tt.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st[i-<span class="number">1</span>]==tt[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[st.length][tt.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="1035不相交的线"><a class="markdownIt-Anchor" href="#1035不相交的线">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/" >1035. 不相交的线 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、无法解决</strong></p>
<p>这题居然是上面一题换皮而成的题目，答案稍作修改就可以解答了，有种智商被侮辱的感觉，太难顶了。我还一直在想怎么判断两条直线是否相连，如何让端点不重复，这些复杂的物理问题。实际上可以转化为这样的问题，直线不能相交说明在 A 中找到一个与 B 相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，那么链接相同数字的直线就不会相交。简直太巧妙了，同时也感到自己真的有点死板，题目换一种表述方式就不会了，应该学会透过现象看本质。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length+<span class="number">1</span>][nums2.length+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=nums2.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i-<span class="number">1</span>]==nums2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums1.length][nums2.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="392判断子序列"><a class="markdownIt-Anchor" href="#392判断子序列">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/" >392. 判断子序列 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键字：贪心算法、双指针、字符串转字符数组、动态规划、边界处理，二维 dp 数组</strong></p>
<p>由于此题要求子序列的相对次序不会改变，因此我们可以使用两个指针分别指向两个字符串的开头，为了方便遍历，我们首先将两个字符串转换为字符数组。然后我们进行判断，如果此时两个指针所指的元素相等则同时加一，表示两个匹配成功，否则子序列的指针不变，继续等待匹配，而父序列的指针加一往后移动。最后判断子序列指针是否走到末尾即可知道是否是子序列。由于是动态规划专题，我也使用了动态规划的方法来解决该题，由于是两个字符序列，因此我们使用一个二维的 dp 数组来记录信息， <code>dp[i][j]</code>  表示字符 s 前 i-1 为何字符 t 前 j-1 位匹配出的最长子序列长度，为什么不是第 i 位和第 j 位呢？因为第一行和第一列需要给边界值赋值。然后转移方程为如果 s [i]==t [j]，说明可以同时拼接到后面，因此是 <code>dp[i][j] = dp[i-1][j-1]+1;</code> ；否则应该是取上方和左方的最大值，因为字符串延长，两者的匹配长度应该是递增的。根据书上所理解，在不相等的情况下甚至不需要取最大值，直接取左方的值即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] st = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] tt = t.toCharArray();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;st.length &amp;&amp; j&lt;tt.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i]==tt[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i==st.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] st = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] tt = t.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[st.length+<span class="number">1</span>][tt.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=st.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tt.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st[i-<span class="number">1</span>]==tt[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[st.length][tt.length] == st.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="115不同的子序列"><a class="markdownIt-Anchor" href="#115不同的子序列">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/" >115. 不同的子序列 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、编辑距离、无法解决、二维 dp 数组</strong></p>
<p>这题想了很久都还是没有办法解决。我们使用 <code>dp[i][j]</code>  记录以 i-1 为结尾的 s 子序列中出现以 j-1 为结尾的 t 子序列的个数，有两种不同的情况，一种是 <code>s[i-1]=t[j-1]</code> ，此时 <code>dp[i][j]</code>  由两部分解决，一部分是用 <code>s[i-1]</code>  匹配字符串，个数为 <code>dp[i-1][j-1]</code> ，一部分是不用 <code>s[i-1]</code>  匹配字符串，个数是 <code>dp[i-1][j]</code> ，这里是最难以理解的点，也是我卡住想不到的地方，就是在这里出现了次数的变化。如果不相等，情况就简单多了，只能使用 <code>dp[i-1][j]</code>  的进行匹配。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] st = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] tt = t.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[st.length+<span class="number">1</span>][tt.length+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;st.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=st.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tt.length &amp;&amp; j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st[i-<span class="number">1</span>]==tt[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[st.length][tt.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="583两个字符串的删除操作"><a class="markdownIt-Anchor" href="#583两个字符串的删除操作">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/" >583. 两个字符串的删除操作 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、二维 dp 数组、编辑距离</strong></p>
<p>这题由 1143 题最长公共子序列变种而来，通过删除两个字符串的字符使其相等的最小步数就等价于找到两个字符串的最长公共子序列，然后将其他多余的元素删除。我们只要计算出最长公共子序列的长度，然后即可计算出多余元素的个数。或者另外的动态规划思想是模拟字符串的删除操作，遇到不相同只有两种情况，一种是从 Word1 中删除，一种是从 Word2 中删除。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] st = word1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] tt = word2.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[st.length+<span class="number">1</span>][tt.length+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=st.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tt.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st[i-<span class="number">1</span>]==tt[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> st.length+tt.length - <span class="number">2</span>*dp[st.length][tt.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种动态规划思想</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word1.length(), n = word2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化，当自身长度为0时，只有将对方元素全部去掉才能相等</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> word1.charAt(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> word2.charAt(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//从Word1中删除一个元素或者从Word2中删除一个元素</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="72编辑距离"><a class="markdownIt-Anchor" href="#72编辑距离">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/" >72. 编辑距离 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：动态规划、二维 dp 数组、编辑距离</strong></p>
<p>这题由上面一题变化而来，只是操作变多了，一共有三种操作：增加、删除和替换。由于删除 A 的字符与 B 增加字符是等价的，因此写删除的情况就可以覆盖增加的情况，这样就可以使问题变得更简单一些。dp 数组的定义和初始化和上一题都是一样的，我们需要处理两种情况，如果相等的话，我们就无需处理， <code>dp[i][j]=dp[i-1][j-1]</code> ；重点是不相等的情况，我们可以将其分为删除和替换两种操作，替换的话则是将目前不相等的两个元素，将其中一个替换成另外一个，因此操作数是 <code>dp[i-1][j-1]+1</code> ，前面部分的操作数加上替换这次的操作数；如果是删除，则要选择是删除 Word1，还是 Word2，因此操作数是 <code>min(dp[i][j-1],dp[i-1][j])+1</code> ，前面的操作数加上删除一次的操作数。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s1 = word1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] s2 = word2.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s1.length+<span class="number">1</span>][s2.length+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化，长度都为0的时候无需操作，当自身为0，要把对方全部元素删除才能相等</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s1.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s2.length;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s2.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>])&#123;<span class="comment">//相等则无需任何操作</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//选择删除Word1还是Word2的字符，删除A的字符与B增加字符是等价的，因此不用写增加的情况。</span></span><br><span class="line">                    min = Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]);</span><br><span class="line">                    <span class="comment">//选择是删除字符</span></span><br><span class="line">                    dp[i][j] = Math.min(min,dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s1.length][s2.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="647回文子串"><a class="markdownIt-Anchor" href="#647回文子串">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/" >647. 回文子串 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二维 dp 数组、动态规划、回文字符</strong></p>
<p>遇到这题，我们首先思考它的 dp 数组，我们可以使用一个二维数组，分别记录开始位置和结束位置是否能形成回文子串，如果 <code>s[i]=s[j]</code> ，我们要思考什么情况下，这个是回文子串，我们只需要它中间位置也是回文子串即可，也即 <code>dp[i+1][j-1]=true</code> ，但是这样会遗漏一种情况，那就是如果 i 和 j 是相邻的情况，我们把这个情况加入即可。如果头尾都不相等，那么肯定不能形成回文子串。初始化就是将全部设置为 false，遍历顺序在这题里面是有关系的，由于 <code>dp[i][j]</code>  的判断依赖 <code>dp[i+1][j-1]</code> ，因此我们应该从下到上，从左到右进行遍历，最后在遍历的过程中设置计数器计数即可。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s1 = s.toCharArray();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s1.length][s1.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s1.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;s1.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==i)&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s1[i]==s1[j] &amp;&amp; (dp[i+<span class="number">1</span>][j-<span class="number">1</span>] || i==j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="516最长回文子序列"><a class="markdownIt-Anchor" href="#516最长回文子序列">#</a> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/" >516. 最长回文子序列 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2>
<p><strong>关键词：二维 dp 数组、动态规划、回文字符</strong></p>
<p>由于回文子序列是不要求连续的，因此我们对上题的代码进行微调，首先我们设置 dp 数组的意义， <code>dp[i][j]]</code>  表示以 i 为起始范围，以 j 为终止范围之间的最长回文子串的长度。与上题同理，遍历顺序也应该是从下到上，从左到右。在遍历的过程中，会遇到两种情况，一种是 <code>s[i]=s[j]</code> ，这种情况下有两种可能，如果 i=j，则回文字符的长度为 1，否则在 <code>dp[i+1][j-1]</code>  的基础上加 2，不用担心无法形成回文子序列，因为不要求连续，所以 <code>dp[i+1][j-1]</code>  至少为 1 且可以与 <code>s[i]</code>  和 <code>s[j]</code>  构成回文子串。如果两者不相等，那么就使用 <code> dp[i][j] = Math.max(dp[i][j-1],dp[i+1][j]);</code>  获取最长一侧的回文子序列。最后返回右上角的值即为最终答案。如果进行初始化 i=j 的情况，则在相等的情况下无需条件判断。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s1 = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s1.length][s1.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s1.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;s1.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i]==s1[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] +<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>],dp[i+<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s1.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> </li>
        <li><strong>作者:</strong> xiqin</li>
        <li><strong>创建于
                :</strong> 2023-10-12 18:49:32</li>
        
            <li>
                <strong>更新于
                    :</strong> 2023-04-05 19:45:14
            </li>
        
        <li>
            <strong>链接:</strong> https://xiqin.com/2023/10/12/java/Java刷题/代码随想录/
        </li>
        <li>
            <strong>
                版权声明:
            </strong>
            
            本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 进行许可。
            

        </li>
    </ul>
</div>

            </div>
        

        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                        rel="prev"
                        href="/2023/10/12/java/Linux-%E9%9F%A9%E9%A1%BA%E5%B9%B3/Linux-%E9%9F%A9%E9%A1%BA%E5%B9%B3/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">Linux-韩顺平</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                        rel="next"
                        href="/2023/10/12/java/%E9%9F%A9%E9%A1%BA%E5%B9%B3%20%E9%9B%B6%E5%9F%BA%E7%A1%8030%E5%A4%A9%E5%AD%A6%E4%BC%9AJava/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">零基础30天学会Java-韩顺平-98</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">此页目录</div>
        <div class="page-title"></div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E7%BB%84"><span class="nav-text"> 第一章 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#704%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-text"> 704. 二分查找 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-text"> 27. 移除元素 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#209%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text"> 209. 长度最小的子数组 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#59%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-ii"><span class="nav-text"> 59. 螺旋矩阵 II </span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%93%BE%E8%A1%A8"><span class="nav-text"> 第二章 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#203%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="nav-text"> 203. 移除链表元素 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#707%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="nav-text"> 707. 设计链表 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text"> 206. 反转链表 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-text"> 19. 删除链表的倒数第 N 个结点 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii"><span class="nav-text"> 14. 环形链表 II </span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text"> 第三章 哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#242%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-text"> 242. 有效的字母异位词 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#349%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="nav-text"> 349. 两个数组的交集 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-text"> 1. 两数之和 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#454%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0-ii"><span class="nav-text"> 454. 四数相加 II </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-text"> 15. 三数之和 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-text"> 18. 四数之和 </span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text"> 第四章 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#344%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text"> 344. 反转字符串 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#541%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-ii"><span class="nav-text"> 541. 反转字符串 II </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#151%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="nav-text"> 151. 反转字符串中的单词 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87"><span class="nav-text"> 28. 找出字符串中第一个匹配项的下标 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#459%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text"> 459. 重复的字符串 </span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="nav-text"> 第五章 栈与队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#232%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-text"> 232. 用栈实现队列 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#225%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="nav-text"> 225. 用队列实现栈 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-text"> 20. 有效的括号 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#150%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-text"> 150. 逆波兰表达式求值 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#239%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-text"> 239. 滑动窗口最大值 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#347%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="nav-text"> 347. 前 K 个高频元素 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-text"> 42. 接雨水 </span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text"> 第六章 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-text"> 递归算法三要素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#144%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text"> 144. 二叉树的前序遍历 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text"> 94. 二叉树的中序遍历 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text"> 145. 二叉树的后序遍历 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text"> 102. 二叉树的层序遍历 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87offer27%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-text"> 剑指 offer27. 二叉树的镜像 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text"> 101. 对称二叉树 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-text"> 104. 二叉树的最大深度 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#111%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="nav-text"> 111. 二叉树的最小深度 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text"> 110. 平衡二叉树 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#257%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="nav-text"> 257. 二叉树的所有路径 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#112%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="nav-text"> 112. 路径总和 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-ii"><span class="nav-text"> 113. 路径总和 II </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#106%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text"> 106. 从中序与后序遍历序列构造二叉树 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text"> 105. 从前序与中序遍历序列构造二叉树 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#617%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text"> 617. 合并二叉树 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#700%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="nav-text"> 700. 二叉搜索树中的搜索 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text"> 98. 验证二叉搜索树 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#530%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="nav-text"> 530. 二叉搜索树的最小绝对差 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#501%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="nav-text"> 501. 二叉搜索树中的众数 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-text"> 236. 二叉树的最近公共祖先 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#235%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-text"> 235. 二叉搜索树的最近公共祖先 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#701%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-text"> 701. 二叉搜索树中的插入操作 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#450%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-text"> 450. 删除二叉搜索树中的节点 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#669%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text"> 669. 修剪二叉搜索树 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#108%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text"> 108. 将有序数组转换为二叉搜索树 </span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-text"> 第七章 回溯算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%89%E9%83%A8%E6%9B%B2"><span class="nav-text"> 回溯算法三部曲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#77%E7%BB%84%E5%90%88"><span class="nav-text"> 77. 组合 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#216%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-iii"><span class="nav-text"> 216. 组合总和 III </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="nav-text"> 17. 电话号码的字母组合 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-text"> 39. 组合总和 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-ii"><span class="nav-text"> 40. 组合总和 II </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#131%E5%88%87%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-text"> 131. 切割回文串 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#93%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80"><span class="nav-text"> 93. 复原 IP 地址 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#73%E5%AD%90%E9%9B%86"><span class="nav-text"> 73. 子集 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#90%E5%AD%90%E9%9B%86-ii"><span class="nav-text"> 90. 子集 II </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#491%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text"> 491. 递增子序列 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-text"> 46. 全排列 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47%E5%85%A8%E6%8E%92%E5%88%97-ii"><span class="nav-text"> 47. 全排列 II </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#51n%E7%9A%87%E5%90%8E"><span class="nav-text"> 51.N 皇后 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37%E8%A7%A3%E6%95%B0%E7%8B%AC"><span class="nav-text"> 37. 解数独 </span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-text"> 第八章 贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#455%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="nav-text"> 455. 分发饼干 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#376%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="nav-text"> 376. 摆动序列 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-text"> 53. 最大子数组和 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#122%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii"><span class="nav-text"> 122. 买卖股票的最佳时机 II </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="nav-text"> 55. 跳跃游戏 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii"><span class="nav-text"> 45. 跳跃游戏 II </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#134%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="nav-text"> 134. 加油站 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#135%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="nav-text"> 135. 分发糖果 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#860%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="nav-text"> 860. 柠檬水找零 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#452%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="nav-text"> 452. 用最少数量的箭引爆气球 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="nav-text"> 26. 合并区间 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#738%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text"> 738. 单调递增的数字 </span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text"> 第九章 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BA%94%E9%83%A8%E6%9B%B2"><span class="nav-text"> 动态规划五部曲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#509%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="nav-text"> 509. 斐波那契数 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#70%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-text"> 70. 爬楼梯 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#746%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-text"> 746. 使用最小花费爬楼梯 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="nav-text"> 62. 不同路径 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#63%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-ii"><span class="nav-text"> 63. 不同路径 II </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#343%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="nav-text"> 343. 整数拆分 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text"> 96. 不同的二叉搜索树 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84"><span class="nav-text"> 一维滚动数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#416%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-text"> 416. 分割等和子集 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#494%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="nav-text"> 494. 目标和 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#474%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="nav-text"> 474. 一和零 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text"> 完全背包问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#518%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii"><span class="nav-text"> 518. 零钱兑换 II </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#377%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-iv"><span class="nav-text"> 377. 组合总和 Ⅳ </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#322%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-text"> 322. 零钱兑换 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#279%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="nav-text"> 279. 完全平方数 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#139%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-text"> 139. 单词拆分 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="nav-text"> 121. 买卖股票的最佳时机 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#122%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii-2"><span class="nav-text"> 122. 买卖股票的最佳时机 II </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#123%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-iii"><span class="nav-text"> 123. 买卖股票的最佳时机 III </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#188%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-iv"><span class="nav-text"> 188. 买卖股票的最佳时机 IV </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#309%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="nav-text"> 309. 最佳买卖股票时机含冷冻期 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#417%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9"><span class="nav-text"> 417. 买卖股票的最佳时机含手续费 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#300%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text"> 300. 最长递增子序列 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#674%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97"><span class="nav-text"> 674. 最长连续递增序列 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#718%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text"> 718. 最长重复子数组 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1143%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text"> 1143. 最长公共子序列 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1035%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF"><span class="nav-text"> 1035. 不相交的线 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#392%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text"> 392. 判断子序列 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#115%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text"> 115. 不同的子序列 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#583%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-text"> 583. 两个字符串的删除操作 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#72%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-text"> 72. 编辑距离 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#647%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-text"> 647. 回文子串 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#516%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text"> 516. 最长回文子序列 </span></a></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2022</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">xiqin</a>
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">访问人数</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">总访问量</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span>
            <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.5.0</a></span>
        </div>
        
        
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>



    
<script src="/js/tools/localSearch.js" type="module"></script>




    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>







<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/libs/anime.min.js"></script>

        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


</body>
</html>
